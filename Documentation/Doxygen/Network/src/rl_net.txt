/**
\defgroup netGen_Func IP Address
\brief IP Address functions can be used for various purposes.
\details
MDK Middleware is now part of two MDK editions: MDK-Professional and MDK-Plus. While users of MDK-Professional can use the
IPv4/IPv6 dual-stack, users of MDK-Plus have access to the IPv4 implementation only. This is important when working with IP
addresses. MDK-Plus users can still provide an IPv6 address (\ref NET_ADDR_IP6) as a function parameter. But in this case,
the IPv4-only library will fail with the error code \ref netInvalidParameter.

The following routines are not reentrant.
*/

/**
\defgroup netGen_AddrConvFunc Conversion Functions
\ingroup netGen_Func
\brief Convert network addresses from ASCII to binary and vice versa.
\details
The address conversion functions are used for conversion of IP or MAC addresses from binary to ASCII strings and vice versa.
*/

/**
\defgroup netSys_Func System Functions (User)
\brief Core system functions to be called by user
\details
System Functions represent the core of the protocol stack. They form an operating system that calls all other protocol
module functions. The functions require a CMSIS-RTOS compatible RTOS to run and are not reentrant.

The functions are part of the Network Component library and are defined in \b %rl_net.h.
*/


//  ==== TCP Enumerations;  ====
/**
\defgroup netTCP_Enums Enumerations
\ingroup netTCP_Func
\brief Enumerations of the TCP Socket Interface
@{

\typedef netTCP_Event
\details
<b>Parameter for:</b>
 - \ref netTCP_cb_t

\typedef netTCP_State
\details
<b>Returned by:</b>
 - \ref netTCP_GetState

\typedef netTCP_Option
\details
<b>Parameter for:</b>
 - \ref netTCP_SetOption
@}
*/

/**
\ingroup tcp_user_api
@{
*/

/// TCP Event callback function.

/** 
\typedef uint32_t (*netTCP_cb_t)(int32_t socket, netTCP_Event event, const NET_ADDR *addr, const uint8_t *buf, uint32_t len)

\param[in] socket   TCP socket handle.
\param[in] event    Event type as shown in the table below (\ref netTCP_Event).
\param[in] addr     Pointer to the structure containing the remote IP address and port number.    
\param[in] buf      Pointer to buffer containing the received data.
\param[in] len      Number of bytes in the received packet.
\returns   Integer Value used to decide whether to accept or reject an incoming connection (see details).
           - \b 1 - incoming connection accepted.
           - \b 0 - incoming connection rejected.

\details
Is the type definition for the TCP callback function. The Network Core calls the callback function whenever
a TCP event occurs.

The argument \a socket is the TCP socket handle of the local machine.

The argument \a addr is a pointer to the buffer containing the IP address and port of the remote machine.

The argument \a event specifies the type of event that occurred as shown in the table below or \ref netTCP_Event.

The argument \a buf points to a buffer containing the received data.

The argument \a len specifies the number of received data bytes.

The Network Core uses the return value of the callback function only when the event is \token{netTCP_EventConnect}.
It uses the return value to decide whether to accept or reject an incoming connection when the TCP socket is
listening. If the listener function returns \token{1}, then it accepts the incoming connection. 
If the listener function returns \token{0}, it rejects the incoming connection. Thus, you can define the listener function to
selectively reject incoming connections from particular IP addresses.

|Event Type         |Description                                                                                 |
|-------------------|--------------------------------------------------------------------------------------------|
|\token{netTCP_EventConnect}    |A Connect Request has been received from a remote client that wants to connect to the server|
|\token{netTCP_EventEstablished}|The TCP socket has connected to the remote machine                                          |
|\token{netTCP_EventClosed}     |The TCP connection has been properly closed                                                 |
|\token{netTCP_EventAbort}      |The TCP connection has been aborted                                                         |
|\token{netTCP_EventACK}        |Acknowledgment has been received from the remote host for the previously sent data          |
|\token{netTCP_EventData}       |A TCP data packet has been received                                                         |

<b>Parameter for:</b>
 - \ref netTCP_GetSocket
 
<b>Code Example TCP Client</b>
\code
uint32_t tcp_cb_func (int32_t socket, netTCP_Event event,
                      const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
 
  switch (event) {
    case netTCP_EventConnect:
      // Connect request received in server mode
      break;
 
    case netTCP_EventEstablished:
      // Connection established
      break;
 
    case netTCP_EventClosed:
      // Connection was properly closed
      break;
 
    case netTCP_EventAborted:
      // Connection is for some reason aborted
      break;
 
    case netTCP_EventACK:
      // Previously sent data acknowledged
      break;
 
    case netTCP_EventData:
      // Data received
      break;
  }
  return (0);
}
\endcode

<b>Code Example TCP Server</b>
\code
uint32_t tcp_cb_func (int32_t socket, netTCP_Event event,
                      const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
 
  switch (event) {
    case netTCP_EventConnect:
      // Connect request received in server mode
      if (addr->addr_type == NET_ADDR_IP4) {
        // IPv4 client
        if (addr->addr[0] == 192  &&
            addr->addr[1] == 168  &&
            addr->addr[2] == 0    &&
            addr->addr[3] == 1) {
          // Accept connection from client at 192.168.0.1
          return (1);
        }
      }
      else {
        // IPv6 client
        const uint8_t ip6_addr[NET_ADDR_IP6_LEN] = { 
                         0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                         0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
        if (memcmp (addr->addr, ip6_addr, NET_ADDR_IP6_LEN) == 0) {
          // Accept connection from client at [fe80::1c30:6cff:fea2:455e]
          return (1);
        }
      }
      // Deny connection.
      return (0);
 
    case netTCP_EventEstablished:
      // Connection established
      break;
 
    case netTCP_EventClosed:
      // Connection was properly closed
      break;
 
    case netTCP_EventAborted:
      // Connection is for some reason aborted
      break;
 
    case netTCP_EventACK:
      // Previously sent data acknowledged
      break;
 
    case netTCP_EventData:
      // Data received
      if ((buf[0] == 0x01) && (len == 2)) {
        // Switch LEDs on and off
        // LED_SetOut (buf[1]);
      }
      break;
  }
  return (0);
}
\endcode
*/

/**
@}
*/

//  ==== UDP Enumerations;  ====
/**
\defgroup netUDP_Enums Enumerations
\ingroup netUDP_Func
\brief Enumerations of the UDP Socket Interface
@{

\typedef netUDP_Option
\details
<b>Parameter for:</b>
 - \ref netUDP_SetOption
@}
*/

/**
\ingroup udp_user_api
*/

/// UDP Event callback function.

/**
\typedef uint32_t (*netUDP_cb_t)(int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len)

\param[in] socket   UDP socket handle.
\param[in] addr     Pointer to the structure containing the remote IP address and port number.
\param[in] buf      Pointer to buffer containing the received data.
\param[in] len      Number of bytes in the received packet.
\returns   <i>Currently not used. Reserved for future use.</i>

\details
Is the type definition for the UDP callback function.
The Network Core calls the callback function whenever a UDP data packet is received. Users must provide the function.

The argument \a socket is the UDP socket handle of the local machine.

The argument \a addr is a pointer to the buffer containing the IP address and port of the remote machine, and the IP version
IPv4 or IPv6.

The argument \a buf points to a buffer containing the received data.

The argument \a len specifies the number of received data bytes. The maximum size of a received data is:

|IP Version   |Maximum data size  |Fragmentation supported |
|-------------|-------------------|------------------------|
|\token{IPv4} |2000 bytes         |Yes                     |
|\token{IPv6} |2000 bytes         |Yes                     |

If the IP fragmentation is not supported or is disabled in the configuration, received fragmented IP packets are dumped 
by the stack automatically. Therefore, it is not possible to receive mega UDP frames up to 64K.
 
<b>Parameter for:</b>
 - \ref netUDP_GetSocket
 
\note
- The IPv4 fragmentation must be enabled in the Network interface configuration.
 
\b Code \b Example
\code
uint32_t udp_cb_func (int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
 
  // Data received
  if ((buf[0] == 0x01) && (len == 2)) {
    // Switch LEDs on and off
    // LED_SetOut (buf[1]);
  }
  return (0);
}
\endcode

\b Code \b Example \b IPv4 \b only
\code
uint32_t udp_cb_func (int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
 
  if (addr->addr_type == NET_ADDR_IP6) {
    // Dump IPv6 data
    return (0);
  }
  if ((buf[0] == 0x01) && (len == 2)) {
    // Switch LEDs on and off
    // LED_SetOut (buf[1]);
  }
  return (0);
}
\endcode

*/

//  ==== Common interface Enumerations;  ====
/**
\defgroup netInterfaces_Enums Enumerations
\ingroup netInterfaces_Common
\brief Common enumerations for all Interfaces.
@{
\typedef netIF_Option
\details
<b>Parameter for:</b>
 - \ref netIF_GetOption
 - \ref netIF_SetOption

\typedef netIF_Version
\details
<b>Parameter for:</b>
 - \ref netIF_SetDefault

\typedef netARP_CacheType
\details
<b>Parameter for:</b>
 - \ref netARP_CacheIP

\typedef netARP_Event
\details
<b>Parameter for:</b>
 - \ref netARP_cb_t

\typedef netNDP_Event
\details
<b>Parameter for:</b>
 - \ref netNDP_cb_t

\typedef netDHCP6_Mode
\details
<b>Parameter for:</b>
 - \ref netDHCP6_Enable
@}
*/

//  ==== Ethernet Enumerations;  ====
/**
\defgroup netETH_Enums Enumerations
\ingroup netETH_Func
\brief Enumerations of the Ethernet Interface
@{
\typedef netETH_Event
\details
<b>Parameter for:</b>
 - \ref netETH_Notify
@}
*/

//  ==== WiFi Enumerations;  ====
/**
\defgroup netWiFi_Enums Enumerations
\ingroup netWiFi_Func
\brief Enumerations of the WiFi Interface
@{
\typedef netWiFi_Security
\details
<b>Parameter for:</b>
 - \ref netWiFi_Activate
 - \ref netWiFi_GetNetInfo
 - \ref netWiFi_Scan

\typedef netWiFi_Option
\details
<b>Parameter for:</b>
 - \ref netWiFi_GetOption
 - \ref netWiFi_SetOption

\typedef netWiFi_WPS
\details
<b>Parameter for:</b>
 - \ref netWiFi_Activate
@}
*/

/**
\ingroup common_user_api
*/

/// ARP Probe Event callback function.

/** 
\typedef void (*netARP_cb_t)(netARP_Event event)
\param[in] event - Probe event as defined in \ref netARP_Event.
\return    none.

\details
Is the type definition for the Probe callback function. Users must provide the function.
The callback function uses the \a event argument to signal one of the following Probe events:

|Event           |Description                                             |
|----------------|--------------------------------------------------------|
|\token{netARP_EventSuccess}|Remote host responded to ARP probe.                      |
|\token{netARP_EventTimeout}|Probe session has timed out, remote host did not respond.|

<b>Parameter for:</b>
 - \ref netARP_Probe
*/

/**
\ingroup common_user_api
*/

/// NDP Probe Event callback function.

/**
\typedef void (*netNDP_cb_t)(netNDP_Event event)
\param[in] event - Probe event as defined in \ref netNDP_Event.
\return    none.

\details
Is the type definition for the Probe callback function. Users must provide the function.
The callback function uses the \a event argument to signal one of the following Probe events:

|Event           |Description                                             |
|----------------|--------------------------------------------------------|
|\token{netNDP_EventSuccess}|Remote host responded to NDP probe.                      |
|\token{netNDP_EventTimeout}|Probe session has timed out, remote host did not respond.|

<b>Parameter for:</b>
 - \ref netNDP_Probe
*/


//  ==== Ping Client ====

/// Ping Callback Events.
/**
\defgroup netPing_Enums Enumerations
@{
\brief 	Enumerations for the Ping Client. 
\ingroup netPing_Func
\typedef netPing_Event
\details
<b>Parameter for:</b>
 - \ref netPing_cb_t
@}
*/


/// Ping Event callback function.

/** 
\ingroup netPing_Func
\typedef void (*netPing_cb_t)(netPing_Event event)

\param[in] event - Ping event as defined in \ref netPing_Event.
\return    none.

\details
Is the type definition for the Ping callback function. Users must provide the function.
The callback function uses the \a event argument to signal one of the following Ping events:

|Event                       |Description                                             |
|----------------------------|--------------------------------------------------------|
|\token{netPing_EventSuccess}|Remote host responded to ping.                          |
|\token{netPing_EventTimeout}|Ping session has timed out, remote host did not respond.|

<b>Parameter for:</b>
 - \ref netPing_Echo
*/


//  ==== DNS Client Enumerations;  ====
/**
\defgroup netDNS_Enums Enumerations
\ingroup netDNSc_Func
\brief Enumerations of the DNS Client
@{
\typedef netDNSc_Event
\details
<b>Parameter for:</b>
 - \ref netDNSc_cb_t
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\ingroup starting_dns
*/

/// DNS Client Event callback function.

/** 
\typedef void (*netDNSc_cb_t)(netDNSc_Event event, const NET_ADDR *addr)

\param[in] event    DNS client event type as defined in \ref netDNSc_Event.
\param[in] addr     Pointer to the structure containing resolved IP address of the host name.
\return    none.

\details
Is the type definition for the DNS callback function. 
The function is invoked by the DNS client when an event ends the DNS session. The DNS client specifies the event 
and the host IP address (in case of \token{netDNSc_EventSuccess}) when calling the function.

<b>Parameter for:</b>
 - \ref netDNSc_GetHostByName

\b Code \b Example
\code
static void dns_cbfunc (netDNSc_Event event, const NET_ADDR *addr) {
  char ip_ascii[40];
  
  switch (event) {
    case netDNSc_EventSuccess:
      // Host Address successfully resolved
      netIP_ntoa (addr->addr_type, adr->addr, ip_ascii, sizeof(ip_ascii));
      printf("IP Address: %s\n", ip_ascii);
      break;
 
    case netDNSc_EventNotResolved:
      // Error, host name does not exist in DNS record database
      break;
 
    case netDNSc_EventTimeout:
      // Error, DNS resolver timeout expired
      break;
 
    case netDNSc_EventError:
      // Error, DNS protocol error occurred
      break;
  }
}
\endcode
*/

//  ==== FTP Server Enumerations;  ====
/**
\defgroup netFTPs_Enums Enumerations
\ingroup netFTPs_Func
\brief Enumerations of the FTP Server.
@{
\typedef netFTPs_Event
\details
<b>Parameter for:</b>
 - \ref netFTPs_Notify
@}
*/

//  ==== FTP Client Enumerations;  ====
/**
\defgroup netFTPc_Enums Enumerations
\ingroup netFTPc_Func
\brief Enumerations of the FTP Client.
@{
\typedef netFTP_Command
\details
<b>Parameter for:</b>
 - \ref netFTPc_Connect

\typedef netFTPc_Request
\details
<b>Parameter for:</b>
 - \ref netFTPc_Process

\typedef netFTPc_Event
\details
<b>Parameter for:</b>
 - \ref netFTPc_Notify
@}
*/

//  ==== TFTP Client Enumerations;  ====
/**
\defgroup netTFTPc_Enums Enumerations
\ingroup netTFTPc_Func
\brief Enumerations of the TFTP Client.
@{
\typedef netTFTPc_Event
\details
<b>Parameter for:</b>
 - \ref netTFTPc_Notify
@}
*/

//  ==== TELNET Server Enumerations;  ====
/**
\defgroup netTELNET_Enums Enumerations
\ingroup netTELNET_Func
\brief Enumerations of the Telnet Server.
@{
\typedef netTELNETs_Message
\details
<b>Parameter for:</b>
 - \ref netTELNETs_ProcessMessage
@}
*/

//  ==== SMTP Client Enumerations;  ====
/**
\defgroup netSMTPc_Enums Enumerations
\ingroup netSMTPc_Func
\brief Enumerations of the SMTP Client.
@{
\typedef netSMTPc_Request
\details
<b>Parameter for:</b>
 - \ref netSMTPc_Process

\typedef netSMTPc_Event
\details
<b>Parameter for:</b>
 - \ref netSMTPc_Notify
@}
*/

//  ==== SNTP Client Enumerations;  ====
/**
\defgroup netSNTPc_Enums Enumerations
\ingroup netSNTPc_Func
\brief Enumerations of the SNTP Client.
@{
\typedef netSNTPc_Mode
\details
<b>Parameter for:</b>
 - \ref netSNTPc_SetMode
@}
*/

/**
\ingroup starting_sntp
*/

/// SNTP Client callback function.

/** 
\typedef void (*netSNTPc_cb_t)(uint32_t seconds, uint32_t seconds_fraction);
\param[in] seconds           time in seconds,
\param[in] seconds_fraction  fraction of seconds.
\return    none.

\details
Is the type definition for the SNTP callback function. Users must provide the function.
The function is called by the SNTP client when an NTP message is received from the
server.

The \a seconds argument of the callback function signals the time, specified
in seconds, elapsed since 1.1.1970 (Unix epoch). A value of \token{0} reports an error.

The argument \a seconds_fraction signals the fraction of seconds. 

<b>Parameter for:</b>
 - \ref netSNTPc_GetTime
*/

//  ==== Network native API ====

/**
\addtogroup netSys_Func
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netInitialize (void)
\details
The function \b netInitialize initializes the Network Core's system resources, protocols, threads and applications. Since the
function also creates RTOS objects, the RTOS must be previously initialized.

\note You must call the function at system start-up to properly initialize the networking environment.

Possible \ref netStatus return values:
- \em netOK: Network Core initialized successfully.
- \em netError: Failed to initialize the Network Core.

\b Code \b Example
\code
int main (void) {
 
  init_hal ();
  // Initialize the Network Core 
  netInitialize ();
   ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUninitialize (void)
\details
The function \b netUninitialize de-initializes the Network Core's system resources, protocols, threads and applications. Network
drivers are de-initialized and powered off. After calling this function the networking environment is in initial state. To use
it again, you must call \ref netInitialize function again.

Possible \ref netStatus return values:
- \em netOK: Network Core de-initialized successfully.
- \em netError: Failed to de-initialize the Network Core.

\b Code \b Example
\code
int main (void) {
 
  init_hal ();
  // Initialize the Network Core 
  netInitialize ();
   ..
  // Uninitialize the Network Core
  netUninitialize (); 
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netSYS_GetHostName (void)
\details
The function \b netSYS_GetHostName returns the name of the local host. The name is set with \c NET_HOST_NAME in the 
\b Net_Config.h, and can be changed at \ref nw_runtime_config "runtime". 

\b Code \b Example
\code
printf ("Localhost name is %s\n", netSYS_GetHostName ());
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSYS_SetHostName (const char *hostname)
\details
The function \b netSYS_SetHostName sets the name of the local host. Default name is set with \c NET_HOST_NAME in the 
\b Net_Config.h, and can be changed at \ref nw_runtime_config "runtime". 

The argument \a hostname is a pointer to the localhost name that is to be set, which is a \token{null}-terminated string.
The function copies the content of the \a hostname to the localhost name. The maximum length of the \a hostname string is
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Host name successfully set.
- \em netInvalidParameter: Invalid \a hostname provided.

\note
When the function ends, the content of \a hostname becomes irrelevant and may be discarded. 

\b Code \b Example
\code
netSYS_SetHostName ("MCB1800");
printf ("Localhost name is %s\n", netSYS_GetHostName ());
\endcode
*/
/**
@}
*/

//  ==== BSD Socket structures ====
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   bsd_structs  Structures
\ingroup    netBSD_Func
\brief      Structures of the BSD Socket
@{
\struct SOCKADDR
\details
<b>Parameter for:</b>
 - \ref accept,
   \ref bind,
   \ref connect,
   \ref getpeername,
   \ref getsockname,
   \ref recvfrom,
   \ref sendto

\struct IN_ADDR
\details
<b>Parameter for:</b>
 - \ref SOCKADDR_IN structure
 - \ref inet_ntoa
 - \ref inet_aton
 
\struct IN6_ADDR
\details
<b>Parameter for:</b>
 - \ref SOCKADDR_IN6 structure

\struct SOCKADDR_IN
\details
<b>Used in:</b>
 - \ref bind,
   \ref connect,
   \ref sendto

\struct SOCKADDR_IN6
\details
<b>Used in:</b>
 - \ref bind,
   \ref connect,
   \ref sendto

\struct SOCKADDR_STORAGE
\details
The structure is sufficiently large to store \ref SOCKADDR_IN or SOCKADDR_IN6 address information.

\struct HOSTENT
\details
<b>Returned by:</b>
 - \ref gethostbyname

\struct timeval
\details
<b>Used in:</b>
 - \ref select

\struct fd_set
\details
<b>Used in:</b>
 - \ref select

\struct IOVEC
\details
<b>Used in:</b>
 - \ref recvmsg
 - \ref sendmsg

\struct MSGHDR
\details
<b>Used in:</b>
 - \ref recvmsg
 - \ref sendmsg

\struct CMSGHDR
\details
<b>Used in:</b>
 - \ref recvmsg
 - \ref sendmsg
@}
*/

//  ==== BSD Socket Error codes ====
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   bsd_errors  Error Codes
\ingroup    netBSD_Func
\brief      BSD Socket error codes
@{
\details
The Error Codes section lists all the return errors that the BSD functions will return. Error codes are negative numbers.
This makes it easy to check errors, when the return code is less than 0. 

|Error Code             |Description                         |
|-----------------------|------------------------------------|
|\ref BSD_ERROR         |Unspecified error                   |
|\ref BSD_ESOCK         |Invalid socket descriptor           |
|\ref BSD_EINVAL        |Invalid parameter                   |
|\ref BSD_ENOTSUP       |Operation or feature not supported  |
|\ref BSD_ENOMEM        |Not enough memory                   |
|\ref BSD_ELOCKED       |Socket locked by another thread     |
|\ref BSD_EWOULDBLOCK   |Operation would block               |
|\ref BSD_ETIMEDOUT     |Operation timed out                 |
|\ref BSD_EINPROGRESS   |Operation in progress               |
|\ref BSD_ENOTCONN      |Socket not connected                |
|\ref BSD_EISCONN       |Socket is connected                 |
|\ref BSD_ECONNREFUSED  |Connection rejected by the peer     |
|\ref BSD_ECONNRESET    |Connection reset by the peer        |
|\ref BSD_ECONNABORTED  |Connection aborted locally          |
|\ref BSD_EALREADY      |Connection already in progress      |
|\ref BSD_EADDRINUSE    |Address already in use              |
|\ref BSD_EDESTADDRREQ  |Destination address required        |
|\ref BSD_EHOSTNOTFOUND |Host not found                      |
|\ref BSD_EMSGSIZE      |Message too large                   |

\def BSD_ERROR
\def BSD_ESOCK
\def BSD_EINVAL
\def BSD_ENOTSUP
\def BSD_ENOMEM
\def BSD_ELOCKED
\def BSD_EWOULDBLOCK
\def BSD_ETIMEDOUT
\def BSD_EINPROGRESS
\def BSD_ENOTCONN
\def BSD_EISCONN
\def BSD_ECONNREFUSED
\def BSD_ECONNRESET
\def BSD_ECONNABORTED
\def BSD_EALREADY
\def BSD_EADDRINUSE
\def BSD_EDESTADDRREQ
\def BSD_EHOSTNOTFOUND
\def BSD_EMSGSIZE
@}
*/

/**
\addtogroup using_network_sockets_bsd_func
@{
*/

//  ==== BSD Socket API ====
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t socket (int32_t family, int32_t type, int32_t protocol)
\details
The function \b socket creates a communication endpoint called a socket.

The argument \a family specifies the address family. Currently, only \ref AF_INET and \ref AF_INET6 address families are supported.
By default, the IPv4 socket operates over the IPv4 protocol, the IPv6 socket operates over the IPv6 protocol. To convert an
IPv6 socket to a dual-stack socket, the \ref setsockopt function must be called with the \ref IPV6_V6ONLY socket option
to set this value to zero before the socket is bound to an IP address. When communicating with a dual-stack socket, the socket
can operate via both, IPv4 or IPv6.

The argument \a type specifies the communication semantics. The following are the currently supported types:
|Type               |Description                                                         |
|-------------------|--------------------------------------------------------------------|
|\token{SOCK_STREAM}|Provides a reliable connection based data stream that is full-duplex|
|\token{SOCK_DGRAM} |Provides connectionless communication that is unreliable            |

The argument \a protocol specifies the protocol that must be used with socket type:
|Protocol   |Description                                                       |
|-----------|------------------------------------------------------------------|
|\token{IPPROTO_TCP}|Must be used with SOCK_STREAM socket type                 |
|\token{IPPROTO_UDP}|Must be used with SOCK_DGRAM socket type                  |
|\token{0}          |The system selects a matching protocol for the socket type|

\note
- You must call the \b socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an \b error \b code.

\b Code \b Example (Stream Socket)
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, sd, res;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, SOCK_STREAM, 0);
 
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
    listen (sock, 1);
    sd = accept (sock, NULL, NULL);
    closesocket (sock);
    sock = sd;
 
    while (1) {
      res = recv (sock, dbuf, sizeof (dbuf), 0);
      if (res <= 0) {
        break;
      }
      if (dbuf[0] == BLINKLED) {
        LED_SetOut (dbuf[1]);
      }
    }
    closesocket (sock);
  }
}
\endcode

\b Code \b Example (Datagram Socket)
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, res;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, SOCK_DGRAM, 0);
 
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
 
    while (1) {
      res = recv (sock, dbuf, sizeof (dbuf), 0);
      if (res <= 0) {
        break;
      }
      if (dbuf[0] == BLINKLED) {
        LED_SetOut (dbuf[1]);
      }
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t bind (int32_t sock, const SOCKADDR *addr, int32_t addrlen)
\details
The function \b bind assigns a name to an unnamed socket. The name represents the local address and port of the communication
endpoint.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a addr is a pointer to the SOCKADDR structure containing the local address and port of the socket. If the port
is specified as \token{0}, the Network Core assigns a unique port from the dynamic client port range (ephemeral ports). 

The argument \a addrlen specifies the length of the SOCKADDR structure.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.
- You can retrieve the assigned dynamic port with \ref getsockname function.

\b Code \b Example (see \ref socket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t listen (int32_t sock, int32_t backlog)
\details
The function \b listen sets the specified socket to listening mode. Before calling the \b listen function, the \ref bind
function must be called.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a backlog specifies a maximum number of connection requests that can be accepted.

This is different from the standard BSD listening function. The reason for this is that BSD sockets in the network component
are just a layer on top of native \ref netTCP_Func. TCP sockets, however, are static, meaning that they are defined at compile
time and are not dynamically allocated objects.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example (see \ref socket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t accept (int32_t sock, SOCKADDR *addr, int32_t *addrlen)
\details
The function \b accept accepts a connection request queued for a listening socket. If a connection request is pending,
\b accept removes the request from the queue, and a new socket is created for the connection. The original listening socket
remains open and continues to queue new connection requests. The socket \a sock must be a \b SOCK_STREAM type socket.

In blocking mode, which is enabled by default, this function waits for a connection request. In
non blocking mode, you must call the \b accept function again if the error code \c BSD_EWOULDBLOCK is returned.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a addr is a pointer to the SOCKADDR structure that will receive the connection node IP address and port number.

The argument \a addrlen is a pointer to the address length. It should initially contain the amount of space pointed to by
\a addr. On return it contains the actual length of the address returned in bytes.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example (see \ref socket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t connect (int32_t sock, const SOCKADDR *addr, int32_t addrlen)
\details
The function \b connect assigns the address of the peer communication endpoint. The function behaves differently according to
the type of socket: 

- \b SOCK_STREAM: A connection is established between the endpoints.

  In blocking mode, which is enabled by default, this function waits for a connection to be established.

  In non blocking mode, the function returns the error code \c BSD_EINPROGRESS and the connection is established asynchronously.
  Subsequent calls to \b connect for the same socket, before the connection is established, return the error code \c BSD_EALREADY.
  When the connection is established, the call to \b connect returns the error code \c BSD_EISCONN. 

- \b SOCK_DGRAM: An address filter is established between the endpoints.

  The address filter is changed with another \b connect function call. If the socket is not yet bound, the system implicitly
  binds to a random dynamic port.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a addr is a pointer to the SOCKADDR structure that contains the endpoint node IP address and port number.

The argument \a addrlen specifies the length of SOCKADDR structure.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
void Client_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, res, lshift;
  int32_t type = (int32_t)arg;
  char dbuf[4];
  uint8_t p2val;
 
  while (1) {
    sock = socket (AF_INET, type, 0);
 
    addr.sin_port      = htons(PORT_NUM);
    addr.sin_family    = AF_INET;
    addr.sin_addr.s_b1 = IP1;
    addr.sin_addr.s_b2 = IP2;
    addr.sin_addr.s_b3 = IP3;
    addr.sin_addr.s_b4 = IP4;
 
    connect (sock, (SOCKADDR *)&addr, sizeof (addr));
 
    lshift = 1;
    p2val  = 0x01;
    while (1) {
      // Shift the LEDs 
      LED_SetOut (p2val);
      p2val = lshift ? (p2val << 1) : (p2val >> 1);
      if (p2val == 0x80) lshift = 0;
      if (p2val == 0x01) lshift = 1;
    
      // Send the data to LED Server.
      dbuf[0] = BLINKLED;
      dbuf[1] = p2val;
      res = send (sock, (char *)&dbuf, 2, 0);
      if (res < 0) {
        break;
      }
      osDelay (100 * SPEED);
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t send (int32_t sock, const char *buf, int32_t len, int32_t flags)
\details
The function \b send is used to send data on an already connected socket. This function is normally used to send a reliable,
ordered stream of data bytes on a \b SOCK_STREAM socket type. It can also be used to send datagrams on a \b SOCK_DGRAM socket
types.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a buf is a pointer to the application data buffer containing data to transmit. The buffer data length is not
limited in size. If the data length is too large for one packet, the \b send function will fragment the data and send it in
several successive data packets:
- In blocking mode, which is enabled by default, this function returns after the data has been successfully queued for transmission.
- In non blocking mode, the function returns immediately without blocking the system.

The argument \a len specifies the length of data in bytes. The argument \a flags specifies the message flags:

|Flag                |Description|
|--------------------|-----------|
|\token{MSG_DONTWAIT}|The function returns with error code \c BSD_EWOULDBLOCK or <b>number of bytes</b> sent instead of blocking the socket|

Return value, when positive, represents the number of bytes sent, which can be less than \a len.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents locally detected error code.

\b Code \b Example (see \ref connect)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t sendto (int32_t sock, const char *buf, int32_t len, int32_t flags, const SOCKADDR *to, int32_t tolen)
\details
The function \b sendto is used to send data. It is normally used to send messages on a \b SOCK_DGRAM socket type, but can also
be used to send data on a connected \b SOCK_STREAM socket type.

If the socket type is \b SOCK_DGRAM and the socket is not yet bound, the system implicitly binds to a random dynamic port.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a buf is a pointer to the application data buffer containing data to transmit. The buffer data length is not
limited in size. If the data length is too large for one packet, the \b sendto function will fragment the data and send it
in several successive data packets:
- In blocking mode, which is enabled by default, this function returns after the data has been successfully queued for transmission.
- In non blocking mode, the function returns immediately without blocking the system.

The argument \a len specifies the length of data in bytes. The argument \a flags specifies the message flags:
|Flag                |Description|
|--------------------|-----------|
|\token{MSG_DONTWAIT}|The function returns with error code \c BSD_EWOULDBLOCK or <b>number of bytes</b> sent instead of blocking the socket|

The argument \a to is a pointer to the SOCKADDR structure that contains the endpoint node IP address and port number.

The argument \a tolen specifies the length of SOCKADDR structure.

If the socket type is \b SOCK_STREAM, arguments \a to and \a tolen are ignored.

Return value, when positive, represents the number of bytes sent, which can be less than \a len.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents locally detected error code.

\b Code \b Example
\code
void Client_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, res, lshift;
  char dbuf[4];
  uint8_t p2val;
 
  while (1) {
    sock = socket (AF_INET, SOCK_DGRAM, 0);
 
    addr.sin_port      = htons(PORT_NUM);
    addr.sin_family    = AF_INET;
    addr.sin_addr.s_b1 = IP1;
    addr.sin_addr.s_b2 = IP2;
    addr.sin_addr.s_b3 = IP3;
    addr.sin_addr.s_b4 = IP4;
 
    lshift = 1;
    p2val  = 0x01;
    while (1) {
      // Shift the LEDs 
      LED_SetOut (p2val);
      p2val = lshift ? (p2val << 1) : (p2val >> 1);
      if (p2val == 0x80) lshift = 0;
      if (p2val == 0x01) lshift = 1;
 
      // Send the data to LED Server.
      dbuf[0] = BLINKLED;
      dbuf[1] = p2val;
      res = sendto (sock, (char *)&dbuf, 2, 0, (SOCKADDR *)&addr, sizeof (addr));
      if (res < 0) {
        break;
      }
      osDelay (100 * SPEED);
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t sendmsg (int32_t sock, const MSGHDR *msg, int32_t flags)
\details
The function \b sendmsg is used to send a message from a \b SOCK_STREAM or \b SOCK_DGRAM socket. It is normally used with
\b SOCK_DGRAM sockets because it permits the application to specify the destination address where the message is to be sent to.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a msg is a pointer to the \b msghdr structure, containing both the destination address and the buffers for 
the outgoing message. 

- The \a msg_name member is a pointer to the SOCKADDR structure that contains the IP address and port number of the endpoint node.
If \a msg_name is \token{NULL}, the destination address specified with a call to \ref connect function is used.

- The \a msg_namelen member is the address length in bytes.

- The \a msg_iov member is a pointer to scatter/gatther array of type \a IOVEC. This array can specify one or more buffers,
containing the data to be sent. 

- The \a msg_iovlen member contains the number of \a IOVEC buffers, that are available in the \a IOVEC array.

- The \a msg_control member is a pointer to a buffer, that contains the ancillary data. 

- The \a msg_controllen member is the ancillary data length.

- The \a msg_flags member is ignored.

The argument \a flags specifies the message flags.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
char msg1[] = { "Message part 1" };
char msg2[] = { "Message part 2" };
char msg3[] = { "Message part 3" };
SOCKADDR_IN addr;
MSGHDR  msg;
IOVEC   iov[3];
  
  sock = socket (AF_INET, SOCK_DGRAM, 0);
 
  // Specify destination address
  addr.sin_family = AF_INET;
  addr.sin_port   = htons(1025);
  addr.sin_addr   = inet_addr("10.0.0.1");
 
  // Specify message buffers
  iov[0].iov_base = &msg1;
  iov[0].iov_len  = strlen(msg1);
  iov[1].iov_base = &msg2;
  iov[1].iov_len  = strlen(msg2);
  iov[2].iov_base = &msg3;
  iov[2].iov_len  = strlen(msg3);
     
  // Construct message header
  msg.msg_iov        = &iov[0];
  msg.msg_iovlen     = 3;
  msg.msg_name       = &addr;
  msg.msg_namelen    = sizeof(addr);
  msg.msg_control    = NULL;
  msg.msg_controllen = 0;

  res = sendmsg (sock, &msg, 0);
  if (res <= 0) {
    // Error
  }
  closesocket (sock);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t recv (int32_t sock, char *buf, int32_t len, int32_t flags)
\details
The function \b recv receives incoming data that has been queued for the socket. This function can be used with both
\b SOCK_STREAM and \b SOCK_DGRAM type sockets. It reads as much information as currently available up to the size of the
buffer specified. The excess data is treated differently according to the type of socket:

- \b SOCK_STREAM: The excess data is buffered internally.

  The application can retrieve all data by multiple calls of \b recv function.

- \b SOCK_DGRAM: The excess message data is silently discarded. 

  The data is extracted from the first enqueued datagram. If the datagram or message is larger than the buffer specified,
  the buffer is filled with the first part of the datagram, the excess data of this datagram is silently discarded.
  All subsequent messages that are enqueued, are retained. The message size is currently limited to 2000 characters.
  You need to enable \b IP \b Fragmentation in the interface configuration so that you can receive 2000 byte datagram messages.

In blocking mode, which is enabled by default, this function waits for received data. In non
blocking mode, you must call the \b recv function again if the error code \c BSD_EWOULDBLOCK is returned.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a buf is a pointer to the application data buffer for storing the data to.
 
The argument \a len specifies the size of the application data buffer.

The argument \a flags specifies the message flags:

|Flag                |Description|
|--------------------|-----------|
|\token{MSG_DONTWAIT}|The function returns with error code \c BSD_EWOULDBLOCK or <b>number of bytes</b> received instead of blocking the socket.|
|\token{MSG_PEEK}    |The function peeks at incoming data. The data is copied into the buffer, but is not removed from the input queue.|

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example (see \ref socket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t recvfrom (int32_t sock, char *buf, int32_t len, int32_t flags, SOCKADDR *from, int32_t *fromlen)
\details
The function \b recvfrom is used to receive data that has been queued for a socket. It is normally used to receive messages
on \b SOCK_DGRAM socket type, but can also be used to receive a reliable, ordered stream of data on a connected \b SOCK_STREAM
socket type. It reads as much information as currently available up to the size of the buffer specified. The excess data is
treated differently according to the type of socket:

- \b SOCK_STREAM: The excess data is buffered internally.

  The application can retrieve all data by multiple calls of \b recvfrom function.

- \b SOCK_DGRAM: The excess message data is silently discarded. 

  The data is extracted from the first enqueued datagram. If the datagram or message is larger than the buffer specified,
  the buffer is filled with the first part of the datagram, the excess data of this datagram is silently discarded.
  All subsequent messages that are enqueued, are retained. The message size is currently limited to 2000 characters.
  You need to enable \b IP \b Fragmentation in the interface configuration so that you can receive 2000 byte datagram messages.

In blocking mode, which is enabled by default, this function waits for received data. In non
blocking mode, you must call the \b recvfrom function again if the error code \c BSD_EWOULDBLOCK is returned.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a buf is a pointer to the application data buffer for storing the data to.

The argument \a len specifies the size of the application data buffer.

The argument \a flags specifies the message flags:

|Flag                |Description|
|--------------------|-----------|
|\token{MSG_DONTWAIT}|The function returns with error code \c BSD_EWOULDBLOCK or <b>number of bytes</b> received instead of blocking the socket.|
|\token{MSG_PEEK}    |The function peeks at incoming data. The data is copied into the buffer, but is not removed from the input queue.|

The argument \a from is a pointer to the SOCKADDR structure. If \a from is not \token{NULL}, the source IP address and port number
of the datagram will be filled in.

The argument \a fromlen is a pointer to the address length. It should initially contain the amount of space pointed to by
\a from. On return it contains the actual length of the address returned in bytes.

If the socket type is \b SOCK_STREAM, arguments \a from and \a fromlen are ignored.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.
- The number of bytes actually read can be less than \a len. 

\b Code \b Example
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, res, addrlen;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, SOCK_DGRAM, 0);
 
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
 
    while (1) {
      addrlen = sizeof (addr);
      res = recvfrom (sock, dbuf, sizeof (dbuf), 0, (SOCKADDR *)&addr, &addrlen);
      if (res <= 0) {
        break;
      }
      procrec ((uint8_t *)dbuf);
      printf ("Remote IP:   %s\n", inet_ntoa(addr.sin_addr));
      printf ("Remote port: %d\n", ntohs (addr.sin_port));
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t recvmsg (int32_t sock, MSGHDR *msg, int32_t flags)
\details
The function \b recvmsg is used to receive a message from a \b SOCK_STREAM or \b SOCK_DGRAM socket. It is normally used with
\b SOCK_DGRAM sockets because it permits the application to retrieve the source address of received data.

In blocking mode, which is enabled by default, this function waits for received data. In non
blocking mode, you must call the \b recvmsg function again if the error code \c BSD_EWOULDBLOCK is returned.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a msg is a pointer to the \b msghdr structure, containing both the buffer to store the source address and
the buffers for the incoming message. 

- The \a msg_name member is a pointer to the SOCKADDR structure. If \a msg_name is not \token{NULL}, the source IP address 
and port number of the datagram will be filled in.

- The \a msg_namelen member is the address length. It should initially contain the amount of space pointed to by
\a msg_name. On return it contains the actual length of the address returned in bytes.

- The \a msg_iov member is a pointer to scatter/gatther array of type \a IOVEC. This array can specify one or more buffers,
where the received data shall be stored. 

- The \a msg_iovlen member contains the number of \a IOVEC buffers, that are available in the \a IOVEC array.

- The \a msg_control member is a pointer to a buffer, that will receive ancillary data.

- The \a msg_controllen member is the buffer length. It should initially contain the amount of space pointed to by
\a msg_control. On return it contains the actual length of the control data returned in bytes.
The control data can be processed with the following macros:

|Macro name            |Description                 |
|----------------------|----------------------------|
|CMSG_FIRSTHDR(mhdr)   |Returns a pointer to the first CMSGHDR structure in the \a mhdr.|
|CMSG_NXTHDR(mhdr,cmsg)|Returns a pointer to the CMSGHDR structure describing the next ancillary data object.|
|CMSG_DATA(cmsg)       |Returns a pointer to the data of ancillary data object.|
|CMSG_ALIGN(len)       |Rounds the argument up to the next even multiple of 4 bytes.|
|CMSG_LEN(len)         |Gives the length of an ancillary data object without padding.|
|CMSG_SPACE(len)       |Gives the length of an ancillary data object including the padding needed.|

- The \a msg_flags member is ignored on input, but may contain meaningful values on output:

|Flag                |Description|
|--------------------|-----------|
|\token{MSG_TRUNC}   |Normal data was truncated, excess bytes are discarded in case of \b SOCK_DGRAM sockets. |
|\token{MSG_CTRUNC}  |Control data was truncated, ancillary data buffer is too small. |

The argument \a flags specifies the message flags:

|Flag                |Description|
|--------------------|-----------|
|\token{MSG_DONTWAIT}|The function returns with error code \c BSD_EWOULDBLOCK or <b>number of bytes</b> received instead of blocking the socket.|
|\token{MSG_PEEK}    |The function peeks at incoming data. The data is copied into the buffer, but is not removed from the input queue.|

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  IN_ADDR     dst_ip;
  MSGHDR  msg;
  IOVEC   iov;
  union {
    CMSGHDR  cm;
    uint8_t  raw[32];
  } control_un;
  CMSGHDR *cmsg;
  int32_t sock, res;
  char dbuf[4];
  char enable;
 
  while (1) {
    sock = socket (AF_INET, SOCK_DGRAM, 0);
 
    addr.sin_family      = AF_INET;
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_addr.s_addr = INADDR_ANY;
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
 
    // Enable receiving destination IPv4 address
    enable = 1;
    setsockopt (sock, IPPROTO_IP, IP_RECVDSTADDR, &enable, sizeof(enable));
 
    // Specify receive IO buffer
    iov.iov_base    = &dbuf[0];
    iov.iov_len     = sizeof(dbuf);
 
    // Construct message header
    msg.msg_iov         = &iov;
    msg.msg_iovlen      = 1;
    msg.msg_name        = &addr;
    msg.msg_namelen     = sizeof(addr);
    msg.msg_control     = &control_un.cm;
    msg.msg_controllen  = sizeof(control_un);

    while (1) {
      res = recvmsg (sock, &msg, 0);
      if (res <= 0) {
        break;
      }
 
      // Process control data
      for (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {
        if (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_RECVDSTADDR) {
          IN_ADDR *pia = (IN_ADDR *)CMSG_DATA(cmsg);
          dst_ip.sin_addr.s_addr = pia->s_addr;
        }
      }
 
      // Process normal data
      procrec ((uint8_t *)dbuf);
      printf ("Remote IP:   %s\n", inet_ntoa(addr.sin_addr));
      printf ("Remote port: %d\n", ntohs (addr.sin_port));
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t closesocket (int32_t sock)
\details
The function \b closesocket closes an existing socket and releases the socket descriptor. Further references to \c sock fail
with \c BSD_EINVAL error code.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

In blocking mode, which is enabled by default, this function will wait until a socket is closed.
In non blocking mode, you must call the \b closesocket function again if the error code \c BSD_EWOULDBLOCK is returned.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example (see \ref socket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t getpeername (int32_t sock, SOCKADDR *name, int32_t *namelen)
\details
The function \b getpeername retrieves the address of the peer to which a socket is connected.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a name is a pointer to the SOCKADDR structure. If \a name is not \token{NULL}, the remote end IP address and port
number will be filled in.

The argument \a namelen is a pointer to the address length. It should initially contain the amount of space pointed to by
\a name. On return it contains the actual length of the address returned in bytes.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, sd, res, addrlen;
  int32_t type = (int32_t)arg;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, type, 0);
 
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
 
    if (type == SOCK_STREAM) {
      listen (sock, 1);
      sd = accept (sock, NULL, NULL);
      closesocket (sock);
      sock = sd;
    }
 
    while (1) {
      res = recv (sock, dbuf, sizeof (dbuf), 0);
      if (res <= 0) {
        break;
      }
      procrec ((uint8_t *)dbuf);
      addrlen = sizeof (addr);
      getpeername (sock, (SOCKADDR *)&addr, &addrlen);
      printf ("Remote IP:   %s\n", inet_ntoa(addr.sin_addr));
      printf ("Remote port: %d\n", ntohs (addr.sin_port));
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t getsockname (int32_t sock, SOCKADDR *name, int32_t *namelen)
\details
The function \b getsockname retrieves the local address for a socket.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a name is a pointer to the SOCKADDR structure. If \a name is not \token{NULL}, the local IP address and port number
will be filled in.

The argument \a namelen is a pointer to the address length. It should initially contain the amount of space pointed to by
\a name. On return it contains the actual length of the address returned in bytes.

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, res, addrlen;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 
    addr.sin_port        = htons(1001);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof (addr));
 
    addrlen = sizeof (addr);
    getsockname (sock, (SOCKADDR *)&addr, &addrlen);
    printf ("Local IP:   %s\n", inet_ntoa(addr.sin_addr));
    printf ("Local port: %d\n", ntohs (addr.sin_port));
 
    while (1) {
      res = recv (sock, dbuf, sizeof (dbuf), 0);
      if (res <= 0) {
        break;
      }
      procrec ((uint8_t *)dbuf);
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t ioctlsocket (int32_t sock, long cmd, unsigned long *argp)
\details
The function \b ioctlsocket controls the I/O mode of a socket. It can be used on any socket in any state to set or retrieve
some operating parameters of the socket.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a cmd specifies a command to perform on a socket. The following commands are supported:
|Command               |Description                                                       |
|----------------------|------------------------------------------------------------------|
|\token{FIONBIO}       |Sets the blocking or non-blocking socket I/O mode                 |
|\token{FIO_DELAY_ACK} |Sets the delay-ack or normal mode for the stream socket           |
|\token{FIO_KEEP_ALIVE}|Sets the keep-alive or timeout mode for the stream socket         |
|\token{FIO_FLOW_CTRL} |Sets the receive flow-control or normal mode for the stream socket|

The argument \a argp specifies a pointer to the command's parameter.
\n For the command \b FIONBIO the argument values are:
|*argp value    |I/O mode         |
|---------------|-----------------|
|\token{0}      |Blocking mode    |
|\token{nonzero}|Non-blocking mode|

For the command \b FIO_DELAY_ACK the argument values are:
|*argp value    |Socket mode   |Description|
|---------------|--------------|-----------|
|\token{0}      |Normal mode   |Waits for an ACK after each sending packet|
|\token{nonzero}|Delay-ack mode|Eliminates the delayed acknowledge impact and improves the performance for applications sending large amount of data|

For the command \b FIO_KEEP_ALIVE the argument values are:
|*argp value    |Socket mode   |Description|
|---------------|--------------|-----------|
|\token{0}      |Timeout mode  |After a timeout a stream socket is disconnected|
|\token{nonzero}|Keep-alive mode|Stream socket sends keep alive segments on timeout to keep a connection alive|

For the command \b FIO_FLOW_CTRL the argument values are:
|*argp value    |Socket mode      |Description|
|---------------|-----------------|-----------|
|\token{0}      |Normal mode      |Stream socket dumps excess data, if the receiving buffer is full|
|\token{nonzero}|Flow-control mode|Stream socket controls the window size and stops the transmitter, if the receiving buffer is full|

\note
- You must call the \ref socket function before any other function calls to the BSD socket.
- Negative return numbers represent error codes.
- The \a blocking mode is enabled by default. 

\b Code \b Example
\code
void Server_Thread (void *arg) {
  int32_t sock, res;
  long sck_mode;
 
  sock = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
 
  // 0= blocking, 1= non-blocking 
  sck_mode = 1;
  res = ioctlsocket (sock, FIONBIO, &sck_mode);
  if (res == 0) {
    printf ("Nonblocking mode enabled.\n");
  }
  else {
    printf ("ioctlsocket() error\n!");
  }
  ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t setsockopt (int32_t sock, int32_t level, int32_t optname, const char *optval, int32_t optlen)
\details
The function \b setsockopt sets options for a socket. Options may exist at multiple protocol levels.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a level describes the level at which the option is defined (for example SOL_SOCKET).

The argument \a optname is the socket option for which the value is to be set. The \a optname argument must be
a socket option defined within the specified \a level. 

The argument \a optval points to the buffer containing the value of the \a optname.

The argument \a optlen tells the exact length of the option.

\b Code \b Example
\code
// Timeout 5 sec
int32_t timeout = 5000;
 
setsockopt (sock, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout, sizeof (timeout));
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t getsockopt (int32_t sock, int32_t level, int32_t optname, char *optval, int32_t *optlen)
\details
The function \b getsockopt retrieves options for a socket. Options may exist at multiple protocol levels.

The argument \a sock specifies a socket descriptor returned from a previous call to \ref socket.

The argument \a level describes the level at which the option is defined (for example SOL_SOCKET).

The argument \a optname is the socket option for which the value is to be retrieved and must be defined within the specified
\a level. 

The argument \a optval points to the buffer that will receive the value of the \a optname.

The argument \a optlen contains the length of the buffer at the input and returns the length of the option information on the output.

\b Code \b Example
\code
// Retrieve keep-alive mode for stream socket
char optval;
int32_t optlen = sizeof(optval);
 
getsockopt (sock, SOL_SOCKET, SO_KEEPALIVE, &optval, &optlen);
 
if (optval != 0) {
  printf ("Keep-alive mode is active.");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t select (int32_t nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout)
\details
The function \b select indicates which of the specified sockets is ready for reading, ready for writing, or has an error
condition pending. If the specified condition is false for all of the specified sockets, \b select blocks, up to the 
specified timeout interval, until the specified condition is true for at least one of the specified sockets. 

The argument \a nfds specifies the range of sockets to be tested. The \b select function tests sockets in the range 
of \token{0} to \a nfds-1.

The argument \a readfds specifies the set of sockets to be checked for being ready to read on input, and on output
indicates which sockets are ready to read. If the value of \a readfds is \token{NULL}, the sockets are not checked for
being ready to read.

The argument \a writefds specifies the set of sockets to be checked for being ready to write on input, and on output
indicates which sockets are ready to write. If the value of \a writefds is \token{NULL}, the sockets are not checked for
being ready to write.

The argument \a errorfds specifies the set of sockets to be checked for error conditions pending on input, and on output
indicates which sockets have error condition pending. If the value of \a errorfds is \token{NULL}, the sockets are not 
checked for error condition pending.

On exit, each set of sockets is modified in place to indicate which sockets actually changed status. Thus, if using
\b select within a loop, the sets must be reinitialized before each call.

The argument \a timeout specifies a maximum interval to wait for the selection to complete. If the value of \a timeout 
is \token{NULL}, the \b select function blocks until an event occurs. If both members of the \a timeout structure are
\token{0}, \b select function does not block.

The set of sockets of type \ref fd_set can be initialized and tested with the following macros: 

|Macro name       |Description                 |
|-----------------|----------------------------|
|FD_SET(fd, set)  |Sets the bit for the socket \a fd in the set of sockets specified with \a set.|
|FD_CLR(fd, set)  |Clears the bit for the socket \a fd in the set of sockets specified with \a set.|
|FD_ISSET(fd, set)|Returns a nonzero value if the bit for the socket \a fd is set in the set of sockets specified with \a set, and \token{0} otherwise.|
|FD_ZERO(set)     |Initialises the set of sockets \a set to have zero bits for all socket descriptors.|

\note
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
void Server_Thread (void *arg) {
  SOCKADDR_IN addr;
  int32_t sock, sd, res, addrlen;
  struct fd_set read_fds;
  char dbuf[4];
 
  while (1) {
    sock = socket (AF_INET, SOCK_STREAM, 0);
 
    addr.sin_port        = htons(PORT_NUM);
    addr.sin_family      = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
 
    bind (sock, (SOCKADDR *)&addr, sizeof(addr));
 
    listen (sock, 1);
    sd = accept (sock, NULL, NULL);
    closesocket (sock);
    sock = sd;
 
    while (1) {
      FD_ZERO (&read_fds);
      FD_SET (sock, &read_fds);
      res = select (sock+1, &read_fds, NULL, NULL, NULL);
      if (res <= 0) {
        break;
      }
      if (FD_ISSET (sock, &read_fds) {
        // Data is ready, recv will not block
        res = recv (sock, dbuf, sizeof (dbuf), 0);
        if (res <= 0) {
          break;
        }
        procrec ((uint8_t *)dbuf);
      }
    }
    closesocket (sock);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn HOSTENT *gethostbyname (const char *name, int32_t *err)
\details
The function \b gethostbyname retrieves host information corresponding to a host name from a host database.

The argument \a name is a pointer to the \token{null}-terminated name of the host to resolve.

The argument \a err is a pointer to the return error code.

\note
- To use this function, you must enable the \ref netDNSc_Func "DNS client" in the selection of RTE Components.
- If a negative number is returned, it represents an error code.

\b Code \b Example
\code
static const char *hosts[] = {
  "www.google.com",
  "www.keil.com",
  "www.microsoft.com",
  "www.yahoo.com",
  NULL
};
 
void Resolver_Thread (void *arg) {
  HOSTENT *host;
  IN_ADDR *addr;
  int32_t i, j, err;
 
  for (i = 0; ; i++) {
    if (hosts[i] == NULL) i = 0;
    printf ("Host: %s\n",hosts[i]);
 
    host = gethostbyname (hosts[i], &err);
    if (host == NULL) {
      if (err == BSD_EHOSTNOTFOUND) {
        printf ("Hostname does not exist\n");
      }
    }
    else if (host->h_addrtype == AF_INET) {
      for (j = 0; host->h_addr_list[j]; j++) {
        addr = (IN_ADDR *)host->h_addr_list[j];
        printf("IP Address: %s\n", inet_ntoa(addr->sin_addr));
      }
    }
    osDelay (300);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn IN_ADDR inet_addr (const char *cp)
\details
The function \b inet_addr converts the specified string to an integer value suitable for use as an Internet address.

The argument \a cp is a pointer to the \token{null}-terminated string in the standard IPv4 dotted decimal notation.

The function returns the converted Internet address on success, or \ref INADDR_NONE if failed.

\b Code \b Example (see \ref inet_aton)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t inet_aton (const char *cp, IN_ADDR *addr)
\details
The function \b inet_aton converts the specified string to a network address, and stores the address in the structure provided.

The argument \a cp is a pointer to the \token{null}-terminated string in the standard IPv4 dotted decimal notation.

The argument \a addr is a pointer to the buffer, where the converted address is to be stored.

The function returns \token{1} if the address is successfully converted, or \token{0} if the conversion failed.

\b Code \b Example
\code
struct sockaddr_in sa;
const char *some_addr;
 
inet_aton("10.0.0.1", &sa.sin_addr); // store IP in sa
 
some_addr = inet_ntoa(sa.sin_addr);  // return the IP
printf("%s\n", some_addr);           // prints "10.0.0.1"
 
// This call is the same as the inet_aton() call, above:
sa.sin_addr = inet_addr("10.0.0.1");
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *inet_ntoa (IN_ADDR in)
\details
The function \b inet_ntoa converts the specified Internet host address to a string in the standard dotted decimal notation.

The argument \a in is the Internet host address to be converted.

The function returns a pointer to the \token{null}-terminated string in the standard IPv4 dotted decimal notation.

\note The function uses a static buffer for the converted address and is therefore not thread safe.

\b Code \b Example (see \ref inet_aton)
*/
 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t inet_pton (int32_t af, const char *src, void *dst)
\details
The function \b inet_pton converts an address from presentation format to network format in network byte order.

The argument \a af specifies the address family. Currently, only \ref AF_INET and \ref AF_INET6 are supported.

The argument \a src is a pointer to the \token{null}-terminated presentation format address. The format of the address is
interpreted according to argument \a af.

The argument \a dst is a pointer to the buffer where the converted address is to be stored.

The function returns \token{1} if the address is successfully converted, or \token{0} if the conversion failed.

\b Code \b Example
\code
struct sockaddr_in sa;
char str[INET_ADDRSTRLEN];
 
// Store this IP address in sa
inet_pton(AF_INET, "192.168.0.100", &(sa.sin_addr));
 
// Now get it back and print it
inet_ntop(AF_INET, &(sa.sin_addr), str, INET_ADDRSTRLEN);
 
printf("%s\n", str);     // prints "192.168.0.100"
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *inet_ntop (int32_t af, const void *src, char *dst, int32_t size)
\details
The function \b inet_ntop converts an address from network format in network byte order to presentation format.

The argument \a af specifies the address family. Currently, only \ref AF_INET and \ref AF_INET6 are supported.

The argument \a src is a pointer to the network address. The format of the address is interpreted according to argument \a af.

The argument \a dst is a pointer to the buffer where the converted address is to be stored.

The argument \a size specifies the size of the buffer pointed to by \a dst. The size must be at least \ref INET_ADDRSTRLEN
bytes for an IPv4 address and \ref INET6_ADDRSTRLEN bytes for an IPv6 address.

The function returns a pointer to \a dst if the address is successfully converted, or \token{NULL} if the conversion failed.

\b Code \b Example (see \ref inet_pton)
*/

/**
@}
*/


/**
\addtogroup udp_user_api
@{
*/

//  ==== UDP Socket API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t netUDP_GetSocket (netUDP_cb_t cb_func)
\details
The function \b netUDP_GetSocket allocates a free UDP socket. It initializes all state variables of the UDP socket to the
default state. By default, a checksum will be calculated for every UDP packet. To turn this off, use the
\ref netUDP_SetOption function.

The argument \a cb_func is the event callback function of the UDP socket. Users must provide this function. Refer to
\ref netUDP_cb_t.

Possible \ref netStatus return values:
- \em netInvalidParameter: Callback function not valid.
- \em netError: No free sockets available.

\note
- You must call the \b netUDP_GetSocket function before any other function calls to the UDP socket.
- You must define the listener function to use with the UDP socket.
- UDP socket is IP version agnostic (supports both IPv4 and IPv6).

\b Code \b Example
\code
int32_t udp_sock;
 
uint32_t udp_cb_func (int32_t socket, const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
   ..
  return (0);
}
 
// Initialize UDP socket and open port 2000
udp_sock = netUDP_GetSocket (udp_cb_func);
if (udp_sock >= 0) {
  netUDP_Open (udp_sock, 2000);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUDP_ReleaseSocket (int32_t socket)
\details
The function \b netUDP_ReleaseSocket releases the \a socket and de-allocates its memory.

Possible \ref netStatus return values:
- \em netOK: Socket released successfully.
- \em netInvalidParameter: Invalid socket requested.
- \em netWrongState: Socket not closed.

\note
- Once the socket is released, the Network Core can allocate the socket to another process.
- You must call the \b netUDP_ReleaseSocket function when you do not need the UDP socket any longer.

\b Code \b Example
\code
// This UDP connection is no longer needed 
netUDP_Close (udp_sock);
netUDP_ReleaseSocket (udp_sock);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUDP_Open (int32_t socket, uint16_t port)
\details
The \b netUDP_Open function opens the UDP socket identified by the argument \a socket for communication.

The argument \a port specifies the local port for sending and receiving data packets. If \a port is set to \token{0},
then the Network Core allocates the first free UDP port automatically. If you need the port number later, use
\ref netUDP_GetLocalPort to retrieve this information.

Possible \ref netStatus return values:
- \em netOK: Socket opened successfully.
- \em netInvalidParameter: Invalid socket requested or port not available.
- \em netWrongState: Socket already opened.

\b Code \b Example (see \ref netUDP_GetSocket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUDP_Close (int32_t socket)
\details
The \b netUDP_Close function closes the UDP \a socket identified in the function argument. After calling the \b netUDP_Close
function, the UDP socket cannot send or receive any data packet. After closing the UDP socket, you can reopen it using the
\ref netUDP_Open function.

The UDP socket still reserves memory after calling the \b netUDP_Close function. Hence, if you do not need the socket,
you must release the memory using the \ref netUDP_ReleaseSocket function after calling \b netUDP_Close.

Possible \ref netStatus return values:
- \em netOK: Socket closed successfully.
- \em netInvalidParameter: Invalid socket requested.

\b Code \b Example (see \ref netUDP_ReleaseSocket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t *netUDP_GetBuffer (uint32_t size)
\details
The function \b netUDP_GetBuffer allocates memory for the UDP send buffer into which your application can write the 
outgoing data packet.

The argument \a size specifies the number of data bytes that the application wants to send. When the UDP frame has been sent,
the Network Core automatically de-allocates the memory used by the send buffer.

\note
- Your application must call the \b netUDP_GetBuffer function each time it wants to send a UDP data packet.
- The total size of the allocated memory must not exceed the UDP Maximum Packet Size (1452 bytes).
- Writing more data than the allocated size of the data buffer overwrites the Memory Manager Block links and causes
  the Network Core to crash.

\b Code \b Example (see \ref netUDP_Send)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUDP_Send (int32_t socket, const NET_ADDR *addr, uint8_t *buf, uint32_t len)
\details
The function \b netUDP_Send sends the data packet to a remote machine.

The argument \a socket specifies the socket handle to use for communication on the local machine.

The argument \a addr points to a buffer containing the IP address and port of the remote machine.

The argument \a buf points to the constructed UDP data packet.

The argument \a len specifies the number of bytes in the data packet. The maximum size of a transmitted data is:

|IP Version   |Maximum data size  |Fragmentation supported |
|-------------|-------------------|------------------------|
|\token{IPv4} |2000 bytes         |Yes                     |
|\token{IPv6} |2000 bytes         |Yes                     |

Over-sized transmit packets are truncated to the maximum size before being sent. Therefore, it is not possible to send
mega UDP frames up to 64K.

Possible \ref netStatus return values:
- \em netOK: Send data successful.
- \em netInvalidParameter: Invalid or not supported parameter provided.
- \em netWrongState: Socket not open.
- \em netError: Send data failed.

\note
- You must allocate the memory using \ref netUDP_GetBuffer before calling \b netUDP_Send.
- The buffer will be released, no matter if \b netUDP_Send is successful or not.
- \b netUDP_Send does not send 0-length packets. It is possible to release a buffer that has been allocated, by simply calling
  \b netUDP_Send with parameter len = 0.
- The socket must already be open for communication before you can send data.
- The same UDP socket, using the same local port, can communicate with several remote machines using UDP ports. The
  user application must handle proper multiplexing of outgoing packets and demultiplexing of received packets.

\b Code \b Example \b IPv4
\code
// IPv4 address: 192.168.0.1
NET_ADDR4 addr = { NET_ADDR_IP4, 2000, 192, 168, 0, 1 };
uint8_t *sendbuf;
 
sendbuf = netUDP_GetBuffer (2);
sendbuf[0] = 0x01;
sendbuf[1] = 0xAA;
 
netUDP_Send (udp_sock, (NET_ADDR *)&addr, sendbuf, 2);
\endcode

\b Code \b Example \b IPv6
\code
// IPv6 address: [fe80::1c30:6cff:fea2:455e]
NET_ADDR addr = { NET_ADDR_IP6, 2000,
                  0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
uint8_t *sendbuf;
 
sendbuf = netUDP_GetBuffer (2);
sendbuf[0] = 0x01;
sendbuf[1] = 0xAA;
 
netUDP_Send (udp_sock, &addr, sendbuf, 2);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netUDP_SetOption (int32_t socket, netUDP_Option option, uint32_t val)
\details
The function \b netUDP_SetOption sets different options for an UDP socket identified by the argument \a socket.

The argument \a option specifies the UDP option that is to be set (see below).

The argument \a val carries the value of the UDP option that is to be set.

|Option                             | Description                  | Value  |
|-----------------------------------|------------------------------|--------|
| \token{netUDP_OptionTOS}          | IPv4 Type of Service         | val=TOS |
| \token{netUDP_OptionTTL}          | IPv4 Multi-cast Time to Live | val=TTL |
| \token{netUDP_OptionTrafficClass} | IPv6 Traffic Class           | val=TrafficClass |
| \token{netUDP_OptionHopLimit}     | IPv6 Multi-cast Hop Limit    | val=HopLimit |
| \token{netUDP_OptionInterface}    | Network interface to bind    | val=if_id (class and number) |
| \token{netUDP_OptionChecksum}     | UDP Checksum Options         | val=Options  |

The option \token{netUDP_OptionInterface} specifies the network interface to be used for sending the broadcast message in the
local network. By default the broadcast message is routed to the first LAN interface from the list where IPv4 is enabled.
You can use this option to change the default interface for sending broadcast messages. Only used in IPv4.

For the option \token{netUDP_OptionChecksum} the argument \a val is a combination of:
- \ref NET_UDP_CHECKSUM_SEND - calculate the checksum for transmit packets,
- \ref NET_UDP_CHECKSUM_VERIFY - calculate the checksum for received packets.

Possible \ref netStatus return values:
- \em netOK: Option successfully set.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Requested socket not allocated.

\b Code \b Example
\code
int32_t udp_sock;
 
udp_sock = netUDP_GetSocket (udp_cb_func);
if (udp_sock >= 0) {
  // Open UDP port 1000 for communication.
  netUDP_Open (udp_sock, 1000);
 
  // Let UDP Multicast datagrams cross a router. 
  netUDP_SetOption (udp_sock, netUDP_OptionTTL, 2);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netUDP_GetLocalPort (int32_t socket)
\details
The function \b netUDP_GetLocalPort returns the port number for the specified \a socket. This is useful if you have not
specified a port in the \ref netUDP_Open function as the system sets the port automatically then.

\b Code \b Example
\code
int32_t udp_sock;
 
udp_sock = netUDP_GetSocket (udp_cb_func);
if (udp_sock >= 0) {
  netUDP_Open (udp_sock, 0);
  printf ("Local port is %d\n", netUDP_GetLocalPort (udp_sock));
}
\endcode
*/

/**
@}
*/

/**
\ingroup tcp_user_api
@{
*/

//  ==== TCP Socket API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t netTCP_GetSocket (netTCP_cb_t cb_func)
\details
The function \b netTCP_GetSocket allocates a free TCP socket. The function initializes all the state variables of the
TCP socket to the default state.

The argument \a cb_func is the event callback function of the TCP socket. The Network Core calls this function whenever a TCP
event occurs. Refer to \ref netTCP_cb_t.

Possible \ref netStatus return values:
- \em netInvalidParameter: Callback function not valid.
- \em netError: No free sockets available.

\note
- You must call the \b netTCP_GetSocket function before any other function calls to the TCP socket.
- You must define the listener function to use with the TCP socket.

\b Code \b Example
\code
int32_t tcp_sock;
 
uint32_t tcp_cb_func (int32_t socket, netTCP_Event event,
                      const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
   .. 
  return (0);
}
 
// Allocate a free TCP socket
tcp_sock = netTCP_GetSocket (tcp_cb_func);
if (tcp_sock < 0) {
  printf ("Get socket failed.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_ReleaseSocket (int32_t socket)
\details
The function \b netTCP_ReleaseSocket de-allocates the memory used by the TCP socket.

The argument \a socket specifies the handle of the socket to be released.

Possible \ref netStatus return values:
- \em netOK: Socket released successfully.
- \em netInvalidParameter: Invalid socket requested.
- \em netWrongState: Socket not closed.

\note
- You must call the \b netTCP_ReleaseSocket function when you do not need the TCP socket any longer.
- After calling \b netTCP_ReleaseSocket the socket is free to be used by another process.

\b Code \b Example
\code
// This TCP connection needs to close immediately
netTCP_Abort (tcp_sock);
// Socket will not be needed any more
netTCP_ReleaseSocket (tcp_sock);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_Listen (int32_t socket, uint16_t port)
\details
The function \b netTCP_Listen opens a socket for incoming connections by causing the socket to listen at a local TCP port.

The argument \a socket specifies the socket handle to listen on the local machine.

The argument \a port specifies the TCP port number to listen at. If the argument \a port is \token{0}, the function returns
error, because this port is reserved. If you need the port number later, use \ref netTCP_GetLocalPort to retrieve
this information.

Possible \ref netStatus return values:
- \em netOK: Socket opened successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Socket not closed.

\note
Server applications (such as Telnet and HTTP server) must open a TCP socket for listening.

\b Code \b Example
\code
int32_t tcp_sock;
 
// Initialize TCP Socket and start listening on port 2000
tcp_sock = netTCP_GetSocket (tcp_cb_func);
if (tcp_sock >= 0) {
  netTCP_Listen (tcp_sock, 2000);
}
 ..
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_Connect (int32_t socket, const NET_ADDR *addr, uint16_t local_port)
\details
The function \b netTCP_Connect initiates a connection to a remote server.

The argument \a socket is a socket handle on the local machine for communicating.

The argument \a addr points to the buffer containing the IP address and port of the remote socket server.

The argument \a local_port specifies the port on the local machine. If \a local_port is set to \token{0}, then the Network
Core allocates the first free TCP port automatically. If you need the port number later, use \ref netTCP_GetLocalPort to
retrieve this information.

Possible \ref netStatus return values:
- \em netOK: Connection initiated successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Socket not closed.

\b Code \b Example \b IPv4
\code
// IPv4 address: 192.168.0.1
NET_ADDR4 addr = { NET_ADDR_IP4, 2000, 192, 168, 0, 1 };
 
netTCP_Connect (tcp_sock, (NET_ADDR *)&addr, 0);
 
// Wait for the socket to connect 
for (;;) {
  switch (netTCP_GetState (tcp_sock)) {
    case netTCP_StateUNUSED:
    case netTCP_StateCLOSED:
      // Failed to connect to TCP socket server
      return;
 
    case netTCP_StateESTABLISHED:
      // Connected, socket is ready to send data
      break;
  }
  // Pass control to other threads
  osDelay (10);
}
\endcode

\b Code \b Example \b IPv6
\code
// IPv6 address: [fe80::1c30:6cff:fea2:455e]
NET_ADDR addr = { NET_ADDR_IP6, 2000,
                  0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                  0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
 
netTCP_Connect (tcp_sock, &addr, 0);
 
// Wait for the socket to connect 
for (;;) {
  switch (netTCP_GetState (tcp_sock)) {
    case netTCP_StateUNUSED:
    case netTCP_StateCLOSED:
      // Failed to connect to TCP socket server
      return;
 
    case netTCP_StateESTABLISHED:
      // Connected, socket is ready to send data
      break;
  }
  // Pass control to other threads
  osDelay (10);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_Close (int32_t socket)
\details
The function \b netTCP_Close initiates the procedure to close the TCP connection. It might take some time to close the
connection.

The argument \a socket specifies the socket handle.

The Network Core calls the listener callback function only when a remote peer has closed the connection. If the socket is
closed locally by calling \b netTCP_Close, then the callback function is not called.

When a socket is used in the \ref netTCP_Listen functions, the socket does not close by calling \b netTCP_Close. Only the
active connection is closed, and the socket will be available for new incoming connection. To close such a socket, the
function \b netTCP_Close needs to be called twice.

Possible \ref netStatus return values:
- \em netOK: Socket closing successfully started.
- \em netInvalidParameter: Invalid socket requested.
- \em netWrongState: Socket in invalid state.

\note
After calling \b netTCP_Close the socket still remains allocated until you release it.

\b Code \b Example
\code
netTCP_State state;
 
// This TCP connection is no longer needed
netTCP_Close (tcp_sock);
 
// Wait for the socket to close
for (;;) {
  state = netTCP_GetState (tcp_sock);
  if (state < netTCP_StateLISTEN) {
    break;
  }
  if (state == netTCP_StateLISTEN) [
    // Socket is in server mode, needs additional close request
    netTCP_Close (tcp_sock);
  }
  // Pass control to other threads
  osDelay (10);
}
 
// A socket is in netTCP_StateCLOSED state now
netTCP_ReleaseSocket (tcp_sock);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_Abort (int32_t socket)
\details
The function \b netTCP_Abort closes the TCP connection immediately by sending a TCP frame with the RESET flag set to the
remote machine.

The argument \a socket specifies the handle of the socket.

The Network Core calls the listener callback function only when a remote peer has aborted the connection. If the aborted
socket is initiated locally by calling \b netTCP_Abort, then the callback function is not called.

Possible \ref netStatus return values:
- \em netOK: Socket aborted successfully.
- \em netInvalidParameter: Invalid socket requested.
- \em netWrongState: Socket in invalid state.

\note After calling \b netTCP_Abort you cannot use the socket to send or receive any data. The socket remains allocated until
      you release it.

\b Code \b Example (see \ref netTCP_ReleaseSocket)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTCP_GetMaxSegmentSize (int32_t socket)
\details
The function \b netTCP_GetMaxSegmentSize determines the maximum number of bytes that can be sent in the TCP packet
(Maximum Segment Size).

The argument \a socket specifies the handle of the TCP socket.

A default Maximum Segment Size (MSS) of 1440 bytes is defined at start-up. However, when establishing a connection with a
remote machine, the Network Core might negotiate a different (smaller) value for MSS.

\note
This function can only be called after establishing a connection using the functions \ref netTCP_Listen or
\ref netTCP_Connect.

\b Code \b Example (see \ref netTCP_Send)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t *netTCP_GetBuffer (uint32_t size)
\details
The function \b netTCP_GetBuffer allocates memory for the TCP send buffer into which your application can write the
outgoing data packet.

The argument \a size specifies the number of data bytes that the application wants to send.

After the TCP frame has been sent and an acknowledgment has been received from the remote host, the Network Core
automatically de-allocates the memory used by the send buffer in the \ref netTCP_Send function.

A default Maximum Segment Size (MSS) of 1440 bytes is defined at start-up. However, when establishing a connection with a
remote machine, the Network Core might negotiate a different (smaller) value for MSS. Use \ref netTCP_GetMaxSegmentSize to
check the available MSS for the current connection.

\note
- Your application must call the \b netTCP_GetBuffer function each time it wants to send a TCP data packet.
- The size of the allocated memory must not exceed the TCP Maximum Segment Size (1440 bytes).
- Writing more data than the allocated \a size of the data buffer overwrites the Memory Manager Block links
  and causes the Network Core to crash.

\b Code \b Example (see \ref netTCP_Send)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTCP_SendReady (int32_t socket)
\details
The function \b netTCP_SendReady determines whether the TCP socket can send data. It does this by checking whether the TCP
connection has been established and whether the socket has received an acknowledgment from the remote machine for data
sent previously.

The argument \a socket specifies the socket handle.

\b Code \b Example (see \ref netTCP_Send)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_Send (int32_t socket, uint8_t *buf, uint32_t len)
\details
The function \b netTCP_Send sends the data packet to a remote machine.

The argument \a socket specifies the socket handle to use for communication on the local machine.

The argument \a buf points to the constructed TCP data packet.

The argument \a len specifies the number of bytes in the data packet.

If the \b netTCP_Send fails to send the data, it releases the memory buffer specified with the argument \a buf and returns
with an error status. The function cannot send data if:
- the TCP connection is not established
- previously sent data is not acknowledged from the remote machine.

Possible \ref netStatus return values:
- \em netOK: Send data successful.
- \em netInvalidParameter: Invalid or not supported parameter provided.
- \em netWrongState: Socket not connected or closing.
- \em netBusy: Previously sent data not acknowledged.
- \em netError: Send data failed.

\note
- You must allocate the memory using \ref netTCP_GetBuffer before calling \b netTCP_Send.
- The buffer will be released, no matter if netTCP_Send is successful or not.
- netTCP_Send does not send 0-length packets. It is possible to release a buffer that has been allocated, by simply calling
  netTCP_Send with parameter len = 0.
- The socket must already be opened and connected for communication.
- It is not allowed to call \b netTCP_Send from the callback function of the socket.

\b Code \b Example
\code
uint8_t *sendbuf;
uint32_t maxlen;
 
if (netTCP_SendReady (tcp_sock)) {
  // The socket is ready to send the data
  maxlen  = netTCP_GetMaxSegmentSize (tcp_sock);
  sendbuf = netTCP_GetBuffer (maxlen);
  memcpy (sendbuf, my_data_buf, maxlen);
  netTCP_Send (tcp_sock, sendbuf, maxlen);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netTCP_State netTCP_GetState (int32_t socket)
\details
The function \b netTCP_GetState determines the current state of the TCP socket. The application can monitor the progress when
establishing or closing a connection with this function. The most useful state values are \token{netTCP_StateCLOSED},
\token{netTCP_StateLISTEN}, and \token{netTCP_StateESTABLISHED}.

The argument \a socket specifies the socket handle.

The \b netTCP_GetState function returns the current state of the TCP socket:
|State                |Description|
|---------------------|-----------|
|\token{netTCP_StateINVALID}      |Socket is not available (not in the range of sockets specified in the \b NET_Config_TCP.h file). |
|\token{netTCP_StateUNUSED}       |Socket is free and not allocated yet. The function cannot return this value.|
|\token{netTCP_StateCLOSED}       |Socket is allocated to an application but the connection is closed.|
|\token{netTCP_StateLISTEN}       |Socket is listening for incoming connections.|
|\token{netTCP_StateSYN_RECEIVED} |Socket has received a TCP packet with the flag SYN set.|
|\token{netTCP_StateSYN_SENT}     |Socket has sent a TCP packet with the flag SYN set.|
|\token{netTCP_StateFIN_WAIT_1}   |Socket has sent a FIN packet, to start the closing of the connection.|
|\token{netTCP_StateFIN_WAIT_2}   |Socket has received acknowledgment from the remote machine for the FIN packet it sent out from the local machine. Socket is now waiting for a FIN packet from the remote machine.|
|\token{netTCP_StateCLOSING}      |Socket has received a FIN packet from the remote machine independently|
|\token{netTCP_StateLAST_ACK}     |Socket is waiting for the last ACK packet to the FIN packet it sent out.|
|\token{netTCP_StateTIME_WAIT}    |Socket is waiting on a 2 MSS timeout before closing the connection.|
|\token{netTCP_StateESTABLISHED}  |Socket has established a TCP connection. You can transfer data only in this state.|

\b Code \b Example (see \ref netTCP_Connect)
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_ResetReceiveWindow (int32_t socket)
\details
The function \b netTCP_ResetReceiveWindow resets the TCP window size to a default value defined with \c TCP_RECEIVE_WIN_SIZE
macro in the \b Net_Config_TCP.h file.

The argument \a socket specifies the handle of the socket for which to reset the window size.

This function can only be used with sockets that have a TCP flow control enabled. Enable a TCP flow control for the socket
by calling the \ref netTCP_SetOption function with the \token{netTCP_OptionFlowControl} enabled. This socket option enables using
a Sliding Window protocol in receive.

In Flow Control mode, each received data packet reduces the receiving Window Size by the number of data bytes received in the
packet. Soon the window size becomes very small or 0. The remote host stops sending data and waits for a window update. As
soon as the received data is processed, we can call a \b netTCP_ResetReceiveWindow function to reopen the receiver window for
further incoming data.

Depending on the context from where this function was called, it performs the following actions:
- resets the window size of the socket and returns if called from the callback function. The window size is actually changed
  in the acknowledge packet generated by the Network Core when the callback function returns.
- resets the window size and sends out a Window Update packet if called from the other part of the user application.
- does nothing if the socket is not in \token{netTCP_StateESTABLISHED} state and the \token{netTCP_OptionFlowControl} option
  is not set.

Possible \ref netStatus return values:
- \em netOK: Receive window reset successfully.
- \em netInvalidParameter: Invalid socket requested or flow control not enabled.
- \em netWrongState: Socket connection not established.

\b Code \b Example
\code
uint8_t uart_buf[TCP_RECEIVE_WIN_SIZE];
 
uint32_t tcp_cb_func (int32_t socket, netTCP_Event event,
                      const NET_ADDR *addr, const uint8_t *buf, uint32_t len) {
  switch (event) {
    case netTCP_EventConnect:
      // Connect request received in server mode
      return (1);
 
    case netTCP_EventData:
      // Data received
      memcpy (&uart_buf[head], buf, len);
      head += len;
      break;
  }
  return (0);
}
 
int main (void) {
  int32_t tcp_sock;
  uint32_t head, tail;
 
  // Initialize the Network Core
  netInitialize ();
  tcp_sock = netTCP_GetSocket (tcp_cb_func);
  if (tcp_sock >= 0) {
    // Start listening on TCP port 8080 
    netTCP_Listen (tcp_sock, 8080);
  }
 
  // Ethernet to UART bridge
  head = 0;
  tail = 0;
  while (1) {
    if (uart_busy () || head == tail) {
      // UART is busy or buffer is empty, do nothing
      continue;
    }
    // Send a byte to UART
    send_uart (uart_buf[tail++]);
    if (tail == head) {
      // Buffer is empty, all bytes consumed
      tail = 0;
      head = 0;
      netTCP_ResetReceiveWindow (tcp_sock);
    }
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_SetOption (int32_t socket, netTCP_Option option, uint32_t val)
\details
The function \b netTCP_SetOption sets different options for a TCP socket identified by the argument \a socket.

The argument \a option specifies the TCP option that is to be set (see below).

The argument \a val carries the value of the TCP option that is to be set.

|Option                            | Description              |Value |
|----------------------------------|--------------------------|------|
|\token{netTCP_OptionTOS}          |IPv4 Type of Service      | val=TOS |
|\token{netTCP_OptionTrafficClass} |IPv6 Traffic Class        | val=TrafficClass |
|\token{netTCP_OptionTimeout}      |TCP Idle Timeout          | val=timeout (in seconds) |
|\token{netTCP_OptionKeepAlive}    |TCP Keep Alive            | val: 0=disabled (default), 1=enabled |
|\token{netTCP_OptionFlowControl}  |TCP Flow Control          | val: 0=disabled (default), 1=enabled |
|\token{netTCP_OptionDelayedACK}   |TCP Delayed Acknowledgment| val: 0=disabled (default), 1=enabled |

Possible \ref netStatus return values:
- \em netOK: Option successfully set.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Requested socket not allocated.

\b Code \b Example
\code
int32_t tcp_sock;
 
tcp_sock = netTCP_GetSocket (tcp_cb_func);
if (tcp_sock >= 0) {
  // Set disconnect timeout to 30 seconds
  netTCP_SetOption (tcp_sock, netTCP_OptionTimeout, 30);
  // Enable Keep Alive
  netTCP_SetOption (tcp_sock, netTCP_OptionKeepAlive, 1);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netTCP_GetLocalPort (int32_t socket)
\details
The function \b netTCP_GetLocalPort returns the local TCP port that is used for a specific \a socket. This is useful if you
have not specified a port in the function \ref netTCP_Connect, as the system sets the port automatically then.

The argument \a socket specifies the local socket handle that is to be used.

\b Code \b Example
\code
int32_t tcp_sock;
 
tcp_sock = netTCP_GetSocket (tcp_cb_func);
if (tcp_sock >= 0) {
  netTCP_Connect (tcp_sock, addr, 0);
  printf ("Local port is %d\n", netTCP_GetLocalPort (tcp_sock));
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTCP_GetPeer (int32_t socket, NET_ADDR *addr, uint32_t addr_len)
\details
The function \b netTCP_GetPeer provides the IP address and port of the remote client that is connected.

The argument \a socket specifies the local socket handle that is to be used.

The argument \a addr points to the buffer where the IP address and port of the remote machine will be stored.

The argument \a addr_len specifies the length of the \a addr structure. The Network Core checks the length, if the library can
store the IP address of the remote peer into the structure. The IP address contains an IPv4 or IPv6 address.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Socket connection not established.

\b Code \b Example
\code
NET_ADDR peer;
char ip_ascii[40];
 
netTCP_GetPeer (tcp_sock, &peer, sizeof(peer));
netIP_ntoa (peer.addr_type, peer.addr, ip_ascii, sizeof (ip_ascii));
printf ("Peer address: %s\n", ip_ascii);
printf ("Peer port: %d\n", peer.port);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTCP_GetTimer (int32_t socket)
\details
The function \b netTCP_GetTimer returns the timer value of a time out or the current keep alive value. When
the time out expires, the Network Core will either close the \a socket, or send a keep-alive frame.

The argument \a socket specifies the local socket handle that is to be used.

\b Code \b Example
\code
printf ("Socket %d will close in %d seconds\n", socket, netTCP_GetTimer (socket));
\endcode
*/

/**
@}
*/

//  ==== BSD Socket API ====
//  is in common.txt as it is the same for IPv4 and IPv6

/**
\addtogroup common_user_api
@{
*/

//  ==== Interface User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netIF_GetOption (uint32_t if_id, netIF_Option option, uint8_t *buf, uint32_t buf_len)
\details
The function \b netIF_GetOption retrieves the current value of an \a option for the interface specified by \a if_id.

The argument \a if_id specifies the \ref interface_id "Interface Identification number".

The argument \a option specifies the interface option that is to be retrieved (see \ref netIF_SetOption).

The argument \a buf points to a buffer that will be used to store the value of the \a option.

The argument \a buf_len specifies the length of the buffer \a buf.

Possible \ref netStatus return values:
- \em netOK: Option retrieved successfully.
- \em netInvalidParameter: Invalid parameter or not supported option provided.

\b Code \b Example
\code
uint8_t ip4_addr[NET_ADDR_IP4_LEN];
 
netIF_GetOption (NET_IF_CLASS_ETH | 0, netIF_OptionIP4_Address, ip4_addr, sizeof (ip4_addr));
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netIF_SetOption (uint32_t if_id, netIF_Option option, const uint8_t *buf, uint32_t buf_len)
\details
The function \b netIF_SetOption sets different options for the interface identified by the argument \a if_id.

The argument \a if_id specifies the \ref interface_id "Interface Identification number".

The argument \a option specifies the interface option that is to be set (see below).

The argument \a buf points to a buffer containing the value of the option to be set.

The argument \a buf_len specifies the actual length of the buffer \a buf and must match the length of the corresponding option
as specified with argument \a option (see below).

| Option                                    | Description                    | Length         |
|-------------------------------------------|--------------------------------|----------------|
| \token{netIF_OptionMAC_Address}           | Ethernet MAC Address           |6 bytes         |
| \token{netIF_OptionVLAN_Identifier}       | Ethernet VLAN Identifier       |2 bytes         |
| \token{netIF_OptionIP4_MTU}               | IPv4 Maximum Transmission Unit |2 bytes         |
| \token{netIF_OptionIP4_Address}           | IPv4 Address                   |4 bytes         |
| \token{netIF_OptionIP4_SubnetMask}        | IPv4 Subnet mask               |4 bytes         |
| \token{netIF_OptionIP4_DefaultGateway}    | IPv4 Default Gateway           |4 bytes         |
| \token{netIF_OptionIP4_PrimaryDNS}        | IPv4 Primary DNS               |4 bytes         |
| \token{netIF_OptionIP4_SecondaryDNS}      | IPv4 Secondary DNS             |4 bytes         |
| \token{netIF_OptionIP6_MTU}               | IPv6 Maximum Transmission Unit |2 bytes         |
| \token{netIF_OptionIP6_LinkLocalAddress}  | IPv6 Link-local Address        |16 bytes        |
| \token{netIF_OptionIP6_StaticAddress}     | IPv6 Static Address            |16 bytes        |
| \token{netIF_OptionIP6_DynamicAddress}    | IPv6 Dynamic Address           |16 bytes        |
| \token{netIF_OptionIP6_SubnetPrefixLength}| IPv6 Subnet Prefix-length      |1 byte          |
| \token{netIF_OptionIP6_DefaultGateway}    | IPv6 Default Gateway           |16 bytes        |
| \token{netIF_OptionIP6_PrimaryDNS}        | IPv6 Primary DNS               |16 bytes        |
| \token{netIF_OptionIP6_SecondaryDNS}      | IPv6 Secondary DNS             |16 bytes        |
  
Possible \ref netStatus return values:
- \em netOK: Option successfully set.
- \em netInvalidParameter: Invalid parameter or not supported option provided.

The option \token{netIF_OptionIP4_MTU} sets the maximum transmission unit for the interface (MTU). The valid values 
for the MTU option depend on the network inteface and are as follows:
- \token{576 - 1500} for Ethernet interface,
- \token{576 - 1500} for PPP interface,
- \token{296 - 1500} for SLIP interface.  

IPv4 fragmentation is enabled if the option value is nonzero. Option value \token{0} disables IPv4 fragmentation.

The option \token{netIF_OptionVLAN_Identifier} sets the Virtual LAN for the Ethernet interface (VLAN). Valid VLAN ID is 
from \token{1} to \token{4093}. Option value \token{0} disables VLAN.

\note
- Ethernet MAC address setting fails if the multicast bit is set. Multicast bit is bit-0 of the first MAC address byte.
- Link Local address setting is not possible, because the link local address is managed within the network library.

\b Code \b Example
\code
uint8_t mac_addr[NET_ADDR_ETH_LEN] = { 0x1e, 0x30, 0x6c, 0xa2, 0x45, 0x5e };
uint16_t eth_mtu = 1480;
 
netIF_SetOption (NET_IF_CLASS_ETH | 0, netIF_OptionMAC_Address, mac_addr, sizeof (mac_addr));
netIF_SetOption (NET_IF_CLASS_ETH | 0, netIF_OptionIP4_MTU, (uint8_t *)&eth_mtu, sizeof (eth_mtu)); 
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netIF_SetDefault (uint32_t if_id, netIF_Version ip_version)
\details
The function \b netIF_SetDefault sets the default interface to the interface specified by \a if_id. The default interface is
used for Internet access.

The argument \a if_id specifies th \ref interface_id "Interface Identification number".

The argument \a ip_version specifies the Internet Protocol version IPv4 or IPv6, for which the default interface is to be set.

Possible \ref netStatus return values:
- \em netOK: Default interface successfully set.
- \em netInvalidParameter: Invalid parameter provided.

\b Code \b Example
\code
// Use PPP interface for Internet access 
netIF_SetDefault (NET_IF_CLASS_PPP | 0, netIF_VersionIP4);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_CacheIP (uint32_t if_id, const uint8_t *ip4_addr, netARP_CacheType type)
\details
The function \b netARP_CacheIP determines whether the ARP table has a MAC (Ethernet) address entry for the requested IP
address. If an entry does not exist, the function forces the Network Core to resolve and cache the MAC address into the
internal ARP table buffer. To resolve the MAC address, the Network Core sends an ARP request to the network.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the ARP table.

The argument \a ip4_addr points to a buffer containing the four octets of the dotted decimal IPv4 address to be resolved.

The argument \a type specifies whether the IP address is fixed or temporary. This consequently determines whether or not the
Network Core automatically refreshes the IP address entry in the ARP cache.
|Type                            |Description|
|--------------------------------|-----------|
|\token{netARP_CacheTemporaryIP} |The IP address is temporary, and thus Network removes the IP address entry from the ARP cache after a timeout.|
|\token{netARP_CacheFixedIP}     |The IP address is fixed, and thus Network's ARP module automatically refreshes the IP address entry after the timeout.|

Possible \ref netStatus return values:
- \em netOK: MAC address resolved successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: MAC address resolving in progress.
- \em netError: Gateway IP address is undefined.

\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_CacheIP.
- Only the Ethernet and WiFi interfaces use the \b netARP_CacheIP function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t mac_addr [NET_ADDR_ETH_LEN];
uint8_t ip4_addr [NET_ADDR_IP4_LEN];
 ..
netIP_aton ("192.168.0.100", NET_ADDR_IP4, ip4_addr);
while (netARP_GetMAC (NET_IF_CLASS_ETH | 0, ip4_addr, mac_addr) != netOK) {
  // Requested IP address not yet cached
  netARP_CacheIP (NET_IF_CLASS_ETH | 0, ip4_addr, netARP_CacheTemporaryIP);
  osDelay (1000);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_CacheMAC (uint32_t if_id, const uint8_t *mac_addr)
\details
The function \b netARP_CacheMAC determines whether the ARP table has an IP address entry for the requested MAC (Ethernet)
address \b mac_addr. If an entry does not exist, the function forces the Network Core to resolve and cache the IP address
into the internal ARP table buffer. To resolve the IP address, the Network Core sends an inverse ARP request to the network.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the ARP table.

The argument \a mac_addr points to a buffer containing the six octets of the MAC address to be resolved.

Possible \ref netStatus return values:
- \em netOK: IP address resolved successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: IP address resolving in progress.
- \em netError: Local IP address is undefined.

\note
- This function can only be used with IPv4. There is no similar functionality for IPv6.
- Only the Ethernet and WiFi interfaces use the \b netARP_CacheMAC function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t mac_addr [NET_ADDR_ETH_LEN];
uint8_t ip4_addr [NET_ADDR_IP4_LEN];
 ..
netMAC_aton ("1E-30-6C-A2-45-5E", mac_addr);
if (netARP_GetIP (NET_IF_CLASS_ETH | 0, mac_addr, ip4_addr) != netOK) {
  // Requested MAC address not yet cached
  netARP_CacheMAC (NET_IF_CLASS_ETH | 0, mac_addr);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip4_addr)
\details
The function \b netARP_GetIP determines the resolved IP address for a specific MAC address.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the ARP table.

The argument \a mac_addr points to a buffer containing the six octets of the MAC address to be resolved.

The argument \a ip4_addr points to a buffer that stores the resolved IPv4 address.

Possible \ref netStatus return values:
- \em netOK: IP address copied to a buffer.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Requested MAC address not found in ARP table.

Refer to 
- \ref netARP_CacheMAC to enforce the Network Core to resolve the MAC address.
- \ref netARP_GetMAC to get the resolved MAC address.

\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_GetIP.
- Only the Ethernet and WiFi interfaces use the \b netARP_GetIP function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example (see \ref netARP_CacheMAC)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_GetMAC (uint32_t if_id, const uint8_t *ip4_addr, uint8_t *mac_addr)
\details
The function \b netARP_GetMAC determines the resolved MAC address for a specific IP address.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the ARP table.

The argument \a ip4_addr points to a buffer containing four octets of the dotted decimal IPv4 address to be resolved.

The argument \a mac_addr points to a buffer that stores the resolved six octets of the MAC address.

Possible \ref netStatus return values:
- \em netOK: MAC address copied to a buffer.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Requested IP address not found in ARP table.

Refer to 
 - \ref netARP_CacheIP to enforce the Network Core to resolve the IP address.
 - \ref netARP_GetIP to retrieve the resolved IP address.

\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_GetMAC.
- Only the Ethernet and WiFi interfaces use the \b netARP_GetMAC function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip4_addr [NET_ADDR_IP4_LEN] = { 192, 168, 0, 100 };
uint8_t mac_addr [NET_ADDR_ETH_LEN];
char addr_ascii[18];
 ..
if (netARP_GetMAC (NET_IF_CLASS_ETH | 0, ip4_addr, mac_addr) == netOK) {
  netIP_ntoa (NET_ADDR_IP4, ip4_addr, addr_ascii, sizeof (addr_ascii));
  printf ("Requested IP address: %s\n", addr_ascii);
  netMAC_ntoa (mac_addr, addr_ascii, sizeof (addr_ascii));
  printf ("Cached MAC address: %s\n", addr_ascii);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_Probe (uint32_t if_id, const uint8_t *ip4_addr, netARP_cb_t cb_func)
\details
The function \b netARP_Probe determines whether the requested IPv4 address is already used in local area network. You can use
this function to check for IPv4 address collisions.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the IPv4 address.

The argument \a ip4_addr points to a buffer containing four octets of the dotted decimal IPv4 address to be checked.

The argument \a cb_func points to an event callback function called by the Network Core when the probe session ends.
Refer to \ref netARP_cb_t.

Possible \ref netStatus return values:
- \em netOK: Probe process started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: Probe process is busy.

Refer to 
 - \ref netIF_GetOption to retrieve the IPv4 address assigned to Ethernet or WiFi interface.
 - \ref netIF_SetOption to manually change assigned IPv4 address.
 
\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_Probe.
- Only the Ethernet and WiFi interfaces use the \b netARP_Probe function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip4_addr[NET_ADDR_IP4_LEN] = { 192, 168, 0, 100 };
 
static void probe_callback (netARP_Event event) {
  switch (event) {
    case netARP_EventSuccess:
      printf ("Response received, IP address is in use.\n");
      break;
    case netARP_EventTimeout:
      printf ("Probe timeout, no response.\n");
      break;
  }
}
 
 ..
if (netARP_Probe (NET_IF_CLASS_ETH | 0, ip4_addr, probe_callback) == netOK) {
  printf("Probe started.\n");
}
else {
  printf("Probe not ready or bad parameters.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_ProbeX (uint32_t if_id, const uint8_t *ip4_addr)
\details
The blocking function \b netARP_ProbeX determines whether the requested IPv4 address is already used in local area network. You can
use this function to check for IPv4 address collisions.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the IPv4 address.

The argument \a ip4_addr points to a buffer containing four octets of the dotted decimal IPv4 address to be checked.

Possible \ref netStatus return values:
- \em netOK: Response received, IP address is in use.
- \em netTimeout: Probe timeout, no reponse received.

Refer to 
 - \ref netIF_GetOption to retrieve the IPv4 address assigned to Ethernet or WiFi interface.
 - \ref netIF_SetOption to manually change assigned IPv4 address.
 
\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_ProbeX.
- Only the Ethernet and WiFi interfaces use the \b netARP_ProbeX function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip4_addr[NET_ADDR_IP4_LEN] = { 192, 168, 0, 100 };
 
if (netARP_ProbeX (NET_IF_CLASS_ETH | 0, ip4_addr) == netOK) {
  printf ("Response received, IP address is in use.\n");
}
else {
  printf ("Probe timeout, no response received.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netARP_AddCache (uint32_t if_id, const uint8_t *ip4_addr, const uint8_t *mac_addr)
\details
The function \b netARP_AddCache adds the IP and MAC address of the host as a static entry to the ARP cache. This is useful
if the host does not respond to ARP requests, but the IP and MAC address of this host are known. You can use this function
to manually add this host to the ARP cache.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which a host is to be included in
the ARP cache table.

The argument \a ip4_addr points to a buffer containing four octets of the dotted decimal IPv4 address of the host to be added.

The argument \a mac_addr points to a buffer containing the six octets of the MAC address of the host to be added.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: No entries can be assigned in the ARP cache table.

\note
- This function can only be used with IPv4. For IPv6 similar functionality is not provided.
- Only the Ethernet and WiFi interfaces use the \b netARP_AddCache function. There is no ARP protocol for the PPP or SLIP interface.
- If necessary, use \ref netARP_ClearCache to clear the ARP cache and the static cache entries.

\b Code \b Example
\code
const uint8_t ip4_addr[NET_ADDR_IP4_LEN] = { 192, 168, 0, 100 };
const uint8_t mac_addr[NET_ADDR_ETH_LEN] = { 0x1e, 0x30, 0x6c, 0xa2, 0x45, 0x5e };

if (netARP_AddCache (NET_IF_CLASS_ETH | 0, ip4_addr, mac_addr) == netOK) {
  // Static entry successfully added to the ARP cache for the ETH0 interface 
}
\endcode
*/

/**
\fn netStatus netARP_ClearCache (uint32_t if_id)
\details
The function \b netARP_ClearCache flushes all resolved MAC addresses from the local ARP cache. You can use this function
when the cache holds outdated values that are no longer valid.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to clear the ARP cache table.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: ARP internal process is in progress.

\note
- This function can only be used with IPv4. For IPv6 similar functionality is provided by \ref netNDP_ClearCache.
- Only the Ethernet and WiFi interfaces use the \b netARP_ClearCache function. There is no ARP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
if (netARP_ClearCache (NET_IF_CLASS_ETH | 0) == netOK) {
  // All entries flushed from ARP cache for ETH0 interface 
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netIGMP_Join (uint32_t if_id, const uint8_t *ip4_addr)
\details
The function \b netIGMP_Join requests that a host should become a member of the host group identified by \a ip4_addr.

The argument \a if_id is the \ref interface_id "Interface Identification number" of the host.

The argument \a ip4_addr points to the address of the group. Before any datagrams destined to a particular group can be
received, an upper-layer protocol must ask the IP module to join that group.

Possible \ref netStatus return values:
- \em netOK: Joining the group successful.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: No free entries in IGMP table.

\note
- This function can only be used with IPv4. For IPv6, the function \ref netMLD_Join must be used.
- Only the Ethernet and WiFi interfaces use the \b netIGMP_Join function. There is no IGMP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
void Multicast_receive (void) {
  SOCKADDR_IN addr;
  int32_t sock, res;
  uint8_t ip4_addr[NET_ADDR_IP4_LEN];
  char dbuf[100];
 
  // Join to the multicast group 225.1.2.3
  inet_pton (AF_INET, "225.1.2.3", ip4_addr);
  netIGMP_Join (NET_IF_CLASS_ETH | 0, ip4_addr);

  // Create socket 
  sock = socket (AF_INET, SOCK_DGRAM, 0);

  // Bind socket
  addr.sin_family      = AF_INET;
  addr.sin_addr.s_addr = INADDR_ANY;
  addr.sin_port        = htons (5555);
  bind (sock, (SOCKADDR *)&addr, sizeof(addr));

  while (1) {
    res = recv (sock, dbuf, sizeof (dbuf), 0);
    if (res <= 0) {
      break;
    }
    // Process data in dbuf
  }

  closesocket (sock);

  // Leave the multicast group
  netIGMP_Leave (NET_IF_CLASS_ETH | 0, ip4_addr);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netIGMP_Leave (uint32_t if_id, const uint8_t *ip4_addr)
\details
The function \b netIGMP_Leave requests a host to give up its membership in a host group.

The argument \a if_id is the host \ref interface_id "Interface Identification number".

The argument \a ip4_addr points to the host group. After the upper-layer has requested to leave the host group, datagrams
destined to a particular group can not be received, but are silently discarded by the IP-layer.

Possible \ref netStatus return values:
- \em netOK: Leaving the group successful.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Not member of requested host group.

\note
- This function can only be used with IPv4. For IPv6, the function \ref netMLD_Leave must be used.
- Only the Ethernet and WiFi interfaces use the \b netIGMP_Leave function. There is no IGMP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
const uint8_t ip4_addr[NET_ADDR_IP4_LEN] = { 238, 0, 100, 1 };
char ip_ascii[16];
 ..
if (netIGMP_Leave (NET_IF_CLASS_ETH | 0, ip4_addr) == netOK) {
  netIP_ntoa (NET_ADDR_IP4, ip4_addr, ip_ascii, sizeof(ip_ascii));
  printf ("This Host has left the group: %s\n", ip_ascii);
}
else {
  printf ("Failed to leave a group, this host is not a member.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDHCP_Enable (uint32_t if_id)
\details
The function \b netDHCP_Enable enables the DHCP service at runtime.

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which DHCP is to be enabled.

Possible \ref netStatus return values:
- \em netOK: DHCP client enabled successfully.
- \em netInvalidParameter: Invalid interface number provided.
- \em netError: DHCP client internal error.

\note
- If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the DHCP service previously using
  \ref netDHCP_Disable or have set \c NET_START_SERVICE to \token{0}.
- The DHCP service works for IPv4 only.

\b Code \b Example (see \ref netDHCP_Disable)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDHCP_Disable (uint32_t if_id)
\details
The function \b netDHCP_Disable permanently disables the DHCP service at runtime. To enable the DHCP client again, you must
call \ref netDHCP_Enable. 

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which DHCP is to be disabled.

Possible \ref netStatus return values:
- \em netOK: DHCP client disabled successfully.
- \em netInvalidParameter: Invalid interface number provided.

\note
- You can use the function only when the <b>Dynamic Host Configuration</b> for IPv4 is enabled in the \b Net_Config_ETH_n.h
  or \b Net_Config_WiFi_n.h configuration file.
- The DHCP service works for IPv4 only.

\b Code \b Example
\code
if (use_dhcp == false)
  // Use a pre-defined static IP address
  netDHCP_Disable (NET_IF_CLASS_ETH | 0);
}
else {
  // Use DHCP assigned IP address
  netDHCP_Enable (NET_IF_CLASS_ETH | 0);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDHCP_SetOption (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len)
\details
The function \b netDHCP_SetOption changes DHCP client options at runtime. To change a DHCP option, DHCP client must be disabled
with a call to \ref netDHCP_Disable, and enabled again after the call to \b netDHCP_SetOption with \ref netDHCP_Enable.

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which DHCP option is to be set.

The argument \a option specifies a DHCP option to be set. The following options are supported:

|Option                          |Description                     |Minimum length | 
|--------------------------------|--------------------------------|---------------|
| \ref NET_DHCP_OPTION_CLIENT_ID | Client-identifier option       | 2 bytes       |

The argument \a val is a pointer to user provided DHCP option value. If argument \a val is \token{NULL}, default DHCP option value
is used instead of the user provided. Default DHCP Client-identifier option is Ethernet MAC address.

The argument \a len contains the length of the option value in bytes. 

Possible \ref netStatus return values:
- \em netOK: Option successfully set.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: DHCP client is running.

\note
- You can use the function only when the <b>Dynamic Host Configuration</b> for IPv4 is enabled in the \b Net_Config_ETH_n.h
  or \b Net_Config_WiFi_n.h configuration file.
- The DHCP service works for IPv4 only.

\b Code \b Example
\code
// Type = 255, IAID = 01020304, DUID = 13169
uint8_t user_cid[] = { 0xFF, 1, 2, 3, 4, 0x33, 0x71 };
 
netDHCP_Disable (NET_IF_CLASS_ETH | 0);
netDHCP_SetOption (NET_IF_CLASS_ETH | 0, NET_DHCP_OPTION_CLIENT_ID, user_cid, 7);
netDHCP_Enable (NET_IF_CLASS_ETH | 0);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNBNS_Resolve (uint32_t if_id, const char *name, uint8_t *ip4_addr)
\details
The blocking function \b netNBNS_Resolve resolves the IP address of a host from a host name on the local network. It starts
the NBNS client, sends a broadcast request to all hosts that are on local network and returns the resolved IP address. If
the host is already resolved and cached in local NBNS cache, the function returns immediately with the IP address.

The argument \a if_id is the host \ref interface_id "Interface Identification number".

The argument \a name is a pointer to a \token{null}-terminated string that specifies the host name. The argument name can also
be "localhost" or the local system host name. In this case the NBNS client returns immediately with the loopback IP address: "127.0.0.1"

The argument \a ip4_addr specifies a user-provided address buffer that will receive the resolved IP address.

Possible \ref netStatus return values:
- \em netOK: Host name successfully resolved.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: NBNS protocol not enabled for this interface.
- \em netBusy: NBNS client is busy.
- \em netTimeout: Timed out with no response received.

\note
- This function can only be used with IPv4. Currently, no similar functionality is provided for IPv6.
- Only the Ethernet and WiFi interfaces use the \b netNBNS_Resolve function. There is no NBNS protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip4_addr[NET_ADDR_IP4_LEN];
char ip_ascii[16];
 
if (netNBNS_Resolve (NET_IF_CLASS_ETH | 0, "MCB4300", ip4_addr) == netOK) {
  // Success, 'ip4_addr' holds resolved IP address
  netIP_ntoa (NET_ADDR_IP4, ip4_addr, ip_ascii, sizeof(ip_ascii));
  printf("IP Address: %s\n", ip_ascii);
}
else {
  printf ("Error resolving host on local network.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNBNS_ClearCache (uint32_t if_id)
\details
The function \b netNBNS_ClearCache flushes all resolved IP addresses from the local NBNS cache. You can use this function
when the cache holds outdated values that are no longer valid.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to clear the NBNS cache table.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: NBNS protocol not enabled for this interface.
- \em netBusy: NBNS internal process is in progress.

\note
- This function can only be used with IPv4. Currently, no similar functionality is provided for IPv6.
- Only the Ethernet and WiFi interfaces use the \b netNBNS_ClearCache function. There is no NBNS protocol for the PPP or SLIP interface.

\b Code \b Example
\code
if (netNBNS_ClearCache (NET_IF_CLASS_ETH | 0) == netOK) {
  // All entries flushed from NBNS cache for ETH0 interface 
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_CacheIP (uint32_t if_id, const uint8_t *ip6_addr)
\details
The function \b netNDP_CacheIP determines whether the NDP table has already an entry for the requested IPv6 address \a ip6_addr.
If an entry does not exist, the function forces the Network Core to resolve and cache the IP address into the internal NDP
table buffer.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to cache the NDP table.

The argument \a ip6_addr points to a buffer containing the IPv6 address.

Possible \ref netStatus return values:
- \em netOK: MAC address resolved successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Gateway IPv6 address is undefined.

\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_CacheIP.
- Only the Ethernet and WiFi interfaces use the \b netNDP_CacheIP function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t mac_addr [NET_ADDR_ETH_LEN];
uint8_t ip6_addr [NET_ADDR_IP6_LEN];
 ..
netIP_aton ("fe80::1c30:6cff:fea2:455e", NET_ADDR_IP6, ip6_addr);
if (netNDP_GetMAC (NET_IF_CLASS_ETH | 0, ip6_addr, mac_addr) != netOK) {
  // Requested IP address not yet cached
  netNDP_CacheIP (0, ip6_addr);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_GetIP (uint32_t if_id, const uint8_t *mac_addr, uint8_t *ip6_addr)
\details
The function \b netNDP_GetIP determines the resolved IPv6 address for a specific MAC address.

The argument \a if_id is the \ref interface_id "Interface Identification number" to be used.

The argument \a mac_addr points to a buffer containing the MAC address.

The argument \a ip6_addr points to a buffer that stores the resolved IPv6 address.

Possible \ref netStatus return values:
- \em netOK: IPv6 address copied to a buffer.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Requested MAC address not found in NDP table.

\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_GetIP.
- Only the Ethernet and WiFi interfaces use the \b netNDP_GetIP function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t mac_addr [NET_ADDR_ETH_LEN];
uint8_t ip6_addr [NET_ADDR_IP6_LEN];
 ..
netMAC_aton ("1E-30-6C-A2-45-5E", mac_addr);
if (netNDP_GetIP (NET_IF_CLASS_ETH | 0, mac_addr, ip6_addr) == netOK) {
  // MAC address found in ND cache
} 
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_GetMAC (uint32_t if_id, const uint8_t *ip6_addr, uint8_t *mac_addr)
\details
The function \b netNDP_GetMAC determines the resolved MAC address for a specific IPv6 address.

The argument \a if_id is the \ref interface_id "Interface Identification number" to be used.

The argument \a ip6_addr points to a buffer containing the IPv6 address.

The argument \a mac_addr points to a buffer that stores the resolved six octets of the MAC address.

Possible \ref netStatus return values:
- \em netOK: MAC address copied to a buffer.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Requested IPv6 address not found in NDP table.

\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_GetMAC.
- Only the Ethernet and WiFi interfaces use the \b netNDP_GetMAC function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip6_addr [NET_ADDR_IP6_LEN];
uint8_t mac_addr [NET_ADDR_ETH_LEN];
char addr_ascii[40];
 ..
netIP_aton ("fe80::1c30:6cff:fea2:455e", NET_ADDR_IP6, ip6_addr);
if (netNDP_GetMAC (NET_IF_CLASS_ETH | 0, ip6_addr, mac_addr) == netOK) {
  printf ("Requested IP address: %s\n", addr_ascii);
  netMAC_ntoa (mac_addr, addr_ascii, sizeof (addr_ascii));
  printf ("Resolved MAC address: %s\n", addr_ascii);
} 
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_Probe (uint32_t if_id, const uint8_t *ip6_addr, netNDP_cb_t cb_func)
\details
The function \b netNDP_Probe determines whether the requested IPv6 address is already used in local area network. You can use
this function to check for IPv6 address collisions.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the IPv6 address.

The argument \a ip6_addr points to a buffer containing the IPv6 address to be checked.

The argument \a cb_func points to an event callback function called by the Network Core when the probe session ends.
Refer to \ref netNDP_cb_t.

Possible \ref netStatus return values:
- \em netOK: Probe process started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: Probe process is busy.

Refer to 
 - \ref netIF_GetOption to retrieve the IPv6 address assigned to Ethernet or WiFi interface.
 - \ref netIF_SetOption to manually change assigned IPv6 address.
 
\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_Probe.
- Only the Ethernet and WiFi interfaces use the \b netNDP_Probe function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip6_addr[NET_ADDR_IP6_LEN];
 
static void probe_callback (netNDP_Event event) {
  switch (event) {
    case netNDP_EventSuccess:
      printf ("Response received, IP address is in use.\n");
      break;
    case netNDP_EventTimeout:
      printf ("Probe timeout, no response.\n");
      break;
  }
}
 
 ..
netIP_aton ("fe80::1c30:6cff:fea2:455e", NET_ADDR_IP6, ip6_addr);
if (netNDP_Probe (NET_IF_CLASS_ETH | 0, ip6_addr, probe_callback) == netOK) {
  printf("Probe started.\n");
}
else {
  printf("Probe not ready or bad parameters.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_ProbeX (uint32_t if_id, const uint8_t *ip6_addr)
\details
The blocking function \b netNDP_ProbeX determines whether the requested IPv6 address is already used in local area network. You can
use this function to check for IPv6 address collisions.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to check the IPv6 address.

The argument \a ip6_addr points to a buffer containing the IPv6 address to be checked.

Possible \ref netStatus return values:
- \em netOK: Response received, IP address is in use.
- \em netTimeout: Probe timeout, no reponse received.

Refer to 
 - \ref netIF_GetOption to retrieve the IPv6 address assigned to Ethernet or WiFi interface.
 - \ref netIF_SetOption to manually change assigned IPv6 address.
 
\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_Probe.
- Only the Ethernet and WiFi interfaces use the \b netNDP_Probe function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
uint8_t ip6_addr[NET_ADDR_IP6_LEN];
 
netIP_aton ("fe80::1c30:6cff:fea2:455e", NET_ADDR_IP6, ip6_addr);
if (netNDP_ProbeX (NET_IF_CLASS_ETH | 0, ip6_addr) == netOK) {
  printf ("Response received, IP address is in use.\n");
}
else {
  printf ("Probe timeout, no response received.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netNDP_ClearCache (uint32_t if_id)
\details
The function \b netNDP_ClearCache flushes all resolved MAC addresses from the local NDP cache. You can use this function
when the cache holds outdated values that are no longer valid.

The argument \a if_id is the \ref interface_id "Interface Identification number" for which to clear the NDP cache table.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: NDP internal process is in progress.

\note
- This function can only be used with IPv6. For IPv4 similar functionality is provided by \ref netARP_ClearCache.
- Only the Ethernet and WiFi interfaces use the \b netNDP_ClearCache function. There is no NDP protocol for the PPP or SLIP interface.

\b Code \b Example
\code
if (netNDP_ClearCache (NET_IF_CLASS_ETH | 0) == netOK) {
  // All entries flushed from NDP cache for ETH0 interface 
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netMLD_Join (uint32_t if_id, const uint8_t *ip6_addr)
\details
The function \b netMLD_Join requests that a node becomes a member of the multicast group identified by \a ip6_addr.

The argument \a if_id is the \ref interface_id "Interface Identification number" of the node.

The argument \a ip6_addr refers to the address of the group. Before datagrams destined for a specific group can be
received, an upper-layer protocol must request the IPv6 module to join this group.

Possible \ref netStatus return values:
- \em netOK: Joining the group successful.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: No free entries in MLD table.

\note
- This function can only be used with IPv6. For IPv4, the function \ref netIGMP_Join must be used.
- Only the Ethernet and WiFi interfaces use the \b netMLD_Join function. There is no MLD protocol for the PPP or SLIP interface.

\b Code \b Example
\code
void Multicast_receive (void) {
  SOCKADDR_IN6 addr;
  int32_t sock, res, on;
  uint8_t ip6_addr[NET_ADDR_IP6_LEN];
  char dbuf[100];
 
  // Join to the multicast group ff02::1:2:3
  inet_pton (AF_INET6, "ff02::1:2:3", ip6_addr);
  netMLD_Join (NET_IF_CLASS_ETH | 0, ip6_addr);

  // Create socket 
  sock = socket (AF_INET6, SOCK_DGRAM, 0);

  // Bind socket
  addr.sin6_family   = AF_INET6;
  addr.sin6_port     = htons(5555);
  addr.sin6_addr     = in6addr_any;
  addr.sin6_flowinfo = 0;
  bind (sock, (SOCKADDR *)&addr, sizeof(addr));

  while (1) {
    res = recv (sock, dbuf, sizeof (dbuf), 0);
    if (res <= 0) {
      break;
    }
    // Process data in dbuf
  }

  closesocket (sock);

  // Leave the multicast group
  netMLD_Leave (NET_IF_CLASS_ETH | 0, ip6_addr);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netMLD_Leave (uint32_t if_id, const uint8_t *ip6_addr)
\details
The function \b netMLD_Leave requests a node to give up its membership in a multicast group.

The argument \a if_id is the \ref interface_id "Interface Identification number" of the node.

The argument \a ip6_addr refers to the multicast group. After the upper-layer has requested to leave the multicast group,
datagrams intended for a specific group can no longer be received, but are silently discarded by the IPv6-layer.

Possible \ref netStatus return values:
- \em netOK: Leaving the group successful.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Not member of requested host group.

\note
- This function can only be used with IPv6. For IPv4, the function \ref netIGMP_Leave must be used.
- Only the Ethernet and WiFi interfaces use the \b netMLD_Leave function. There is no MLD protocol for the PPP or SLIP interface.

\b Code \b Example
\code
const char ip6_ascii[] = "ff02::16";
uint8_t ip6_mcast[NET_ADDR_IP6_LEN];
 
netIP_aton (ip6_ascii, NET_ADDR_IP6, ip6_mcast);
if (netMLD_Leave (NET_IF_CLASS_ETH | 0, ip6_mcast) == netOK) {
  printf ("This node has left the multicast group: %s\n", ip6_ascii);
}
else {
  printf ("Failed to leave a group, this node is not a member.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDHCP6_Enable (uint32_t if_id, netDHCP6_Mode mode)
\details
The function \b netDHCP6_Enable enables the DHCPv6 service at runtime.

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which DHCPv6 is to be enabled.

The argument \a mode specifies whether DHCPv6 client runs in \b stateful mode with IPv6 address assignment, or in \b stateless
mode with no IPv6 address assignment. In stateless mode, DHCPv6 client obtains only additional information, such as DNS name 
servers.

Possible \ref netStatus return values:
- \em netOK: DHCPv6 client enabled successfully.
- \em netInvalidParameter: Invalid interface number provided.
- \em netError: DHCPv6 client internal error.

\note
- If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the DHCPv6 service previously using
  \ref netDHCP6_Disable or have set \c NET_START_SERVICE to \token{0}.
- The DHCPv6 service works for IPv6 only.

\b Code \b Example (see \ref netDHCP6_Disable)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDHCP6_Disable (uint32_t if_id)
\details
The function \b netDHCP6_Disable permanently disables the DHCPv6 service at runtime. To enable the DHCPv6 client again, you
must call \ref netDHCP6_Enable. 

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which DHCPv6 is to be disabled.

Possible \ref netStatus return values:
- \em netOK: DHCPv6 client disabled successfully.
- \em netInvalidParameter: Invalid interface number provided.

\note
- You can use the function only when the <b>Dynamic Host Configuration</b> for IPv6 is enabled in the \b Net_Config_ETH_n.h
  or \b Net_Config_WiFi_n.h configuration file.
- The DHCPv6 service works for IPv6 only.

\b Code \b Example
\code
if (use_dhcp6 == false)
  // Use a pre-defined static IP address
  netDHCP6_Disable (NET_IF_CLASS_ETH | 0);
}
else {
  // Use DHCPv6 assigned IP address, stateful mode
  netDHCP6_Enable (NET_IF_CLASS_ETH | 0, netDHCP6_ModeStateful);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netICMP_SetNoEcho (uint32_t if_id, bool no_echo)
\details
The function \b netICMP_SetNoEcho enables or disables the Echo response on the interface at runtime.

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which ICMP Echo response mode is
to be changed.

The argument \a no_echo switches the NoEcho response mode on (\token{true}) or off (\token{false}).

Possible \ref netStatus return values:
- \em netOK: Echo response mode changed successfully.
- \em netInvalidParameter: Invalid interface number provided.

\b Code \b Example
\code
// Disable IPv4 Echo response for ETH0
netICMP_SetNoEcho (NET_IF_CLASS_ETH | 0, true);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netICMP6_SetNoEcho (uint32_t if_id, bool no_echo)
\details
The function \b netICMP6_SetNoEcho enables or disables the Echo response on the interface at runtime.

The argument \a if_id specifies the \ref interface_id "Interface Identification number" for which ICMPv6 Echo response mode is
to be changed.

The argument \a no_echo switches the NoEcho response mode on (\token{true}) or off (\token{false}).

Possible \ref netStatus return values:
- \em netOK: Echo response mode changed successfully.
- \em netInvalidParameter: Invalid interface number provided.

\b Code \b Example
\code
// Disable IPv6 Echo response for ETH0
netICMP6_SetNoEcho (NET_IF_CLASS_ETH | 0, true);
\endcode
*/

/**
@}
*/

/**
\addtogroup ethernet_user_api
@{
*/

//  ==== Ethernet Interface User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netETH_SendRaw (uint32_t if_num, const uint8_t *buf, uint32_t len)
\details
The function \b netETH_SendRaw sends the raw Ethernet data to a remote machine. The data must contain Ethernet header and payload
data. This allows the users to implement additional Ethernet protocols, which are not supported by the network library. 

The argument \a if_num specifies the \ref interface_num "Ethernet Interface" which is used for sending.

The argument \a buf points to a buffer containing Ethernet raw data.

The argument \a len specifies the number of data bytes to send.

Possible \ref netStatus return values:
- \em netOK: Data sent successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Ethernet link is down.
- \em netDriverError: Ethernet driver internal error.
- \em netBusy: Ethernet transmitter is busy.

\b Code \b Example
\code
void netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len) {
  uint8_t echo_buf[60];
 
  // Echo small packets
  if (len <= 60) {
    memcpy (&echo_buf[0], &buf[6], 6);          // Destination MAC address
    memcpy (&echo_buf[6], &buf[0], 6);          // Source MAC address
    memcpy (&echo_buf[12], &buf[12], len-12);   // EtherType + data
    netETH_SendRaw (if_num, echo_buf, len);
  }
}
\endcode
*/

/**
@}
*/

/**
\addtogroup common_interface_callbacks
@{
*/

//  ==== Common Interface Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len)
\details
The user function \b netDHCP_Notify is called by the DHCP client to signal IP address changes or provide information about 
extended DHCP options. Extended DHCP options are enabled in the \ref using_ethernet_interfaces_conf files and 
that allow request information such as a boot file name or NTP Server IP addresses.

DHCP client notifications require the implementation of the function \ref netDHCP_Notify in the user code.

The parameter \a if_id indicates the \ref interface_id "Interface Identification number".

The parameter \a option specifies the extended DHCP option code.
 
The parameter \a val is a pointer to information provided by the DCHP server replies (see table below).

The parameter \a len contains the length of the option value in bytes.

The following table shows the various option codes. 

| Option Code (\em option)          | Description                     | \em val is
|:----------------------------------|:--------------------------------|-----------------------
|\ref NET_DHCP_OPTION_IP_ADDRESS    |IP address change event          | pointer to new dynamic IPv4 address (binary)         
|\ref NET_DHCP_OPTION_NTP_SERVERS   |IP addresses of NTP Server       | pointer to list of NTP Server IPv4 addresses (binary)
|\ref NET_DHCP_OPTION_BOOTFILE_NAME |Boot file name from DHCP server  | pointer to boot file name (ASCII string)

\note
- This function is optional. It is not required for a default DHCP client configuration.
- The DHCP service is supported only for IPv4 networks.

\b Code \b Example
\code
// Process DCHP server information
void netDHCP_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len) {
  char ip_ascii[16];
  uint32_t idx;
  
  switch (option)  {
    case NET_DHCP_OPTION_IP_ADDRESS:           // IP address has changed
      netIP_ntoa (NET_ADDR_IP4, &val[0], ip_ascii, sizeof(ip_ascii));
      printf ("IP address: %s", ip_ascii);
      break;
  
    case NET_DHCP_OPTION_NTP_SERVERS:          // List of NTP Server IP addresses
      printf ("NTP Server IP address list:\n");
      idx = 0;
      while ((idx+3) < len) {
        netIP_ntoa (NET_ADDR_IP4, &val[idx], ip_ascii, sizeof(ip_ascii));
        printf ("IP address: %s", ip_ascii);
        idx += 4;
      }
      break;
  
    case NET_DHCP_OPTION_BOOTFILE_NAME:        // DCHP server boot file
      printf ("Boot File: %s\n", val);
      break;
  }   
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netDHCP6_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len)
\details
The user function \b netDHCP6_Notify is called by the DHCPv6 client to signal IPv6 address changes or provide information
about extended DHCPv6 options. Extended DHCP options are enabled in the \ref using_ethernet_interfaces_conf files.

DHCPv6 client notifications require the implementation of the function \ref netDHCP6_Notify in the user code.

The parameter \a if_id indicates the \ref interface_id "Interface Identification number".

The parameter \a option specifies the extended DHCPv6 option code.
 
The parameter \a val is a pointer to information provided by the DCHPv6 server replies (see table below).

The parameter \a len contains the length of the option value in bytes.

The following table shows the various option codes. 

| Option Code (\em option)          | Description                     | \em val is
|:----------------------------------|:--------------------------------|-----------------------
|\ref NET_DHCP6_OPTION_IP_ADDRESS   |IP address change event          | pointer to new dynamic IPv6 address (binary)         

\note
- This function is optional. It is not required for a default DHCPv6 client configuration.
- The DHCPv6 service is supported only for IPv6 networks.

\b Code \b Example
\code
// Process DCHPv6 server information
void netDHCP6_Notify (uint32_t if_id, uint8_t option, const uint8_t *val, uint32_t len) {
  char ip_ascii[40];
  
  switch (option)  {
    case NET_DHCP6_OPTION_IP_ADDRESS:          // IPv6 address has changed
      netIP_ntoa (NET_ADDR_IP6, &val[0], ip_ascii, sizeof(ip_ascii));
      printf ("IP6 address: %s", ip_ascii);
      break;
  
  }   
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ethernet_interface_callbacks
@{
*/

//  ==== Ethernet Interface Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val)
\details
The callback function \b netETH_Notify polls the link status and notifies the user about state changes. 

The argument \a if_num specifies the \ref interface_num "Ethernet Interface" for which the link status has changed.

The argument \a event specifies link event, as defined in \ref netETH_Event enumeration:

|Event                           |Description                     |
|--------------------------------|--------------------------------|
| \token{netETH_LinkDown}        | Link down                      |
| \token{netETH_LinkUp}          | Link up; val=link_info         |
| \token{netETH_Wakeup}          | Wake-up (on Magic Packet)      |
| \token{netETH_TimerAlarm}      | Timer Alarm (PTP)              |

The argument \a val stores the value of the link event.

\b Code \b Example
\code
void netETH_Notify (uint32_t if_num, netETH_Event event, uint32_t val) {
  NET_ETH_LINK_INFO *info;
     
  switch (event) {
    case netETH_LinkDown:
      printf ("Link is down\n");
      break;
    case netETH_LinkUp:
      printf ("Link is up\n");
      info = (NET_ETH_LINK_INFO *)&val;
      switch (info->speed) {
        case 0:
          printf ("10 MBit\n");
          break;
        case 1:
          printf ("100 MBit\n");
          break;
        case 2:
          printf ("1 GBit\n");
          break;
      }
      switch (info->duplex) {
        case 0:
          printf ("Half duplex\n");
          break;
        case 1:
          printf ("Full duplex\n");
          break;
      }
      break;
    case netETH_Wakeup:
      printf ("Wakeup frame received\n");
      break;
    case netETH_TimerAlarm:
      printf ("Timer alarm\n");
      break;
  }
} 
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len)
\details
The user function \b netETH_ReceiveRaw is called by the Ethernet interface to provide raw Ethernet frames to the user.
The data contains Ethernet header and payload data. This allows the users to implement additional Ethernet protocols,
which are not supported by the network library. 

The network library calls this function, if the Ethernet Type is not supported. For supported Ethernet 
Types: ARP (0x0806), IPv4 (0x0800) and IPv6 (0x86dd), the function is not called.
 
The argument \a if_num specifies the \ref interface_num "Ethernet Interface" which received the frame.

The argument \a buf points to a buffer containing the received Ethernet frame data.

The argument \a len specifies the number of received data bytes.

\note
- This function is optional. It is not required for a default Ethernet interface configuration.

\b Code \b Example
\code
void netETH_ReceiveRaw (uint32_t if_num, const uint8_t *buf, uint32_t len) {
  uint16_t ether_type;
 
  ether_type = (buf[12] << 8) | buf[13];
  if (ether_type == 0x888E) {                   // EAPoL protocol
    // Process the frame here
  }
}
\endcode
*/

/**
@}
*/

/**
\addtogroup wifi_user_api
@{
*/

//  ==== WiFi Interface User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netWiFi_Scan (uint32_t if_num, NET_WIFI_SCAN_INFO scan_info[], uint32_t *scan_num)
\details
The function \b netWiFi_Scan scans the WiFi networks within range. This function is usually executing for a long time, typically
for a few seconds. The execution time is determined by the WiFi driver and the number of available WiFi networks.  

The argument \a if_num specifies the \ref interface_num "WiFi Interface" which is used for scanning.

The argument \a scan_info is a pointer to an array of \ref NET_WIFI_SCAN_INFO structures, where the available network information
will be returned. 

The argument \a scan_num is a pointer to the length of \a scan_info array. It should initially contain the number of records
available in \a scan_info. Upon return, it contains the actual number of WiFi networks found.

Possible \ref netStatus return values:
- \em netOK: The search was successfully completed.
- \em netError: Scanning not possible in WiFi Access Point mode.
- \em netInvalidParameter: Invalid parameter provided.
- \em netDriverError: WiFi driver operation failed.

\note It is common to call the \b netWiFi_Scan function at system start-up.

\b Code \b Example
\code
NET_WIFI_SCAN_INFO scan_info[10];
uint32_t scan_num;
 
scan_num = 10;
if (netWiFi_Scan (0, scan_info, &scan_num) == netOK) {
  // Print SSIDs of available WiFi networks
  for (i = 0; i < scan_num; i++) {
    printf (%d. ssid=%s\n", i, scan_info[i].ssid);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netWiFi_GetOption (uint32_t if_num, netWiFi_Option option, void *buf, uint32_t buf_len)
\details
The function \b netWiFi_GetOption retrieves the current value of an \a option for the WiFi interface driver specified by \a if_num.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" for which an option should be obtained.

The argument \a option specifies the driver option \ref netWiFi_Option that is to be retrieved (see \ref netWiFi_SetOption).

The argument \a buf points to a buffer that will be used to store the value of the \a option.

The argument \a buf_len specifies the length of the buffer \a buf.

Possible \ref netStatus return values:
- \em netOK: Option retrieved successfully.
- \em netInvalidParameter: Invalid parameter or not supported option provided.
- \em netError: WiFi driver operation not supported.
- \em netDriverError: WiFi driver operation failed.

\b Code \b Example
\code
uint8_t bss_id[6];
 
netWiFi_GetOption (0, netWiFi_OptionBSSID, bss_id, sizeof (bss_id));
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netWiFi_SetOption (uint32_t if_num, netWiFi_Option option, const void *buf, uint32_t buf_len)
\details
The function \b netWiFi_SetOption sets different options for the WiFi interface driver identified by the argument \a if_num.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" for which the option must be set.

The argument \a option specifies the driver option \ref netWiFi_Option that is to be set (see below).

The argument \a buf points to a buffer containing the value of the option to be set.

The argument \a buf_len specifies the actual length of the buffer \a buf and must match the length of the corresponding option
as specified with argument \a option (see below).

| Option                        | Description                               | Length |
|-------------------------------|-------------------------------------------|--------|
| \token{netWiFi_OptionBSSID}   | BSSID of the WiFi Station or Access Point |6 bytes |
| \token{netWiFi_OptionTxPower} | WiFi transmit power                       |4 bytes |
| \token{netWiFi_OptionLpTimer} | Low-power deep-sleep time                 |4 bytes |
| \token{netWiFi_OptionDTIM}    | DTIM interval                             |4 bytes |
| \token{netWiFi_OptionBeacon}  | Beacon interval                           |4 bytes |

Possible \ref netStatus return values:
- \em netOK: Option successfully set.
- \em netInvalidParameter: Invalid parameter or not supported option provided.
- \em netError: WiFi driver operation not supported.
- \em netDriverError: WiFi driver operation failed.

\b Code \b Example
\code
uint8_t  bss_id[6] = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15 };
uint32_t beacon_interval = 100;
 
// Set BSSID and beacon interval 100ms
netWiFi_SetOption (0, netWiFi_OptionBSSID, bss_id, sizeof (bss_id));
netWiFi_SetOption (0, netWiFi_OptionBeacon, &beacon_interval, sizeof(beacon_interval));
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netWiFi_Activate (uint32_t if_num, const NET_WIFI_CONFIG *config)
\details
The function \b netWiFi_Activate activates the specified interface. In station mode, the function connects to the wireless network,
which must be available or the operation will fail after the timeout. In the access point mode, the function creates a wireless
network by activating the access point.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" to be activated.

The argument \a config is a pointer to the \ref NET_WIFI_CONFIG structure, which provides information needed to activate the WiFi interface.
- \a ssid:     specifies the name of the network you want to connect to, or the network that you want to create.
- \a password: specifies the password for accessing the wireless network.
- \a security: specifies the type of security that will be used for the connection, defined by \ref netWiFi_Security.
- \a channel:  specifies the WiFi channel which will be used for the connection.
  \n Valid channels for 2.4 GHz frequency are from \token{1} to \token{13}. If the value for \a channel is \token{0}, the system
  automatically selects the channel:
  - \b station:         the channel of the AP being connected to is used.
  - \b access \b point: the module automatically selects the best channel for the WiFi connection.
- \a wps_method: specifies the WiFi Protected Setup (WPS) used, defined by \ref netWiFi_WPS.
- \a wps_pin:    specifies the PIN code used by WPS, when using the \ref netWiFi_WPS_PIN method.

Possible \ref netStatus return values:
- \em netOK: WiFi interface activated successfully.
- \em netError: WiFi driver operation not supported.
- \em netInvalidParameter: Invalid parameter provided.
- \em netDriverError: WiFi driver operation failed.
- \em netTimeout: WiFi driver operation timed out.

With the \ref netWiFi_WPS_PBC method, you typically press the button, either real or virtual, both at the access point
and the station. No credentials are needed.

With the \ref netWiFi_WPS_PIN method, you must provide the PIN code that you read from the label or screen on the wireless device.
WPS configuration for station is used when station connects to an access point. It enables to connect without specifying SSID, Password,
Security Type or WiFi Channel. The actual network information can be retrieved once connected with \ref netWiFi_GetNetInfo.
WPS configuration for access point is used when access point is activated. Subsequent activate calls re-trigger the WPS procedure.

\b Code \b Example
\code
NET_WIFI_CONFIG wifi_config;
 
wifi_config.ssid       = "GuestAccess";
wifi_config.password   = "guest";
wifi_config.security   = netWiFi_SecurityWPA2;
wifi_config.channel    = 0;
wifi_config.wps_method = netWiFi_WPS_None;
 
// Connect to wireless network
status = netWiFi_Activate (0, &wifi_config);
if (status != netOK) {
  // error handling
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn \fn netStatus netWiFi_Deactivate (uint32_t if_num)
\details
The function \b netWiFi_Deactivate deactivates the specified interface.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" to be deactivated.

Possible \ref netStatus return values:
- \em netOK: WiFi interface deactivated successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netDriverError: WiFi driver operation failed.

\b Code \b Example (see \ref netWiFi_GetNetInfo)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netWiFi_IsConnected (uint32_t if_num)
\details
The function \b netWiFi_IsConnected determines the state of the wireless connection. It returns \token{true} if the WiFi station
is connected to wireless access point and IP frames can be exchanged.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" to check if it is connected.

\note
- You can use the \b netWiFi_IsConnected function to continuously monitor the WiFi connection state.

\b Code \b Example
\code
void connect_soc (void) {
  // Connect TCP socket when PPP is up. 
  if(netWiFi_IsConnected(0)) {
    netTCP_Connect (socket_tcp, remip, 1000, 0);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netWiFi_GetNetInfo (uint32_t if_num, NET_WIFI_NET_INFO *net_info)
\details
The function \b netWiFi_GetNetInfo retrieves wireless network information of a connected station. You can use the function to
retrieve network information after the initial connection using WPS. Then use this network information for all the subsequent
network connections to this wireless network.

The argument \a if_num specifies the \ref interface_num "WiFi Interface" for obtaining the network information.

The argument \a net_info is a pointer to the \ref NET_WIFI_NET_INFO structure, where the network information will be returned. 

Possible \ref netStatus return values:
- \em netOK: Network information successfully retrieved.
- \em netError: Retrieving not possible in WiFi Access Point mode.
- \em netInvalidParameter: Invalid parameter provided.
- \em netDriverError: WiFi driver operation failed.

\b Code \b Example
\code
NET_WIFI_CONFIG wifi_config;
NET_WIFI_NET_INFO net_info;
 
memset(&wifi_config, 0, sizeof(wifi_config));
 
wifi_config.wps_method = netWiFi_WPS_PBC;
 
// Connect to wireless network (WPS)
status = netWiFi_Activate (0, &wifi_config);
if (status != netOK) {
  // error handling
}
 
// Retrieve network information
if (netWiFi_IsConnected (0)) {
  status = netWiFi_GetNetInfo (0, &net_info);
  if (status != netOK) {
    // error handling
  }
  printf("SSID=%s, Password=%s",net_info.ssid, net_info.pass);
}
 
// Disconnect from wireless network
netWiFi_Deactivate (0);
\endcode
*/

/**
@}
*/


/**
\addtogroup ppp_user_api
@{
*/

//  ==== PPP Interface User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netPPP_Listen (const char *username, const char *password)
\details
The function \b netPPP_Listen configures the PPP interface to accept incoming PPP connections by starting the PPP daemon in
server mode.

The argument \a username points to the user name.

The argument \a password points to the password.

The Network Core authenticates the user credentials using the Password Authentication Protocol (PAP). Both arguments are
\token{null}-terminated strings.

Possible \ref netStatus return values:
- \em netOK: Listening to inbound dial-up connections started.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Dial-up connection already established.

\note It is common to call the \b netPPP_Listen function at system start-up.

\b Code \b Example
\code
int main (void) {
  // Initialize the Network Core 
  netInitialize ();
  // Activate the PPP interface. 
  netPPP_Listen ("Keil", "test");
   ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netPPP_Connect (const char *dial_num, const char *username, const char *password)
\details
The function \b netPPP_Connect starts a dial-up connection to the remote PPP server by starting the PPP daemon in client
mode.

The argument \a dial_num points to a \token{null}-terminated string containing the phone number of the remote PPP
server.

The argument \a username points to the user name.

The argument \a password points to the password.

The Network Core authenticates the user credentials using the Password Authentication Protocol (PAP) or Challenge-Handshake
Authentication Protocol (CHAP). Both arguments are \token{null}-terminated strings.

Possible \ref netStatus return values:
- \em netOK: Dial-up connection started.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Dial-up connection already established.

\note
- You must call the \b netPPP_Connect function if you want to establish a dial-up connection using PPP.
- When using a direct cable connection, \a dial_num can be set to \token{NULL}, because the Null_Modem device driver ignores
  \a dial_num.

\b Code \b Example
\code
void dial_remote (void) {
  // Dial remote PPP Server. 
  netPPP_Connect ("04213372", "Keil", "test");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netPPP_Close (void)
\details
The function \b netPPP_Close disconnects the PPP link between two modems.

Possible \ref netStatus return values:
- \em netOK: Disconnection started.

\note
- You can call the \b netPPP_Close function when the PPP network daemon is either in client mode or in server mode.
- Because the PPP client starts a dial-up connection, it is also the PPP client that usually disconnects the PPP link.
- The \b netPPP_Close function does not change the running mode of the PPP daemon. If the PPP daemon was in server mode, PPP
  daemon re-initializes the modem driver to accept further incoming calls.

\b Code \b Example
\code
void disconnect_link (void) {
  // Disconnect a dial-up link. 
  netPPP_Close ();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netPPP_LinkUp (void)
\details
The function \b netPPP_LinkUp determines the state of PPP link between the two modems. It returns \token{true} if the PPP
link state is \b network and IP frames can be exchanged.

\note
- You can call the \b netPPP_LinkUp function when the PPP network daemon is either in client mode or in server mode.
- You can also use the \b netPPP_LinkUp function to continuously monitor the PPP link.

\b Code \b Example
\code
void connect_soc (void) {
  // Connect TCP socket when PPP is up. 
  if(netPPP_LinkUp()) {
    netTCP_Connect (socket_tcp, remip, 1000, 0);
  }
}
\endcode
*/

/**
@}
*/


/**
\addtogroup slip_user_api
@{
*/

//  ==== SLIP Interface User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSLIP_Listen (void)
\details
The function \b netSLIP_Listen configures the SLIP interface to accept incoming SLIP connections by starting the SLIP daemon
in server mode.

\note It is common to call \b netSLIP_Listen at system start-up. 

Possible \ref netStatus return values:
- \em netOK: Listening to inbound dial-up connections started.
- \em netWrongState: Dial-up connection already established.

\b Code \b Example
\code
int main (void) {
  netInitialize ();
  // Activate the SLIP interface. 
  netSLIP_Listen ();
   ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSLIP_Connect (const char *dial_num)
\details
The function \b netSLIP_Connect starts a dial-up connection to the remote SLIP server by starting the SLIP daemon in client
mode.

The argument \a dial_num points to a \token{null}-terminated string containing the phone number of the remote SLIP
server.

Possible \ref netStatus return values:
- \em netOK: Dial-up connection started.
- \em netInvalidParameter: Invalid \a dial_num parameter provided.
- \em netWrongState: Dial-up connection already established.

\note
- You must call the \b netSLIP_Connect function when you want to establish a dial-up connection using SLIP.
- When using a direct cable connection, you can set \a dial_num to \token{NULL} because the Null_Modem device driver ignores
  \a dial_num.

\b Code \b Example
\code
void dial_remote (void) {
  // Dial remote SLIP Server. 
  netSLIP_Connect ("04213372");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSLIP_Close (void)
\details
The function \b netSLIP_Close disconnects the SLIP link between the two modems.

Possible \ref netStatus return values:
- \em netOK: Disconnection started.

\note
- You can call the \b netSLIP_Close function when the SLIP network daemon is either in client mode or in server mode.
- Since the SLIP client starts a dial-up connection, it is also the SLIP client that usually disconnects the SLIP link.
- The \b netSLIP_Close function does not change the running mode of the SLIP daemon. If the SLIP daemon was in server mode,
  SLIP daemon re-initializes the modem driver to accept further incoming calls.

\b Code \b Example
\code
void disconnect_link (void) {
  // Disconnect a dial-up link. 
  netSLIP_Close ();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netSLIP_LinkUp (void)
\details
The function \b netSLIP_LinkUp determines the state of SLIP link between the two modems. It returns \token{true} if IP frames
can be exchanged over the SLIP link.

\note
- You can call the \b netSLIP_LinkUp function when the SLIP network daemon is either in client mode or in server mode.
- You can also use the \b netSLIP_LinkUp function to continuously monitor the state of the SLIP link.

\b Code \b Example
\code
void connect_soc (void) {
  // Connect TCP socket when SLIP is up. 
  if(netSLIP_LinkUp()) {
    netTCP_Connect (socket_tcp, remip, 1000, 0);
  }
}
\endcode
*/

/**
@}
*/

/**
\addtogroup netPing_Func
@{
*/

//  ==== Ping User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netPing_Echo (const NET_ADDR *addr, netPing_cb_t cb_func)
\details
The non-blocking function \b netPing_Echo starts the ping process on the Network Core. This causes the Ping client to send
an echo request to the remote IP address. The result of the operation is provided with the callback function.

The argument \a addr is a pointer to the buffer containing the IP address of the remote host to be pinged.

The argument \a cb_func points to an event callback function called by the Ping client (running on Network Core) 
when the ping session ends. Refer to \ref netPing_cb_t.

Possible \ref netStatus return values:
- \em netOK: Ping client started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: Ping client is busy.

\b Code \b Example
\code
static void ping_callback (netPing_Event event);
 
void ping_host (void) {
  const NET_ADDR addr = { NET_ADDR_IP4, 0, 192, 168, 0, 100 };
 
  if (netPing_Echo (&addr, ping_callback) == netOK) {
    printf("Ping started.\n");
  }
  else {
    printf("Ping not ready or bad parameters.\n");
  }
}
 
static void ping_callback (netPing_Event event) {
  switch (event) {
    case netPing_EventSuccess:
      printf ("Remote host responded to ping.\n");
      break;
    case netPing_EventTimeout:
      printf ("Ping timeout, no response.\n");
      break;
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netPing_EchoX (const char *target, uint32_t flags)
\details
The blocking function \b netPing_EchoX starts the ping process on the Network Core and returns the result of the operation. 
This causes the Ping client to send an echo request to the remote IP address and wait for an echo response. 

The argument \a target is a fully qualified domain name or an absolute IP address of the remote host that needs to be pinged.
If \a target is a hostname, the ping client uses the DNS resolver to resolve the destination IP address.

The argument \a flags specify the IP version to be used for ping. The value of \token{0} for \a flags is
the use default ping settings.

|Flags                    |Description                    |
|-------------------------|-------------------------------|
|\token{NET_PING_IP4_ONLY}|Force using IP version 4 only. |
|\token{NET_PING_IP6_ONLY}|Force using IP version 6 only. |

Possible \ref netStatus return values:
- \em netOK: Target host responded ok.
- \em netInvalidParameter: Invalid or not supported parameter.
- \em netDnsResolverError:  Target name not existing.
- \em netTimeout: Target host not responding.

\note To use this function, you must enable the \ref netDNSc_Func "DNS client" in the selection of RTE Components.

\b Code \b Example (absolute IP address)
\code
if (netPing_EchoX ("192.168.0.100", 0) == netOK) {
  printf ("Target host responded to ping.\n");
}
else {
  printf ("Ping timeout, no response.\n");
}
\endcode

\b Code \b Example (fully qualified domain name)
\code
if (netPing_EchoX ("www.arm.com", 0) == netOK) {
  printf ("Target host responded to ping.\n");
}
else {
  printf ("Ping timeout, no response.\n");
}
\endcode
*/

/**
@}
*/


/**
\addtogroup starting_dns
@{
*/

//  ==== DNS Client User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDNSc_GetHostByName (const char *name, int16_t addr_type, netDNSc_cb_t cb_func)
\details
The non-blocking function \b netDNSc_GetHostByName resolves the IP address of a host from a host name. It starts the DNS
client and sends a request to the DNS server.

The argument \a name is a pointer to a \token{null}-terminated string that specifies the host name. The argument \a name can 
also point to the dotted decimal IPv4 address in string format (for example "192.168.0.100"), or to the hexadecimal IPv6 address
in string format (for example "2001:4860:4860::8888"). In this case, the DNS client calls the \a cb_func function 
immediately with the IP address. The argument \a name can also be "localhost", in this case the DNS client calls the \a cb_func
function immediately with the loopback IP address: "127.0.0.1" for IPv4 or "::1" for IPv6.

The argument \a addr_type specifies the type of address to resolve. It is \ref NET_ADDR_IP4 when you want to resolve an IPv4
address, and \ref NET_ADDR_IP6 when you want to resolve an IPv6 address.
 
The argument \a cb_func specifies a user-provided callback function. Refer to \ref netDNSc_cb_t.

Possible \ref netStatus return values:
- \em netOK: DNS client started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netBusy: DNS client is busy.
- \em netServerError: DNS server IP address undefined.

\note The function \b netDNSc_GetHostByName is deprecated, use the \ref netDNSc_GetHostByNameX function instead.

\b Code \b Example
\code
static void dns_cbfunc (netDNSc_Event event, const NET_ADDR *addr);
 
if (netDNSc_GetHostByName ("www.arm.com", NET_ADDR_IP4, dns_cbfunc) == netOK) {
  // Started, will complete on callback notification
}
 
static void dns_cbfunc (netDNSc_Event event, const NET_ADDR *addr) {
  char ip_ascii[40];
  
  switch (event) {
    case netDNSc_EventSuccess:
      // Host Address successfully resolved
      netIP_ntoa (addr->addr_type, adr->addr, ip_ascii, sizeof(ip_ascii));
      printf("IP Address: %s\n", ip_ascii);
      break;
 
    case netDNSc_EventNotResolved:
      // Error, host name does not exist in DNS record database
      break;
 
    case netDNSc_EventTimeout:
      // Error, DNS resolver timeout expired
      break;
 
    case netDNSc_EventError:
      // Error, DNS protocol error occurred
      break;
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDNSc_GetHostByNameX (const char *name, int16_t addr_type, NET_ADDR *addr)
\details
The blocking function \b netDNSc_GetHostByNameX resolves the IP address of a host from a host name. It starts the DNS
client, sends a request to the DNS server and returns the resolved IP address.

The argument \a name is a pointer to a \token{null}-terminated string that specifies the host name. The argument \a name can 
also point to the dotted decimal IPv4 address in string format (for example "192.168.0.100"), or to the hexadecimal IPv6 address
in string format (for example "2001:4860:4860::8888"). In this case, the DNS client calls the \a cb_func function 
immediately with the IP address. The argument \a name can also be "localhost", in this case the DNS client calls the \a cb_func
function immediately with the loopback IP address: "127.0.0.1" for IPv4 or "::1" for IPv6.

The argument \a addr_type specifies the type of address to resolve. It is \ref NET_ADDR_IP4 when you want to resolve an IPv4
address, and \ref NET_ADDR_IP6 when you want to resolve an IPv6 address.
 
The argument \a addr specifies a user-provided \ref NET_ADDR address structure that will receive the resolved IP address.

Possible \ref netStatus return values:
- \em netOK: Host name successfully resolved.
- \em netInvalidParameter: Invalid parameter provided.
- \em netDnsResolverError: Host name not existing.
- \em netTimeout: DNS server not responding.
- \em netServerError: DNS server IP address undefined.
- \em netError: DNS protocol error occurred.

\b Code \b Example
\code
NET_ADDR addr;
char ip_ascii[40];
 
if (netDNSc_GetHostByNameX ("www.arm.com", NET_ADDR_IP4, &addr) == netOK) {
  // Success, 'addr' holds resolved IP address
  netIP_ntoa (addr->addr_type, adr->addr, ip_ascii, sizeof(ip_ascii));
  printf("IP Address: %s\n", ip_ascii);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netDNSc_ClearCache (void)
\details
The function \b netDNSc_ClearCache flushes all resolved IP addresses from the local DNS cache. You can use this function
when the cache holds outdated values that are no longer valid.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netBusy: DNS client is busy.

\b Code \b Example
\code
if (netDNSc_ClearCache () == netOK) {
  // All entries flushed from DNS cache
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ftp_user_api
@{
*/

//  ==== FTP Server User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_Start (void)
\details
The function \b netFTPs_Start is used to start the FTP server at runtime.

Possible \ref netStatus return values:
- \em netOK: FTP server started successfully.

\note
  If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the FTP server previously using
  \ref netFTPs_Stop or have set \c NET_START_SERVICE to \token{0}.

\b Code \b Example (see \ref netFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_Stop (void)
\details
The function \b netFTPs_Stop is used to stop the FTP server at runtime. To re-start the FTP server, use \ref netFTPs_Start.

Possible \ref netStatus return values:
- \em netOK: FTP server stopped successfully.

\b Code \b Example (see \ref netFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_Running (void)
\details
The function \b netFTPs_Running is used to check whether the FTP server is running. A return value of \token{true} shows a
running FTP server.

\b Code \b Example (see \ref netFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netFTPs_GetPort (void)
\details
The function \b netFTPs_GetPort returns the port of the FTP server.

\b Code \b Example
\code
printf ("FTP server is listening on port %d\n", netFTPs_GetPort ());
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_SetPort (uint16_t port)
\details
The function \b netFTPs_SetPort sets the port of the FTP server. The FTP server must not run while setting the port. If
required, stop it first using \ref netFTPs_Stop.

The argument \a port specifies the port number to be used.

Possible \ref netStatus return values:
- \em netOK: Port successfully set.
- \em netWrongState: FTP server is running.

\b Code \b Example
\code
void change_server_port (uint16_t port) {}
  if (netFTPs_Running() == true) {
    netFTPs_Stop();
  }
  netFTPs_SetPort (port);
  netFTPs_Start();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netFTPs_GetRootPath (void)
\details
The function \b netFTPs_GetRootPath returns the path to the current root directory if \c FTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_FTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example
\code
if (netFTPs_GetRootPath() != NULL) {
  printf ("User files are stored here: %s\n", netFTPs_GetRootPath ());
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_SetRootPath (const char *path)
\details
The function \b netFTPs_SetRootPath sets the path to the root directory of FTP server if \c FTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_FTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime. Root directory specifies a path on a storage device, where the user files are stored. This path is common to all
FTP server users.

The argument \a path is a pointer to the new root path to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a path to the root path of the FTP server. The maximum length of the \a path string is 
limited to \token{79} characters.

You can change the root path until the user logs on to the server. Once the user is authenticated, the root path can no longer
be changed. This simple solution allows the root folder to be mapped to the user when logging on to the server. For example
to access two drives, it is therefore necessary to create two user profiles, one has a root folder on the first drive (i.e "M:")
and the other on the second drive (i.e. "F:"). The root path can be changed in the \ref netFTPs_CheckUsername or in the 
\ref netFTPs_CheckPassword function. To access another drive, the user must log out and then log on with other credentials.
 
Possible \ref netStatus return values:
- \em netOK: Root path successfully set.
- \em netInvalidParameter: Invalid \a path parameter provided.
- \em netWrongState: FTP server is running and the user is logged in.
- \em netError: Root path not enabled in the configuration.

\note
When the function ends, the content of \a path becomes irrelevant and may be discarded.

\b Code \b Example
\code
uint8_t netFTPs_CheckUsername ( const char *username) {
  if (strcmp (username, "DRIVE_M") == 0) {
    netFTPs_SetRootPath ("M:");
    return (1);
  }
  if (strcmp (username, "DRIVE_F") == 0) {
    netFTPs_SetRootPath ("F:");
    return (2);
  }
  return (0);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netFTPs_GetUsername (void)
\details
The function \b netFTPs_GetUsername returns the user name of the built-in user if \c FTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_FTP.h file. If this define is set to \token{0}, the function is not available at runtime
and returns \token{NULL}. 

\b Code \b Example (see \ref netFTPs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_SetUsername (const char *username)
\details
The function \b netFTPs_SetUsername sets the user name of the built-in user if \c FTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_FTP.h file. If this define is set to \token{0}, the function is not available at runtime. 

The argument \a username is a pointer to the user name to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a username to the user name of the built-in user. The maximum length of the \a username string is 
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Username successfully set.
- \em netInvalidParameter: Invalid \a username provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a username becomes irrelevant and may be discarded. 

\b Code \b Example
\code
if (netFTPs_LoginActive() == true) {
  netFTPs_SetUsername ("sysadmin");
  netFTPs_SetPassword ("a$Min#77");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netFTPs_GetPassword (void)
\details
The function \b netFTPs_GetPassword returns the password of the built-in user account if \c FTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_FTP.h file. If this define is set to \token{0}, the function is not available at runtime
and returns \token{NULL}. 

\b Code \b Example (see \ref netFTPs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_SetPassword (const char *password)
\details
The function \b netFTPs_SetPassword sets the password of the built-in user if \c FTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_FTP.h file. If this define is set to \token{0}, the function is not available at runtime. 

The argument \a password is a pointer to the password that is to be set, which is a \token{null}-terminated string. The function
copies the content of the \a password to the password of the build-in user. The maximum length of the \a password string is 
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Password successfully set.
- \em netInvalidParameter: Invalid \a password provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a password becomes irrelevant and may be discarded. 

\b Code \b Example (see \ref netFTPs_SetUsername)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_LoginActive (void)
\details
The function \b netFTPs_LoginActive checks if the FTP server is set up for user authentication.

\b Code \b Example
\code
if (netFTPs_LoginActive() == true) {
  printf ("Authentication is enabled\n");
  printf ("Username is: %s\n", netFTPs_GetUsername());
  printf ("Password is: %s\n", netFTPs_GetPassword());
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPs_LoginOnOff (bool login)
\details
The function \b netFTPs_LoginOnOff enables or disables the user authentication on the FTP server. If
\c FTP_SERVER_AUTH_ENABLE is set to \token{0} in the \b Net_Config_FTP.h file, the function is not available at runtime. 

The argument \a login switches the log-in on (\token{true}) or off (\token{false}).

Possible \ref netStatus return values:
- \em netOK: Login enabled or disabled successfully.
- \em netError: Authentication not enabled in the configuration.

\b Code \b Example
\code
if (netFTPs_LoginActive () == true) {
  netFTPs_LoginOnOff (false);
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ftp_access_filter_mui
@{
*/

//  ==== FTP Server Access Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_AcceptClient (const NET_ADDR *addr)
\details
The function \b netFTPs_AcceptClient checks if a connection from the remote client is allowed or not. This enables remote
client filtering. You can selectively decide which clients are allowed to connect to the FTP server and which are not.

The argument \a addr points to a buffer containing IP address and port of the remote machine.

\note This function is optional. If missing, the library default function is used which accepts all remote clients. 

\b Code \b Example

The following example is available in the user code template file \b %FTP_Server_Access.c. Customize it to the application's
needs.

\code
bool netFTPs_AcceptClient (const NET_ADDR *addr) {
  if (addr->addr_type == NET_ADDR_IP4) {
    // IPv4 client
    if (addr->addr[0] == 192  &&
        addr->addr[1] == 168  &&
        addr->addr[2] == 0    &&
        addr->addr[3] == 1) {
      // Accept connection from client at 192.168.0.1
      return (true);
    }
  }
  else {
    // IPv6 client
    const uint8_t ip6_addr[NET_ADDR_IP6_LEN] = { 
                     0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
    if (memcmp (addr->addr, ip6_addr, NET_ADDR_IP6_LEN) == 0) {
      // Accept connection from client at [fe80::1c30:6cff:fea2:455e]
      return (true);
    }
  }
  // Deny connection.
  return (false);
}
\endcode
*/

//  ==== FTP Server Multi-User Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netFTPs_CheckUsername (const char *username)
\details
The function \b netFTPs_CheckUsername authenticates the username and returns the corresponding identification number.
A value of \token{0} is returned if the user does not exist.

The argument \a username points to the user name.

\b Code \b Example

The following example is available in the user code template file \b %FTP_Server_Multiuser.c. Customize it to the
application's needs.

\code
uint8_t netFTPs_CheckUsername (const char *username) {
  if (strcmp (username, "guest") == 0) {
    // Username is correct, return user_id
    return (1);
  }
  return (0);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_CheckPassword (uint8_t user_id, const char *password)
\details
The function \b netFTPs_CheckPassword authenticates the password for a specified user ID.

The argument \a user_id is the identification number of a user.

The argument \a password points to the password that gets checked.

\b Code \b Example

The following example is available in the user code template file \b %FTP_Server_Multiuser.c. Customize it to the
application's needs.

\code
bool netFTPs_CheckPassword (uint8_t user_id, const char *password) {
  if (user_id == 1) {
    if (strcmp (password, "guest") == 0) {
      // Password is correct
      return (true);
    }
  }
  return (false);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access)
\details
The function \b netFTPs_FileAccess checks if file access is allowed for a specific user. This allows access protection of
sensitive files. The access to protected files will be blocked for unprivileged users. The error code
"550 Access is denied" will be returned to the client if access is not allowed.

The argument \a user_id is the user identification number as returned by \ref netFTPs_CheckUsername.
\a user_id identifies the user who is trying to access the specified file.

The argument \a fname points to a buffer containing the file name with path which should be accessed. The file name
is a \token{null}-terminated string.

The argument \a access specifies the requested type of file access:
- \ref NET_ACCESS_FILE_READ - File Read is allowed.
- \ref NET_ACCESS_FILE_WRITE - File Write is allowed.
- \ref NET_ACCESS_DIRECTORY_CREATE -Directory Create is allowed.
- \ref NET_ACCESS_DIRECTORY_REMOVE - Directory Remove is allowed.
- \ref NET_ACCESS_DIRECTORY_LIST - Directory List is allowed.

\note This function is optional. If the FTP file access restriction is not used, this function is not required. 

\b Code \b Example

The following example is available in the user code template file \b %FTP_Server_Multiuser.c. Customize it to the
application's needs.

\code
bool netFTPs_FileAccess (uint8_t user_id, const char *fname, uint32_t access) {
  if (user_id == 1) {
    if ((strcmp (fname, "/log/test.txt") == 0) && (access == NET_ACCESS_FILE_WRITE)) {
      // User "guest" is not allowed to modify or delete "test.txt" in "log" folder
      return (false);
    }
  }
  return (true);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netFTPs_GetUserId (void)
\details
The function \b netFTPs_GetUserId retrieves the user identification number.

\note This function returns a value of \token{0} for system administrator account.

\b Code \b Example
\code
uint32_t log_count1;
 
void netFTPs_Notify (netFTPs_Event event) {
  if ((event == netFTPs_EventLogin) && (netFTPs_GetUserId() == 1)) {
    // Count user 1 logins
    log_count1++;
  }
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ftp_user_notification
@{
*/

//  ==== FTP Server User Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netFTPs_Notify (netFTPs_Event event)
\details
The callback function \b netFTPs_Notify notifies the user application about events in FTP server. This function is useful to
synchronize various actions, such as firmware upgrade, to FTP server events. The firmware upgrade might start after the
\token{netFTPs_EventLogout} event is signaled and a new firmware image file has been uploaded to the server.

The argument \a event contains the FTP server event as specified by \ref netFTPs_Event.

\b Code \b Example

The following skeleton is available in the user code template file \b %FTP_Server_Event.c. Customize it to the application's
needs.

\code
void netFTPs_Notify (netFTPs_Event event) {
 
  switch (event) {
    case netFTPs_EventLogin:
      // User logged in, session is busy
      break;
 
    case netFTPs_EventLogout:
      // User logged out, session is idle
      break;
 
    case netFTPs_EventLoginFailed:
      // User login failed (invalid credentials)
      break;
 
    case netFTPs_EventDownload:
      // File download ended
      break;
 
    case netFTPs_EventUpload:
      // File upload ended
      break;
 
    case netFTPs_EventDelete:
      // File deleted
      break;
 
    case netFTPs_EventRename:
      // File or directory renamed
      break;
 
    case netFTPs_EventMakeDirectory:
      // Directory created
      break;
 
    case netFTPs_EventRemoveDirectory:
      // Directory removed
      break;
 
    case netFTPs_EventOperationDenied:
      // Requested file operation denied
      break;
 
    case netFTPs_EventLocalFileError:
      // Local file operation error
      break;
 
    case netFTPs_EventFileError:
      // Generic file operation error
 
    case netFTPs_EventError:
      // Generic FTP server error
      break;
  }
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ftp_fs_interface
@{
*/

//  ==== FTP Server File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void *netFTPs_fopen (const char *fname, const char *mode)
\details
The function \b netFTPs_fopen opens a file for reading or writing.

The argument \a fname specifies the name of the file to open.

The argument \a mode defines the type of access permitted for the file. The argument can have one of the following values:
|Mode|Description|
|----|-----------|
|"rb"|Opens the file for reading. If the file does not exist, fopen fails.|
|"wb"|Opens an empty file for writing if the file does not exist. If the file already exists, its contents are cleared.|

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netFTPs_fclose (void *file)
\details
The function \b netFTPs_fclose closes the file identified by the \a file stream pointer in the function argument.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netFTPs_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netFTPs_fread reads \a len bytes from the file \a file stream pointer specified in the function argument.

The argument \a buf is a pointer to the buffer where the function stores the read data.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.

\note The function must read \a len bytes. The FTP server stops reading and closes the file if the return value
is less than \a len bytes. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len)
\details
The function \b netFTPs_fwrite writes a block of data to the file identified by the \a file stream pointer.

The argument \a buf points to the buffer containing the data that is to be written to the file.

The argument \a len specifies the number of bytes to write to the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.

\note The FTP server stops writing and closes the file if the return value is less than \a len bytes.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_fdelete (const char *fname)
\details
The function \b netFTPs_fdelete deletes the file specified by \a fname from the server.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_frename (const char *fname, const char *newname)
\details
The function \b netFTPs_frename renames a file specified by \a fname to \a newname on the server.

The argument \a fname must be the name of an existing file.

The argument \a newname must be a valid file name that does not exist in the scope.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_mkdir (const char *path)
\details
The function \b netFTPs_mkdir creates a new directory on the FTP server for file storage. On success, it returns
\token{true}.

The argument \a path is a pointer to the directory's name.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_rmdir (const char *path)
\details
The function \b netFTPs_rmdir deletes a directory on the FTP server. On success, it returns \token{true}.

The argument \a path is a pointer to the directory's name.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netFTPs_chdir (const char *path)
\details
The function \b netFTPs_chdir verifies that specified directory exists on the FTP server. On success, it returns \token{true}.
If the file system on the FTP server storage device does not support directories, the function must always return \token{false}.

The argument \a path is a pointer to the directory's name.


The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t netFTPs_ffind (const char *mask, char *fname, uint32_t *fsize, NET_FS_TIME *ftime, bool first)
\details
The function \b netFTPs_ffind searches the File System directory for files matching the specified mask filter \a mask.
Matching file information is stored to the output buffer \a fname, \a fsize and \a ftime. The output data is then processed
in FTP server and formatted in the FTP folder listing format.

The argument \a fname is a pointer to a buffer, where the file name is going to be stored. If this argument is \token{NULL},
the file name is not requested and is not saved.

The argument \a fsize is a pointer to where the file size is going to be stored. If this argument is \token{NULL}, the file
size is not requested and is not saved.

The argument \a ftime is a pointer to a structure, that will receive the last modification time of a file. If this argument
is \token{NULL}, the last modification time is not requested and is not saved.

The argument \a first has a value of \token{true} when the first file is requested. On all subsequent calls, the argument
\a first has a value of \token{false}. It is used to initialize the file search engine in the File System Component.

This function returns the following values:
|Return Value                  |Description                     |
|------------------------------|--------------------------------|
|\token{NET_FS_ATTR_FILE}      |The entry found is a file       |
|\token{NET_FS_ATTR_DIRECTORY} |The entry found is a directory  |
|\token{0}                     |No entry found                  |

\note
Currently, the function \b netFTPs_ffind requires the File System Component of the MDK-Professional Middleware to be present.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Server_FS.c module.
*/

/**
@}
*/

/**
\addtogroup ftpc_user_api
@{
*/

//  ==== FTP Client User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netFTPc_Connect (const NET_ADDR *addr, netFTP_Command command)
\details
The function \b netFTPc_Connect starts the FTP client. The FTP client then connects to a FTP server specified with the
argument \a addr which points to a buffer containing the IP address and port of the FTP server. If the specified port is \token{0},
the client uses a standard FTP server port \token{21} to connect to the server.

The argument \a command specifies a command that is preformed when the FTP client connects to the FTP server. The following
commands are supported:

|Command  |Description                                                       |
|---------|------------------------------------------------------------------|
|\token{netFTP_CommandPUT}   |Puts a local file from local system to FTP server                 |
|\token{netFTP_CommandGET}   |Retrieves a file from FTP server to save as a local file          |
|\token{netFTP_CommandAPPEND}|Appends a local file to an existing file on FTP server            |
|\token{netFTP_CommandDELETE}|Deletes a file from FTP server                                    |
|\token{netFTP_CommandLIST}  |Lists files located on FTP server (including detailed information)|
|\token{netFTP_CommandRENAME}|Renames a file or directory on FTP server                         |
|\token{netFTP_CommandMKDIR} |Creates a new directory on FTP server                             |
|\token{netFTP_CommandRMDIR} |Deletes an empty directory on FTP server                          |
|\token{netFTP_CommandNLIST} |Lists file names located on FTP server (names only)               |

Possible \ref netStatus return values:
- \em netOK: FTP client started successfully.
- \em netInvalidParameter: Invalid FTP server address provided.
- \em netWrongState: FTP client is busy.

\b Code \b Example
\code
const NET_ADDR4 addr = { NET_ADDR_IP4, 0, 192, 168, 0, 253 };
  
if (netFTPc_Connect ((NET_ADDR *)&addr, netFTP_CommandPUT) == netOK) {
  printf("FTP client started.\n");
}
else {
  printf("FTP client is busy.\n");
}
\endcode
*/

/**
@}
*/

/**
\addtogroup ftpc_operation
@{
*/

//  ==== FTP Client User Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netFTPc_Process (netFTPc_Request request, char *buf, uint32_t buf_len)
\details
The callback function \b netFTPc_Process provides additional parameters for the FTP client session such as the credentials to
login to the FTP server, local and remote file name for the file operation, etc. The FTP client calls this function several
times to complete the file operation requested.

The argument \a request specifies the type of additional information (user, password, file name, etc.) that the FTP Client
requires:
|  Type         |Description|
|---------------|--------------|
| \token{netFTPc_RequestUsername}      | Username to login to FTP server                      |
| \token{netFTPc_RequestPassword}      | Password to login to FTP server                      |
| \token{netFTPc_RequestDirectory}     | Working directory path on server for all commands    |
| \token{netFTPc_RequestName}          | File or Directory name for FTP commands              |
| \token{netFTPc_RequestNewName}       | New File or Directory name for RENAME command        |
| \token{netFTPc_RequestListMask}      | File filter/mask for LIST command (wildcards allowed)|
| \token{netFTPc_RequestList}          | Received data if LIST command is given               |
| \token{netFTPc_RequestLocalFilename} | Local filename (including path)                      |

The argument \a buf is a pointer to the output buffer where the function writes the requested data.

The argument \a buf_len specifies the length of the output buffer in bytes.

\b Code \b Example

The following example is available in the user code template file \b %FTP_Client_UIF.c. Customize it to the application's
needs.

\code
uint32_t netFTPc_Process (netFTPc_Request request, char *buf, uint32_t buf_len) {
  uint32_t len = 0;
  int32_t i;
 
  switch (request) {
    case netFTPc_RequestUsername:
      // Username to login to FTP server
      len = sprintf (buf, "anonymous");
      break;
 
    case netFTPc_RequestPassword:
      // Password to login to FTP server
      len = sprintf (buf, "test@keil.com");
      break;
 
    case netFTPc_RequestDirectory:
      // Working directory path on server
      len = sprintf (buf, "/Logs");
      break;
 
    case netFTPc_RequestName:
      // Filename for PUT, GET, APPEND, DELETE and RENAME commands
      // Directory name for MKDIR and RMDIR commands
      len = sprintf (buf, "test.log");
      break;
 
    case netFTPc_RequestNewName:
      // New name for a RENAME command
      len = sprintf (buf, "renamed.log");
      break;
 
    case netFTPc_RequestListMask:
      // File filter/mask for LIST command (wildcards allowed)
      len = sprintf (buf, "");
      break;
 
    case netFTPc_RequestList:
      // Received data if LIST command is given
      for (i = 0; i < len; i++) {
        putchar (buf[i]);
      }
      break;
 
    case netFTPc_RequestLocalFilename:
      // Local filename
      len = sprintf (buf, "test_log.txt");
      break;
  }
  return (len);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netFTPc_Notify (netFTPc_Event event)
\details

The callback function \b netFTPc_Notify is called automatically when an FTP event occurred and notifies the user application
when the FTP client operation ends.

The argument \a event is a \ref netFTPc_Event signal:

|Event                   |Description                                                                           |
|------------------------|--------------------------------------------------------------------------------------|
|\token{netFTPc_EventSuccess}        |The file operation completed successfully                                             |
|\token{netFTPc_EventTimeout}        |FTP Server response has timed out, and hence the FTP client has aborted the operation |
|\token{netFTPc_EventLoginFailed}    |The FTP client failed to login to FTP server                                          |
|\token{netFTPc_EventAccessDenied}   |The file access to a specified file is not allowed                                    |
|\token{netFTPc_EventFileNotFound}   |The requested file was not found on FTP server                                        |
|\token{netFTPc_EventInvalidDirectory}    |Working directory path not found on FTP server                                        |
|\token{netFTPc_EventLocalFileError} |File open or file write error on local system                                         |
|\token{netFTPc_EventError}          |An error encountered during the file operation                                        |

\b Code \b Example

The following skeleton is available in the user code template file \b %FTP_Client_UIF.c. Customize it to the application's
needs.

\code
void netFTPc_Notify (netFTPc_Event event) {
  switch (event) {
    case netFTPc_EventSuccess:
      // File operation successful
      break;
 
    case netFTPc_EventTimeout:
      // Timeout on file operation
      break;
 
    case netFTPc_EventLoginFailed:
      // Login error, username/password invalid
      break;
 
    case netFTPc_EventAccessDenied:
      // File access not allowed
      break;
 
    case netFTPc_EventFileNotFound:
      // File not found
      break;
 
    case netFTPc_EventInvalidDirectory:
      // Working directory path not found
      break;
 
    case netFTPc_EventLocalFileError:
      // Local file open/write error
      break;
 
    case netFTPc_EventError:
      // Generic FTP client error
      break;
  }
}
\endcode
*/

/**
@}
*/

/**
\addtogroup ftpc_fs_interface
@{
*/

//  ==== FTP Client File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void *netFTPc_fopen (const char *fname, const char *mode)
\details
The function \b netFTPc_fopen opens a local file for reading or writing.

The argument \a mode defines the type of access permitted for the file \a fname. It can have one of the following values:
|Mode|Description|
|----|-----------|
|"rb"|Opens the file for reading. If the file does not exist, fopen fails.|
|"wb"|Opens an empty file for writing. If the file already exists, its contents are cleared.|

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netFTPc_fclose (void *file)
\details
The function \b netFTPc_fclose closes the file identified by the \a file stream pointer.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netFTPc_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netFTPc_fread reads \a len bytes from the file identified by the \a file stream pointer in the function
argument.

The argument \a buf is a pointer to the buffer where the function stores the data read from the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Client_FS.c module.

\note The function must read \a len bytes. The FTP client stops reading and closes the file if the return value
is less than \a len bytes. 
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len)
\details
The function \b netFTPc_fwrite writes a block of data to the file identified by the \a file stream pointer.

The argument \a buf points to the buffer containing the data that is to be written to the file.

The argument \a len specifies the number of bytes to be written to the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %FTP_Client_FS.c module.

\note
The function must write \a len bytes. The FTP client stops writing, aborts data transfer and closes the FTP session if the
return value is less than \a len bytes.
*/


/**
@}
*/

/**
\addtogroup tftp_server_user_api
@{
*/

//  ==== TFTP Server User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPs_Start (void)
\details
The function \b netTFTPs_Start starts the TFTP server at runtime. It can be stopped again using \ref netTFTPs_Stop.

Possible \ref netStatus return values:
- \em netOK: TFTP server started successfully.

\note
  If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the TFTP server previously using
  \ref netTFTPs_Stop or have set \c NET_START_SERVICE to \token{0}.

\b Code \b Example (see \ref netTFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPs_Stop (void)
\details
The function \b netTFTPs_Stop stops the TFTP server at runtime. It can be restarted using \ref netTFTPs_Start.

Possible \ref netStatus return values:
- \em netOK: TFTP server stopped successfully.

\b Code \b Example (see \ref netTFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTFTPs_Running (void)
\details
The function \b netTFTPs_Running checks whether the TFTP server is running. It returns \token{true} if the server is up and
running.

\b Code \b Example (see \ref netTFTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netTFTPs_GetPort (void)
\details
The function \b netTFTPs_GetPort returns the port that is used for the TFTP server.

\b Code \b Example
\code
printf ("TFTP server is listening on port %d\n", netTFTPs_GetPort ());
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPs_SetPort (uint16_t port)
\details
The function \b netTFTPs_SetPort sets the port that is to be used for the TFTP server. The TFTP server must not run while
setting the port. If required, stop it first using \ref netTFTPs_Stop.

The argument \a port specifies the port number to be used.

Possible \ref netStatus return values:
- \em netOK: Port successfully set.
- \em netWrongState: TFTP server is running.

\b Code \b Example
\code
void change_server_port (uint16_t port) {}
  if (netTFTPs_Running() == true) {
    netTFTPs_Stop();
  }
  netTFTPs_SetPort (port);
  netTFTPs_Start();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netTFTPs_GetRootPath (void)
\details
The function \b netTFTPs_GetRootPath returns the path to the current root directory if \c TFTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_TFTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example
\code
if (netTFTPs_GetRootPath() != NULL) {
  printf ("Boot files are stored here: %s\n", netTFTPs_GetRootPath ());
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPs_SetRootPath (const char *path)
\details
The function \b netTFTPs_SetRootPath sets the path to the root directory of TFTP server if \c TFTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_TFTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime. Root directory specifies a path on a storage device, where the user files are stored.

The argument \a path is a pointer to the new root path to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a path to the root path of the TFTP server. The maximum length of the \a path string is 
limited to \token{79} characters. 

Possible \ref netStatus return values:
- \em netOK: Root path successfully set.
- \em netInvalidParameter: Invalid \a path parameter provided.
- \em netWrongState: TFTP server is running.
- \em netError: Root path not enabled in the configuration.

\note
When the function ends, the content of \a path becomes irrelevant and may be discarded. 

\b Code \b Example
\code
netTFTPs_Stop ();
netTFTPs_SetRootPath ("/Boot");
netTFTPs_Start ();
\endcode
*/

/**
@}
*/

/**
\addtogroup tftp_server_access
@{
*/

//  ==== TFTP Server Access Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTFTPs_AcceptClient (const NET_ADDR *addr)
\details
The function \b netTFTPs_AcceptClient checks if a connection from the remote client is allowed. This enables remote client
filtering to decide which clients are allowed to connect to the TFTP server.

The argument \a addr points to a buffer containing the IP address and port of the remote machine.

\note This function is optional. If missing, the library default function is used which accepts all remote clients. 

\b Code \b Example

The following example is available in the user code template file \b %TFTP_Server_Access.c. Customize it to the application's
needs.

\code
bool netTFTPs_AcceptClient (const NET_ADDR *addr) {
  if (addr->addr_type == NET_ADDR_IP4) {
    // IPv4 client
    if (addr->addr[0] == 192  &&
        addr->addr[1] == 168  &&
        addr->addr[2] == 0    &&
        addr->addr[3] == 1) {
      // Accept connection from client at 192.168.0.1
      return (true);
    }
  }
  else {
    // IPv6 client
    const uint8_t ip6_addr[NET_ADDR_IP6_LEN] = { 
                     0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
    if (memcmp (addr->addr, ip6_addr, NET_ADDR_IP6_LEN) == 0) {
      // Accept connection from client at [fe80::1c30:6cff:fea2:455e]
      return (true);
    }
  }
  // Deny connection.
  return (false);
}
\endcode
*/

/**
@}
*/

/**
\addtogroup tftp_server_fs_interface
@{
*/

//  ==== TFTP Server File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void *netTFTPs_fopen (const char *fname, const char *mode)
\details
The function \b netTFTPs_fopen opens a file for reading or writing on the server.

The argument \a fname specifies the name of the file to open.

The argument \a mode defines the type of access permitted for the file. It can have one of the following values:

|Mode|Description|
|----|-----------|
|"rb"|Opens the file for reading. If the file does not exist, then the function fails.|
|"wb"|Opens an empty file for writing if the file does not exist. If the file exists already, then the content is cleared.|

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netTFTPs_fclose (void *file)
\details
The function \b netTFTPs_fclose closes the file identified by the \a file stream pointer in the function argument.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTFTPs_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netTFTPs_fread reads \a len bytes from the file identified by the \a file stream pointer in the function
argument.

The argument \a buf is a pointer to the buffer where the function stores the read data.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Server_FS.c module.

\note The function must read \a len bytes. The TFTP server stops reading and closes the file if the return value
is less than \a len bytes. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTFTPs_fwrite (void *file, const uint8_t *buf, uint32_t len)
\details
The function \b netTFTPs_fwrite writes a block of data to the file identified by the \a file stream pointer.

The argument \a buf points to the buffer containing the data that is to be written to the file.

The argument \a len specifies the number of bytes to write to the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Server_FS.c module.

\note The TFTP server stops writing and closes the file if the return value is less than \a len bytes.
*/

/**
@}
*/


/**
\addtogroup tftpc_user_api
@{
*/

//  ==== TFTP Client User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPc_Put (const NET_ADDR *addr, const char *fname, const char *local_fname)
\details
The function \b netTFTPc_Put is used to transfer a file from the local system using the TFTP client to a remote TFTP server.
This causes the TFTP client to start a (UDP based) TFTP session by connecting to the TFTP server specified by the argument
\a addr. This points to the structure containing the IP address and port of the TFTP server. If the specified port is \token{0},
the client uses a standard TFTP server port \token{69} to connect to the server.

The argument \a fname points to the \token{null}-terminated name of the destination file on the TFTP server. If the
destination file is not specified (\a fname has a value of \token{NULL}), then the \a local_fname name will be used as the
destination file name.

The argument \a local_fname points to the \token{null}-terminated name of the source file on the local system.

Possible \ref netStatus return values:
- \em netOK: TFTP client started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: TFTP client is busy.
- \em netFileError: Local file not found.

\b Code \b Example
\code
const NET_ADDR4 addr = { NET_ADDR_IP4, 0, 192, 168, 0, 253 };
 
if (netTFTPc_Put ((NET_ADDR *)&addr, NULL, "my_file.c") == netOK) {
  printf("TFTP Client started.\n");
}
else {
  printf("TFTP Client not ready.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTFTPc_Get (const NET_ADDR *addr, const char *fname, const char *local_fname)
\details
The function \b netTFTPc_Get is used to transfer a file from a remote TFTP server to the local system. The TFTP client starts
a (UDP based) TFTP session by connecting to a TFTP server specified by the argument \a addr. This argument points to a
structure containing the IP address and port of the TFTP server. If the specified port is \token{0}, the client uses a standard
TFTP server port \token{69} to connect to the server. 

The argument \a fname points to the \token{null}-terminated name of the source file on the TFTP server.

The argument \a local_fname points to the \token{null}-terminated name of the destination file on the local system. If the
destination file is not specified (\a local_fname has a value of \token{NULL}), then the \a fname will be used as the
destination file name.

Possible \ref netStatus return values:
- \em netOK: TFTP client started successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: TFTP client is busy.
- \em netFileError: Local file open failed.

\b Code \b Example
\code
const NET_ADDR4 addr = { NET_ADDR_IP4, 0, 192, 168, 0, 253 };
 
if (netTFTPc_Get ((NET_ADDR *)&addr, "my_file.c", NULL) == netOK) {
  printf("TFTP Client started.\n");
}
else {
  printf("TFTP Client not ready.\n");
}
\endcode
*/

/**
@}
*/


/**
\addtogroup tftpc_operation
@{
*/

//  ==== TFTP Client User Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netTFTPc_Notify (netTFTPc_Event event)
\details
The callback function \b netTFTPc_Notify is called automatically when a TFTP event occurred and notifies the user application
about the success of a TFTP client operation.

The argument \a event is a \ref netTFTPc_Event signal:

|Event                  |Description                                                                            |
|-----------------------|---------------------------------------------------------------------------------------|
|\token{netTFTPc_EventSuccess}      |The file has been successfully transferred                                             |
|\token{netTFTPc_EventTimeout}      |TFTP Server response has timed out, and hence the TFTP client has aborted the operation|
|\token{netTFTPc_EventAccessDenied} |File access on TFTP server is not allowed for a specified file                         |
|\token{netTFTPc_EventFileNotFound} |The TFTP server was not able to find the specified file                                |
|\token{netTFTPc_EventDiskFull}     |The TFTP server has run out of disk space, file transfer is not possible               |
|\token{netTFTPc_EventLocalFileError}| Local file read/write error                                                          |
|\token{netTFTPc_EventError}        |The TFTP client has encountered an error during file transfer process                  |

\b Code \b Example

The following skeleton is available in the user code template file \b %TFTP_Client_UIF.c. Customize it to the application's
needs.

\code
void netTFTPc_Notify (netTFTPc_Event event) {
  switch (event) {
    case netTFTPc_EventSuccess:
      // File operation successful
      break;
 
    case netTFTPc_EventTimeout:
      // Timeout on file operation
      break;
 
    case netTFTPc_EventAccessDenied:
      // File access not allowed
      break;
 
    case netTFTPc_EventFileNotFound:
      // File not found
      break;
 
    case netTFTPc_EventDiskFull:
      // Disk full
      break;
 
    case netTFTPc_EventLocalFileError:
      // Local file write error
      break;
 
    case netTFTPc_EventError:
      // Generic TFTP client error
      break;
  }
}\endcode
*/

/**
@}
*/


/**
\addtogroup tftpc_fs_interface
@{
*/

//  ==== TFTP Client File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void *netTFTPc_fopen (const char *fname, const char *mode)
\details
The function \b netTFTPc_fopen opens a local file for reading or writing.

The argument \a mode defines the type of access permitted for the file \a fname. \a mode can have one of the following
values:

|Mode|Description|
|----|-----------|
|"rb"|Opens the file for reading. If the file does not exist, the function fails.|
|"wb"|Opens an empty file for writing. If the file exists already, then the content is cleared.|

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netTFTPc_fclose (void *file)
\details
The function \b netTFTPc_fclose closes the file identified by the \a file stream pointer in the function argument.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTFTPc_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netTFTPc_fread reads \a len bytes from the file identified by the \a file stream pointer in the function
argument.

The argument \a buf is a pointer to the buffer where the function stores the read data.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Client_FS.c module.

\note
The  function should read \a len bytes. The TFTP client stops reading and closes the TFTP session, if the return value is
less than \a len bytes.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTFTPc_fwrite (void *file, const uint8_t *buf, uint32_t len)
\details
The function \b netTFTPc_fwrite writes a block of data to the file identified by the \a file stream pointer.

The argument \a buf points to the buffer containing the data to write to the file.

The argument \a len specifies the number of bytes to write to the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %TFTP_Client_FS.c module.

\note
The function must write \a len bytes. The TFTP client stops writing, aborts data transfer, and closes the TFTP session if
the return value is less than \a len bytes.
*/

/**
@}
*/


//  ==== Telnet Server service ===
/**
\addtogroup telnet_user_api
@{
*/

//  ==== Telnet Server User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_Start (void)
\details
The function \b netTELNETs_Start starts the Telnet server at runtime. It can be stopped again using \ref netTELNETs_Stop.

Possible \ref netStatus return values:
- \em netOK: Telnet server started successfully.

\note
  If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the Telnet server previously using
  \ref netTELNETs_Stop or have set \c NET_START_SERVICE to \token{0}.

\b Code \b Example (see \ref netTELNETs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_Stop (void)
\details
The function \b netTELNETs_Stop stops the Telnet server at runtime. It can be restarted using \ref netTELNETs_Start.

Possible \ref netStatus return values:
- \em netOK: Telnet server stopped successfully.

\b Code \b Example (see \ref netTELNETs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTELNETs_Running (void)
\details
The function \b netTELNETs_Running checks whether the Telnet server is running. It returns \token{true} if the server is up
and running.

\b Code \b Example (see \ref netTELNETs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netTELNETs_GetPort (void)
\details
The function \b netTELNETs_GetPort returns the port that is used for the Telnet server.

\b Code \b Example
\code
printf ("Telnet server is listening on port %d\n", netTELNETs_GetPort ());
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_SetPort (uint16_t port)
\details
The function \b netTELNETs_SetPort sets the \a port that is to be used for the Telnet server. The Telnet server must not run
while setting the port. If required, stop it first using \ref netTELNETs_Stop.

The argument \a port specifies the port number to be used.

Possible \ref netStatus return values:
- \em netOK: Port successfully set.
- \em netWrongState: Telnet server is running.

\b Code \b Example
\code
void change_server_port (uint16_t port) {
  if (netTELNETs_Running () == true) {
    netTELNETs_Stop ();
  }
  netTELNETs_SetPort (port);
  netTELNETs_Start ();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netTELNETs_GetUsername (void)
\details
The function \b netTELNETs_GetUsername returns the user name of the built-in user if \c TELNET_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_Telnet_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example (see \ref netTELNETs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_SetUsername (const char *username)
\details
The function \b netTELNETs_SetUsername sets the user name of the built-in user if \c TELNET_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_Telnet_Server.h file. If this define is set to \token{0}, the function is not available at
runtime.

The argument \a username is a pointer to the user name to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a username to the user name of the built-in user. The maximum length of the \a username string is 
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Username successfully set.
- \em netInvalidParameter: Invalid \a username provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a username becomes irrelevant and may be discarded. 

\b Code \b Example
\code
if (netTELNETs_LoginActive() == true) {
  netTELNETs_SetUsername ("sysadmin");
  netTELNETs_SetPassword ("a$Min#77");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netTELNETs_GetPassword (void)
\details
The function \b netTELNETs_GetPassword returns the password of the built-in user if \c TELNET_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_Telnet_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example (see \ref netTELNETs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_SetPassword (const char *password)
\details
The function \b netTELNETs_SetPassword sets the password of the built-in user if \c TELNET_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_Telnet_Server.h file. If this define is set to \token{0}, the function is not available at
runtime.

The argument \a password is a pointer to the password that is to be set, which is a \token{null}-terminated string. The function
copies the content of the \a password to the password of the build-in user. The maximum length of the \a password string is 
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Password successfully set.
- \em netInvalidParameter: Invalid \a password provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a password becomes irrelevant and may be discarded. 

\b Code \b Example (see \ref netTELNETs_SetUsername)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTELNETs_LoginActive (void)
\details
The function \b netTELNETs_LoginActive checks if the Telnet server is set up for user authentication. 

\b Code \b Example
\code
if (netTELNETs_LoginActive() == true) {
  printf ("Authentication is enabled\n");
  printf ("Username is: %s\n", netTELNETs_GetUsername());
  printf ("Password is: %s\n", netTELNETs_GetPassword());
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_LoginOnOff (bool login)
\details
The function \b netTELNETs_LoginOnOff enables or disables the user authentication on the Telnet server. If
\c TELNET_SERVER_AUTH_ENABLE is set to \token{0} in the \b Net_Config_Telnet_Server.h file, the function is not available at
runtime. 

The argument \a login switches the log-in on (\token{true}) or off (\token{false}).

Possible \ref netStatus return values:
- \em netOK: Login enabled or disabled successfully.
- \em netError: Authentication not enabled in the configuration.

\b Code \b Example
\code
if (netTELNETs_LoginActive () == true) {
  netTELNETs_LoginOnOff (false);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_GetClient (NET_ADDR *addr, uint32_t addr_len)
\details
The function \b netTELNETs_GetClient provides information about the remote machine that has connected to the Telnet server.

The argument \a addr points to a structure that will receive the IP address and port of the remote machine.

The argument \a addr_len specifies the length of the \a addr structure. Using IPv4 only, you can optimize memory usage
by specifying an \a addr_len that is equal to the size of NET_ADDR4 (8 bytes). The Telnet server checks the \a addr_len
argument, whether it can enter the IP address of the client into the structure. 

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Server session not active.

\note
Use this function to restrict machines from performing system changes.

\b Code \b Example
\code
NET_ADDR client;
char ip_ascii[40];
 ..
netTELNETs_GetClient (&client, sizeof(client));
netIP_ntoa (client.addr_type, client.addr, ip_ascii, sizeof(ip_ascii));
printf ("IP address: %s\n", ip_ascii);
printf ("TCP port:   %d\n", client.port);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t netTELNETs_GetSession (void)
\details
The function \b netTELNETs_GetSession retrieves the current session number of the Telnet server for further usage. The session
number can be used, when multiple Telnet clients are connected at the same time.

\b Code \b Example
\code
uint32_t netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len) {
  uint32_t len = 0;
 
  switch (msg) {
     ..
    case netTELNETs_MessagePrompt:
      // Prompt message (with user id)
      len = sprintf (buf, "\r\n"
                          "User%d> ", netTELNETs_GetSession());
      break;
     ..
  }
  return (len);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTELNETs_CheckCommand (const char *cmd, const char *user_cmd)
\details
The function \b netTELNETs_CheckCommand compares the command in the buffer \a cmd with the string \a user_cmd.

The argument \a cmd is \token{null}-terminated or \token{space}-separated command line string from the client.

The argument \a user_cmd is a user command to compare with, which is a \token{null}-terminated string in upper case.

\b Code \b Example (see \ref netTELNETs_ProcessCommand)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_RepeatCommand (uint32_t delay)
\details
The function \b netTELNETs_RepeatCommand ensures that the Telnet server does not call the \ref netTELNETs_ProcessCommand
function until a certain time period expires. When a timeout expires, the Telnet server calls \b netTELNETs_ProcessCommand 
function again, with the same content of \a cmd argument. This continuously updates information on the client screen. The 
end-less calling of \b netTELNET_ProcessCommand is terminated, when a user presses any key in the Telnet client.

The argument \a delay specifies the time period to wait, in number of timer ticks.

Possible \ref netStatus return values:
- \em netOK: Repeat command requested successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Server is not updating the client screen.

\b Code \b Example
\code
uint32_t netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar) {
  static uint32_t timer;
  uint32_t len = 0;
 
  switch (*pvar) {
    case 0:
      // New command received
      if (netTELNETs_CheckCommand (cmd, "TIMER") == true) {
        // TIMER command given
        *pvar = 1;
        timer = 0;
        len   = sprintf (buf, CLS);
        return (len | (1u << 31));
      }
       ..
      break;
 
    case 1:
      // Command TIMER, repeated call
      len = sprintf (buf, "Timer = %d", ++timer);
      // Repeat a command after 10 ticks (1 second)
      netTELNETs_RepeatCommand (10);
      // Set request for another callback
      return (len | (1u << 31));
  }
  return (len);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netTELNETs_RequestMessage (int32_t session)
\details
The function \b netTELNETs_RequestMessage is used to pass unsolicited messages to the Telnet server. It needs to be called by
the user application when unsolicited message is ready. The content of unsolicited message is passed to the Telnet server in the
\ref netTELNETs_ProcessMessage function.

The Telnet session handle parameter \a session identifies the remote host when many Telnet connections are active at the same
time.

Possible \ref netStatus return values:
- \em netOK: Unsolicited message requested successfully.
- \em netInvalidParameter: Invalid \a session provided.
- \em netWrongState: Server session not active.

\b Code \b Example
\code
if (netTELNETs_RequestMessage (1) == netOK) {
  // Request accepted, wait for callback
}
\endcode
*/

/**
@}
*/


/**
\addtogroup telnet_user_notification
@{
*/

//  ==== Telnet Server User Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar)
\details
The callback function \b netTELNETs_ProcessCommand processes and executes the command requested by the Telnet client. The
Network Component's Telnet server calls the function when it receives the consecutive Carriage Return (CR) and Line Feed (LF)
character sequence from the Telnet client (this is usually produced by the user pressing Enter on the Telnet client
terminal).

The argument \a cmd points to the message containing the command that is received from the Telnet client.

The argument \a buf points to the output buffer where the \b netTELNETs_ProcessCommand must write the message to be returned to the
Telnet client.

The argument \a buf_len specifies the length of the output buffer in bytes.

The argument \a pvar is a pointer to a local session buffer with a length of 4 bytes. The Telnet Server clears the data in
the \a pvar pointer to \token{0} before the function is called for the first time in each session, and never changes it later.
You can use \a *pvar as a repeat counter or simply to distinguish between different function calls.

\note The Telnet server does not automatically expand the CR character. The function must write the CR and LF
  characters into the buffer to indicate the end of each message.

\b Code \b Example

The following example is available in the user code template file \b %Telnet_Server_UIF.c. Customize it to the application's
needs.

\code
uint32_t netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar) {
  uint32_t len = 0;
  ..
  if (netTELNETs_CheckCommand (cmd, "LED0=ON") == true) {
    // Switch ON LED0
    len = sprintf (buf," Ok");
    return (len);
  }
  if (netTELNETs_CheckCommand (cmd, "LED0=OFF") == true) {
    // Switch OFF LED0
    len = sprintf (buf," Ok");
    return (len);
  }
  ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len)
\details
The callback function \b netTELNETs_ProcessMessage provides the connection and login messages to the Telnet server, when
requested. The Telnet server sends these messages to the Telnet client.

The argument \a msg specifies the type of message that the Telnet server requires:
|Message                               |Description|
|--------------------------------------|-----------|
|\token{netTELNETs_MessageWelcome}     | Initial welcome message                                      |
|\token{netTELNETs_MessageLogin}       | Login message, if authentication is enabled                  |
|\token{netTELNETs_MessageUsername}    | Username request login message                               |
|\token{netTELNETs_MessagePassword}    | Password request login message                               |
|\token{netTELNETs_MessageLoginFailed} | Incorrect login error message                                |
|\token{netTELNETs_MessageLoginTimeout}| Login timeout error message                                  |
|\token{netTELNETs_MessagePrompt}      | Prompt message                                               |
|\token{netTELNETs_MessageUnsolicited} | Unsolicited message (triggered by \ref netTELNETs_RequestMessage) |

The argument \a buf points to the output buffer where the \b netTELNETs_ProcessMessage must write the message.

The argument \a buf_len specifies the length of the output buffer in bytes.

\note
- The length of the output buffer (\a buf_len), might vary because buffer length is determined by the TCP socket Maximum
  Segment Size (MSS) negotiation. It is normally around 1400 bytes for local LAN. But this can be reduced to 500 bytes or
  even less.
- If the \b netTELNETs_ProcessMessage function writes more bytes than \a buf_len into the output buffer, then a system crash
  resulting from corruption of memory link pointers is highly likely.
- The Telnet server does not automatically expand the carriage return (CR) character. The \b netTELNETs_ProcessMessage
  function must write the carriage return and line feed (LF) characters into the buffer to indicate the end of each message.

\b Code \b Example

The following example is available in the user code template file \b %Telnet_Server_UIF.c. Customize it to the application's
needs.

\code
uint32_t netTELNETs_ProcessMessage (netTELNETs_Message msg, char *buf, uint32_t buf_len) {
  uint32_t len = 0;
 
  switch (msg) {
    case netTELNETs_MessageWelcome:
      // Initial welcome message
      len = sprintf (buf, "\r\n"
                          "Embedded Telnet Server\r\n");
      break;
 
    case netTELNETs_MessagePrompt:
      // Prompt message
      len = sprintf (buf, "\r\n"
                          "Cmd> ");
      break;
 
    case netTELNETs_MessageLogin:
      // Login message, if authentication is enabled
      len = sprintf (buf, "\r\n"
                          "Please login...");
      break;
 
    case netTELNETs_MessageUsername:
      // Username request login message
      len = sprintf (buf, "\r\n"
                          "Username: ");
      break;
 
    case netTELNETs_MessagePassword:
      // Password request login message
      len = sprintf (buf, "\r\n"
                          "Password: ");
      break;
 
    case netTELNETs_MessageLoginFailed:
      // Incorrect login error message
      len = sprintf (buf, "\r\n"
                          "Login incorrect");
      break;
 
    case netTELNETs_MessageLoginTimeout:
      // Login timeout error message
      len = sprintf (buf, "\r\n"
                          "Login timeout\r\n");
      break;
 
    case netTELNETs_MessageUnsolicited:
      // Unsolicited message (ie. from basic interpreter)
      len = sprintf (buf, "\r\n"
                          "Unsolicited message\r\n");
      break;
  }
  return (len);
}
\endcode
*/

/**
@}
*/


/**
\addtogroup telnet_access_filter_mui
@{
*/

//  ==== Telnet Server Access Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTELNETs_AcceptClient (const NET_ADDR *addr)
\details
The function \b netTELNETs_AcceptClient checks if a connection from the remote client is allowed. This allows remote client
filtering. You can selectively decide which clients are allowed to connect to the Telnet server.

The argument \a addr points to a buffer containing the IP address and port of the remote client.

\note This function is optional. If missing, the library default function is used which accepts all remote clients.

\b Code \b Example

The following example is available in the user code template file \b %Telnet_Server_Access.c. Customize it to the
application's needs.

\code
bool netTELNETs_AcceptClient (const NET_ADDR *addr) {
  if (addr->addr_type == NET_ADDR_IP4) {
    // IPv4 client
    if (addr->addr[0] == 192  &&
        addr->addr[1] == 168  &&
        addr->addr[2] == 0    &&
        addr->addr[3] == 1) {
      // Accept connection from client at 192.168.0.1
      return (true);
    }
  }
  else {
    // IPv6 client
    const uint8_t ip6_addr[NET_ADDR_IP6_LEN] = { 
                     0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
    if (memcmp (addr->addr, ip6_addr, NET_ADDR_IP6_LEN) == 0) {
      // Accept connection from client at [fe80::1c30:6cff:fea2:455e]
      return (true);
    }
  }
  // Deny connection.
  return (false);
}
\endcode
*/

//  ==== Telnet Server Multi-User Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netTELNETs_CheckUsername (const char *username)
\details
The function \b netTELNETs_CheckUsername authenticates the user name and returns the user identification number. A value of
\token{0} is returned if the user does not exist.

The argument \a username points to a \token{null}-terminated string representing the user name that must be checked.

\note This function is optional and only needed for multi-user authentication.

\b Code \b Example

The following example is available in the user code template file \b %Telnet_Server_Multiuser.c. Customize it to the
application's needs.

\code
uint8_t netTELNETs_CheckUsername (const char *username) {
  if (strcmp (username, "guest") == 0) {
    // Username is correct, return user_id
    return (1);
  }
  return (0);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netTELNETs_CheckPassword (uint8_t user_id, const char *password)
\details
The function \b netTELNETs_CheckPassword authenticates the password for a specified user ID on the server.

The argument \a user_id is the identification number of a user.

The argument \a password points to a \token{null}-terminated string representing the password that gets checked.

\note This function is optional and only needed for multi-user authentication.

\b Code \b Example

The following example is available in the user code template file \b %Telnet_Server_Multiuser.c. Customize it to the
application's needs.

\code
bool netTELNETs_CheckPassword (uint8_t user_id, const char *password) {
  if (user_id == 1) {
    if (strcmp (password, "guest") == 0) {
      // Password is correct
      return (true);
    }
  }
  return (false);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netTELNETs_GetUserId (void)
\details
The function \b netTELNETs_GetUserId retrieves the user identification number when the Telnet console is protected with user
authentication. It can be used to disable certain commands for unprivileged users. 

\note This function returns a value of 0 for the system administrator account. 

\b Code \b Example
\code
uint32_t netTELNETs_ProcessCommand (const char *cmd, char *buf, uint32_t buf_len, uint32_t *pvar) {
  uint32_t len = 0;
  ..
  if (netTELNETs_CheckCommand (cmd, "PASSW") == true) { 
    // Change the system password
    if (netTELNETs_GetUserId () == 0) && (strlen (cmd) >= 7)) {
      // Only administrator can change the password
      netTELNETs_SetPassword (&cmd[7]);
      len = sprintf (buf,"Password changed");
      return (len);
    }
  }
  ..
}
\endcode
*/

/**
@}
*/


//  ==== HTTP server service ===

/**
\addtogroup ws_user_api
@{
*/

//  ==== HTTP Server User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_Start (void)
\details
The function \b netHTTPs_Start starts the HTTP server at runtime. It can be stopped using \ref netHTTPs_Stop.

Possible \ref netStatus return values:
- \em netOK: HTTP server started successfully.

\note
  If you set the \c NET_START_SERVICE to \token{1} in \b Net_Config.h, all selected services will be started automatically.
  Thus, you only need to call this function, if you have either stopped the HTTP server previously using
  \ref netHTTPs_Stop or have set \c NET_START_SERVICE to \token{0}.

\b Code \b Example (see \ref netHTTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_Stop (void)
\details
The function \b netHTTPs_Stop stops the HTPP server at runtime. It can be restarted using \ref netHTTPs_Start.

Possible \ref netStatus return values:
- \em netOK: HTTP server stopped successfully.

\b Code \b Example (see \ref netHTTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netHTTPs_Running (void)
\details
The function \b netHTTPs_Running checks whether the HTTP server is running. It returns \token{true} if the server is up and
running.

\b Code \b Example (see \ref netHTTPs_SetPort)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t netHTTPs_GetPort (void)
\details
The function \b netHTTPs_GetPort returns the port that is used for the HTTP server.

\b Code \b Example
\code
printf ("HTTP server is listening on port %d\n", netHTTPs_GetPort ());
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_SetPort (uint16_t port)
\details
The function \b netHTTPs_SetPort sets the \a port that is to be used for the HTTP server. The HTTP server must not run
while setting the port. If required, stop it first using \ref netHTTPs_Stop.

The argument \a port specifies the port number to be used.

Possible \ref netStatus return values:
- \em netOK: Port successfully set.
- \em netWrongState: HTTP server is running.

\b Code \b Example
\code
void change_server_port (uint16_t port) {}
  if (netHTTPs_Running() == true) {
    netHTTPs_Stop();
  }
  netHTTPs_SetPort (port);
  netHTTPs_Start();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netHTTPs_GetRootPath (void)
\details
The function \b netHTTPs_GetRootPath returns the path to the current root directory if \c HTTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example
\code
if (netHTTPs_GetRootPath() != NULL) {
  printf ("Web recources are stored here: %s\n", netHTTPs_GetRootPath ());
}
\endcode
*/
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_SetRootPath (const char *path)
\details
The function \b netHTTPs_SetRootPath sets the path to the root directory of HTTP server if \c HTTP_SERVER_ROOT_ENABLE is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime. Root directory specifies a path on a storage device, where the WEB recources are stored.

The argument \a path is a pointer to the new root path to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a path to the root path of the HTTP server. The maximum length of the \a path string is 
limited to \token{79} characters. 

Possible \ref netStatus return values:
- \em netOK: Root path successfully set.
- \em netInvalidParameter: Invalid \a path parameter provided.
- \em netWrongState: HTTP server is running.
- \em netError: Root path not enabled in the configuration.

\note
When the function ends, the content of \a path becomes irrelevant and may be discarded. 

\b Code \b Example
\code
netHTTPs_Stop ();
netHTTPs_SetRootPath ("/Web/Update");
netHTTPs_Start ();
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netHTTPs_GetUsername (void)
\details
The function \b netHTTPs_GetUsername returns the user name of the built-in user if \c HTTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example (see \ref netHTTPs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_SetUsername (const char *username)
\details
The function \b netHTTPs_SetUsername sets the user name of the built-in user if \c HTTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime.

The argument \a username is a pointer to the user name to be set, which is a \token{null}-terminated string. The function 
copies the content of the \a username to the user name of the built-in user. The maximum length of the \a username string is 
limited to \token{15} characters.

Possible \ref netStatus return values:
- \em netOK: Username successfully set.
- \em netInvalidParameter: Invalid \a username provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a username becomes irrelevant and may be discarded. 

\b Code \b Example
\code
if (netHTTPs_LoginActive() == true) {
  netHTTPs_SetUsername ("sysadmin");
  netHTTPs_SetPassword ("a$Min#77");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netHTTPs_GetPassword (void)
\details
The function \b netHTTPs_GetPassword returns the password of the built-in user if \c HTTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime and returns \token{NULL}.

\b Code \b Example (see \ref netHTTPs_LoginActive)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_SetPassword (const char *password)
\details
The function \b netHTTPs_SetPassword sets the password of the built-in user if \c HTTP_SERVER_AUTH_ADMIN is set to
\token{1} in the \b Net_Config_HTTP_Server.h file. If this define is set to \token{0}, the function is not available at
runtime.

The argument \a password is a pointer to the password that is to be set, which is a \token{null}-terminated string. The function
copies the content of the \a password to the password of the build-in user. The maximum length of the \a password string is 
limited to \token{15} characters.

If the authentication type is \b Digest, the argument \a password can be either a plain text password or a pre-calculated
HA1 hash value. The \a password for HA1 should be \token{32} bytes, lowercase hexadecimal. (see \ref netHTTPs_GetUserSecret)

Possible \ref netStatus return values:
- \em netOK: Password successfully set.
- \em netInvalidParameter: Invalid \a password provided.
- \em netError: Administrator account not enabled in the configuration.

\note
When the function ends, the content of \a password becomes irrelevant and may be discarded. 

\b Code \b Example (see \ref netHTTPs_SetUsername)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netHTTPs_LoginActive (void)
\details
The function \b netHTTPs_LoginActive checks if the HTTP server is accepting log-in data. 

\b Code \b Example
\code
if (netHTTPs_LoginActive() == true) {
  printf ("Authentication is enabled\n");
  printf ("Username is: %s\n", netHTTPs_GetUsername());
  printf ("Password is: %s\n", netHTTPs_GetPassword());
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_LoginOnOff (bool login)
\details
The function \b netHTTPs_LoginOnOff enables or disables the user authentication on the HTTP server. If
\c HTTP_SERVER_AUTH_ENABLE is set to \token{0} in the \b Net_Config_HTTP_Server.h file, the function is not available at
runtime. 

The argument \a login switches the log-in on (\token{true}) or off (\token{false}).

Possible \ref netStatus return values:
- \em netOK: Login enabled or disabled successfully.
- \em netError: Authentication not enabled in the configuration.

\b Code \b Example
\code
if (netHTTPs_LoginActive () == true) {
  netHTTPs_LoginOnOff (false);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_GetClient (NET_ADDR *addr, uint32_t addr_len)
\details
The function \b netHTTPs_GetClient obtains information about the remote machine that has connected to the HTTP server.

The argument \a addr points to a structure that will receive the IP address and port of the remote machine.

The argument \a addr_len specifies the length of the \a addr structure. Using IPv4 only, you can optimize memory usage
by specifying an \a addr_len that is equal to the size of NET_ADDR4 (8 bytes). The HTTP server checks the \a addr_len
argument, whether it can enter the IP address of the client into the structure. 

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: Server session not active.

\note
Use this function to restrict machines from performing system changes.

\b Code \b Example
\code
NET_ADDR client;
char ip_ascii[40];
 ..
netHTTPs_GetClient (&client, sizeof(client));
netIP_ntoa (client.addr_type, client.addr, ip_ascii, sizeof(ip_ascii));
printf ("IP address: %s\n", ip_ascii);
printf ("TCP port:   %d\n", client.port);
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t netHTTPs_GetSession (void)
\details
The function \b netHTTPs_GetSession returns the current session number of the HTTP server running on the Network
Component. The session number can be any value between 0 and \c HTTP_SERVER_NUM_SESSIONS, defined in
\b Net_Config_HTTP_Server.h.

\note Storing the HTTP query string in a single global variable can result in the HTTP server sending the wrong reply to a
client when several clients try to access a dynamic HTTP page at the same time. Hence, it is better to have a separate
variable for each session, for example an array of query strings.

\b Code \b Example
\code
// Should be the same value as set in 'Net_Config_HTTP_Server.h' file. 
#define HTTP_SERVER_NUM_SESSIONS 10
 
int32_t answer[HTTP_SERVER_NUM_SESSIONS];
 
uint32_t netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi) {
  uint32_t len = 0;
  int32_t http_session;
  ..
  http_session = netHTTPs_GetSession ();
  len += sprintf (buf+len,"Answer is: %d",answer[http_session]);
   ..
  return (len);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netHTTPs_GetLanguage (void)
\details
The function \b netHTTPs_GetLanguage retrieves the preferred language setting from the browser. You can use this information
to implement automatic language selection for your embedded web pages.

When a web browser requests a web page, it specifies the preferred language in the HTTP header that is sent to the web server.
This information is processed by the Network Component and stored internally.

\note
You can set the language preference in Internet Explorer by selecting <b>Tools -> Internet Options -> Languages</b>. In
Mozilla Firefox, you can set the language preference by selecting <b>Options -> Options -> Content -> Languages</b>.

\b Code \b Example
\code
uint32_t netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi) {
  uint32_t len = 0;
  char *lang;
 
  switch (env[0]) {
     ..
    case 'e':
      // Browser Language - file 'language.cgi' 
      lang = netHTTPs_GetLanguage();
      if (strcmp (lang, "en") == 0) {
        lang = "English";
      }
      else if (strcmp (lang, "en-us") == 0) {
        lang = "English USA";
      }
      else if (strcmp (lang, "de") == 0) {
        lang = "German";
      }
      else if (strcmp (lang, "de-at") == 0) {
        lang = "German AT";
      }
      else if (strcmp (lang, "fr") == 0) {
        lang = "French";
      }
      else {
        lang = "Unknown";
      }
      len = sprintf (buf, &env[2], lang, netHTTPs_GetLanguage());
      break;
  }
  return (len);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netHTTPs_GetContentType (void)
\details
The function \b netHTTPs_GetContentType returns a pointer to the Content-Type HTML header, which was received with a
XML or any other type POST request. You can use this function to check for the content type, which was submitted by a
web service application.

When a web service application sends a request to a web server, it specifies the Content-Type in the HTTP header that
is sent to the web server. This information is processed by the Network Component and stored internally.

\b Code \b Example
\code
void netCGI_ProcessData (uint8_t code, const char *data, uint32_t len) {
  char var[40];
 
  switch (code) {
    ...
    case 4:
      // Other content type data, last packet
      // Example
      if (strcmp (netHTTPs_GetContentType(), "text/xml; charset=utf-8" == 0) {
        // Content type xml, utf-8 encoding
         ...
      }
      break;
 
    default:
      // Ignore all other codes
      break;
  }
}
\endcode
*/

/**
@}
*/


/**
\addtogroup ws_access_filtering_mui
@{
*/

//  ==== HTTP Server Access Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netHTTPs_AcceptClient (const NET_ADDR *addr)
\details
The function \b netHTTPs_AcceptClient checks if a connection from a remote client is allowed or not. This enables remote client
filtering. You can selectively decide which clients are allowed to connect to the web server.

The argument \a addr points to a buffer containing the IP address and port of the remote machine.

\note This function is optional. If missing, the library default function is used which accepts all remote clients.

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_Access.c. Customize it to the application's
needs.

\code
bool netHTTPs_AcceptClient (const NET_ADDR *addr) {
 
  if (addr->addr_type == NET_ADDR_IP4) {
    // IPv4 client
    if (addr->addr[0] == 192  &&
        addr->addr[1] == 168  &&
        addr->addr[2] == 0    &&
        addr->addr[3] == 1) {
      // Accept connection from client at 192.168.0.1
      return (true);
    }
  }
  else {
    // IPv6 client
    const uint8_t ip6_addr[NET_ADDR_IP6_LEN] = { 
                     0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                     0x1c, 0x30, 0x6c, 0xff, 0xfe, 0xa2, 0x45, 0x5e };
    if (memcmp (addr->addr, ip6_addr, NET_ADDR_IP6_LEN) == 0) {
      // Accept connection from client at [fe80::1c30:6cff:fea2:455e]
      return (true);
    }
  }
  // Deny connection.
  return (false);
}
\endcode
*/

//  ==== HTTP Server Multi-User Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netHTTPs_CheckAccount (const char *username, const char *password)
\details
The function \b netHTTPs_CheckAccount checks if an user account exist in the user database for the provided credentials. It
is called from the Network Component's HTTP server to check if the user with provided credentials is allowed to access the
web pages or not.

The argument \a username points to a \token{null}-terminated string representing the user name that was typed in from the
browser.

The argument \a password points to a \token{null}-terminated string representing the password. If the authentication type
is \b Digest, the \a password is an empty string. 

\note This function is optional. For single user HTTP authentication or when the HTTP authentication is disabled, this function
  is not required.

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_Multiuser.c. Customize it to the
application's needs.

\code
uint8_t netHTTPs_CheckAccount (const char *username, const char *password) {
 
  if ((strcmp (username, "guest") == 0) && (strcmp (password, "guest") == 0)) {
    // Accept guest account
    return (1);
  }
  return (0);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len);
\details
The function \b netHTTPs_GetUserSecret retrieves the user secret word from the user database for the provided user.
It is called from the HTTP server of the Network Component if \b Digest authentication is used.

The argument \a user_id is the identification number of a user.

The argument \a buf points to a buffer that will be used to store the value of the secret word.

The argument \a buf_len specifies the length of the buffer \a buf which is \token{33} bytes.

The \b UserSecret is either a plain text password or a MD5 hash value HA1. The length of the string that is returned
is used by the Network library to determine the type. The HA1 value should be \token{32} bytes, lowercase hexadecimal.
If the length is less than \token{32} bytes, the Network library treats the string as plain text password.

The HA1 hash is calculated as:
\code
HA1 = MD5(username:realm:password)
\endcode 

For \a username "guest", \a realm "Embedded WEB Server" and \a password "guest" the HA1 is:
\code
MD5("guest:Embedded WEB Server:guest") = "bd553df9efecf3af93c88843b0f54496"
\endcode 

\note This function is optional. For Basic HTTP authentication or when the HTTP authentication is disabled, this function
is not required.

\b Code \b Example \b clear-text

\code
void netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len) {
  if (user_id == 1) {
    /* Plain text password */
    strcpy (buf, "guest");
  }
}
\endcode

\b Code \b Example \b hash-value

\code
void netHTTPs_GetUserSecret (uint8_t user_id, char *buf, uint32_t buf_len) {
  if (user_id == 1) {
    /* Digest HA1 hash value */
    strcpy (buf, "bd553df9efecf3af93c88843b0f54496");
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netHTTPs_FileAccess (uint8_t user_id, const char *fname)
\details
The function \b netHTTPs_FileAccess checks if a file access is allowed for a specified user. This enables access protection
of sensitive web pages. Protected web pages will not be displayed for unprivileged users. Instead, the Web server shows
"Error Page 403 - Forbidden".

The argument \a user_id is an user identification number as returned by \ref netHTTPs_CheckAccount.
It identifies the user who is trying to access the specified file.

The argument \a fname points to a buffer containing the file name of a file, which the user is trying to access. The file
name is a \token{null}-terminated string.

\note This function is optional. If the HTTP resource access restriction is not used, this function is not required.

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_Multiuser.c. Customize it to the
application's needs.

\code
bool netHTTPs_FileAccess (uint8_t user_id, const char *fname) {
 
  if (user_id == 1) {
    if (strcmp (fname, "system.cgi") == 0) {
      // User "guest" is not allowed to see "system.cgi"
      return (false);
    }
  }
  return (true);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netHTTPs_CalcHashHA1 (const char *username, const char *password, char *buf, uint32_t buf_len);
\details
The function \b netHTTPs_CalcHashHA1 calculates the MD5 hash value HA1, which is representend as a hexadecimal string.
You can call the function if \b Digest authentication is used. Saving a password as HA1 hash adds additional
security to the application.

The argument \a username points to the user name, which is a \token{null}-terminated string.

The argument \a password points to the password, which is a \token{null}-terminated string.

The argument \a buf points to a buffer that will be used to store the value of HA1 hash.

The argument \a buf_len specifies the length of the buffer \a buf, which must be at least \token{33} bytes because the function
also adds a \token{null}-termination to the HA1 hash string.

The HA1 hash is calculated as:
\code
HA1 = MD5(username:realm:password)
\endcode 

The value for \a realm is from the \ref ws_configuration "Net_Config_HTTP_Server.h".

Possible \ref netStatus return values:
- \em netOK: HA1 hash calculated successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netError: Digest authentication not enabled in the configuration.

\b Code \b Example

\code
char buf[33];
 
if (netHTTPs_LoginActive() == true) {
  netHTTPs_SetUsername ("sysadmin");
  netHTTPs_CalcHashHA1 ("sysadmin", "a$Min#77", buf, sizeof(buf));
  netHTTPs_SetPassword (buf);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t netHTTPs_GetUserId (void)
\details
The function \b netHTTPs_GetUserId retrieves the user identification number when the web pages are protected with user
authentication. It can be used to generate a web page, whose content is based on the connected user. This function is
normally called from the netCGI_Script function.

\b netHTTPs_GetUserId is a system function that is in the Network Component library.

\note This function returns a value of 0 for system administrator account.

\b Code \b Example
\code
uint16_t netCGI_Script (const char *env, char *buf, uint16_t buf_len, uint32_t *pcgi) {
  uint8_t uid;
  ..
    case 'd':
      // System password - file 'system.cgi' 
      switch (env[2]) {
        case '0':
          // Display the user name on web page. 
          uid = netHTTPs_GetUserId ();
          len = sprintf((char *)buf,(const char *)&env[4],
                        (uid == 0) ? "admin" : users[uid-1]);
          break;
        case '1':
           ..
          break;
      }
      break;
   ..
}  
\endcode
*/

/**
@}
*/


/**
\addtogroup ws_fs_interface
@{
*/

//  ==== HTTP Server File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void *netHTTPs_fopen (const char *fname)
\details
The function \b netHTTPs_fopen opens a file for reading.

The argument \a fname specifies the name of the file to open. If the file does not exist, the function fails and
returns \token{NULL}. \a fname is percent-encoded. This means that all reserved characters in a file name are escaped. 

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %HTTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netHTTPs_fclose (void *file)
\details
The function \b netHTTPs_fclose closes the file identified by the \a file stream pointer in the function argument.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %HTTP_Server_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netHTTPs_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netHTTPs_fread reads \a len bytes from the file identified by the \a file stream pointer in the function
argument.

The argument \a buf is a pointer to the buffer where the function stores the read data.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %HTTP_Server_FS.c module.

\note The function must read \a len bytes. The Web Server stops reading and closes the file if the return value
is less than \a len bytes. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn char *netHTTPs_fgets (void *file, char *buf, uint32_t size)
\details
The function \b netHTTPs_fgets reads up to \a size bytes from the file identified by the \a file stream pointer in the
function argument.

The argument \a buf is a pointer to the buffer which stores the data.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %HTTP_Server_FS.c module.

\note The function is used by the \ref ws_script_langugage "script interpreter". 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netHTTPs_fstat (const char *fname, uint32_t *fsize, uint32_t *ftime)
\details
The function \b netHTTPs_fstat reads the size of a file and the time when the file was last modified.

The argument \a fname identifies the file for which the information is to be retrieved.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %HTTP_Server_FS.c module.
*/

/**
@}
*/


/**
\addtogroup ws_cgi_script
@{
*/

//  ==== HTTP Server CGI ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netCGI_ProcessQuery (const char *qstr)
\details
The function \b netCGI_ProcessQuery processes the environment variable QUERY_STRING returned by the method GET or by the method
POST of the \ref ws_script_langugage "CGI" form. The HTTP server calls this function when a user clicks the SUBMIT button on
the input form. The function is not called if no URL query string arguments are specified.

The argument \a qstr points to the QUERY_STRING that is encoded in the URL of the request. The query string is terminated by
a space character.

\note 
- The function is called by the HTTP server if the input form (HTML source) is created with the METHOD=GET attribute.
  For example:
  \code
  <FORM ACTION=index.htm METHOD=GET NAME=CGI>
  ..
  </FORM>
  \endcode
- The function is also called if the input form is created with the METHOD=POST attribute and a query string argument
  is specified in the form's ACTION.
  For example:
  \code
  <FORM ACTION=service.htm?cmd=frw METHOD=POST NAME=CGI>
  ..
  </FORM>
  \endcode

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_CGI.c. Customize it to the application's
needs.

\code
void netCGI_ProcessQuery (const char *qstr) {
  char var[40];
 
  do {
    // Loop through all the parameters
    qstr = netCGI_GetEnvVar (qstr, var, sizeof (var));
    // Check return string, 'qstr' now points to the next parameter
    if (var[0] != 0) {
      // First character is non-null, string exists
      // Example of a parameter "ip=fe80::1c30:6cff:fea2:455e"
      if (strncmp (var, "ip=", 3) == 0) {
        uint8_t ip_addr[NET_ADDR_IP6_LEN];
        // Read parameter IP address submitted by the browser
        netIP_aton (&var[3], NET_ADDR_IP6, ip_addr);
         ...
      }
    }
  } while (qstr);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netCGI_ProcessData (uint8_t code, const char *data, uint32_t len)
\details
The function \b netCGI_ProcessData processes the data returned from the POST method of the \ref ws_script_langugage "CGI"
form. The HTTP server calls this function when a user clicks the SUBMIT button of an input form.

The argument \a code can have the following types:

|Code|Data Type  |Meaning of *data   |Meaning of len   |
|----|-----------|-------------------|-----------------|
|0   |Form data  |Pointer to data string returned from the POST method                                                     |Length of data string |
|1   |Filename   |Pointer to a Filename for the HTTP file upload. Filename is a \token{null}-terminated string.            |Length of a filename  |
|2   |File data  |Pointer to data packet received from the host                                                            |Length of data packet |
|3   |End of file|\token{NULL}                                                                                             |Don't care            |  
|4   |Other data |Pointer to data string returned from the POST method. A single packet or last packet in data stream      |Length of data string |
|5   |Other data |Pointer to data string returned from the POST method. The same as under 4, but with more data to follow  |Length of data string |

The argument \a data point to the data that get processed.

The argument \a len is the data length in bytes.

\note
- The HTTP server calls the function only if the input form (HTML source) is created with the attribute METHOD=POST.
  For example:
  \code
  <FORM ACTION=index.htm METHOD=POST NAME=CGI>
  ..
  </FORM>
  \endcode
- Web browsers provide a filename for HTTP file upload with a path included. It is the user's responsibility to remove the
  path information from the filename.
- For large files, file data is received in several small packets. The size of data packet depends on the TCP Maximum Segment
  Size (MSS). This value is typically \token{1440} bytes.
- The XML-POST is generated from the web service application.

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_CGI.c. Customize it to the application's
needs.

\code
void netCGI_ProcessData (uint8_t code, const char *data, uint32_t len) {
  char var[40];
 
  switch (code) {
    case 0:
      // Url encoded form data received
      do {
        // Parse all parameters
        data = netCGI_GetEnvVar (data, var, sizeof (var));
        if (var[0] != 0) {
          // First character is non-null, string exists
          if (strcmp (var, "led0=on") == 0) {
            // ... Switch LED 0 on
          }
        }
      } while (data);
      break;
 
    case 1:
      // Filename for file upload received
      if (data[0] != 0) {
        // Open a file for writing
        file = fopen (var, "w");
      }
      break;
 
    case 2:
      // File content data received
      if (file != NULL) {
        // Write data to a file
        fwrite (data, 1, len, file);
      }
      break;
 
    case 3:
      // File upload finished
      if (file != NULL) {
        // Close a file
        fclose (file);
      }
      break;
 
    case 4:
      // Other content type data, last packet
      if (strcmp (netHTTPs_GetContentType(), "text/xml; charset=utf-8") == 0) {
        // Content type xml, utf-8 encoding
         ...
      }
      break;
 
    case 5:
      // Other content type data, more to follow
      // ... Process data
      break;
 
    default:
      // Ignore all other codes
      break;
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi)
\details
The function \b netCGI_Script is what the \ref ws_script_langugage "script interpreter" calls when interpreting the script to
output the dynamic part of the HTTP response. The script interpreter calls \b netCGI_Script for each line in the script that
begins with the command c. You must customize the \b netCGI_Script function so that it can understand and use the input
string from the script.

The argument \a env is a pointer to the input string to create the dynamic response. It is the same
string of bytes that is specified in the CGI script code using the c command.

The argument \a buf is a pointer to the output buffer where the \b netCGI_Script function must write the HTTP response.

The argument \a buf_len specifies the length of the output buffer in bytes.

The argument \a pcgi is a pointer to a variable that never gets altered by the HTTP Server. Hence, you can use it to store
parameters for successive calls of the \b netCGI_Script function. You might use this to store:
- loop counters
- number of sent bytes
- pointer to a local status buffer.

\note
- The contents written into the output buffer by the \b netCGI_Script function must be HTML code.
- \a c is a command that is available in the scripting language of the Network Component.
- The length of the output buffer (\a buf_len) might vary, because the length is determined by the TCP socket Maximum Segment
  Size (MSS) negotiation. The buffer length is normally around 1400 bytes for local LAN. But this can be reduced to 500 bytes
  or less. It also varies because the HTTP Server tries to optimize the number of generated TCP packets. It calls this
  function again to use the complete available buffer. It stops when there are only 240 or less bytes free in the buffer.
  This causes the packet to be generated and transmitted. If you want to force the HTTP Server to transmit the packet, you
  need to \c or the return value from this function with 1U<<30.
- If \b netCGI_Script writes more bytes than \a buf_len into the output buffer, a system crash from a corruption of the
  memory link pointers is highly likely.
- The input string \a env might contain single-character subcommands to tell the \b netCGI_Script function how to process the
  script line correctly. There are no rules for these subcommands, so you can create and use your own commands.
- The argument \a pcgi is private to each HTTP Session. The HTTP Server clears the data in the pcgi pointer to 0, before
  \b netCGI_Script is called for the first time in each session.
- \b netCGI_Script must update the contents in \a pcgi for each call. You can use the 4 bytes in \a pcgi to store data in any
  format.

\b Code \b Example

The following example is available in the user code template file \b %HTTP_Server_CGI.c. Customize it to the application's
needs.

\code
uint32_t netCGI_Script (const char *env, char *buf, uint32_t buf_len, uint32_t *pcgi) {
  uint32_t len = 0;
 
  // Analyze a 'c' script line starting position 2
  // c a i <td><input type=text name=ip value="%s" size=40 maxlength=40></td>
 
  char ip_ascii[40];
 
  switch (env[0]) {
    case 'a' :
      switch (env[2]) {
        case 'i':
          // Write the local IP address
          netIP_ntoa (NET_ADDR_IP6, IpAddr, ip_ascii, sizeof(ip_ascii));
          len = sprintf (buf, &env[4], ip_ascii);
          break;
           ..
      }
      break;
  }
  return (len);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGI_GetEnvVar (const char *env, char *ansi, uint32_t max_len)
\details
The function \b netCGI_GetEnvVar processes the string \a env, which contains the environment variables, and identifies where
the first variable ends. The function obtains and stores the first variable and its value in the buffer pointed by \a ansi,
in ANSI format.

The argument \a max_len specifies the maximum length that can be stored in the \a ansi buffer. If the decoded environment
variable value is longer than this limit, then the function truncates it to \a max_len to fit it into the buffer.

\note
- The function can process environment variables from the GET and POST methods.
- You can call this function from the \b %HTTP_Server_CGI.c module.
- The web browser uses environment variables to return user-entered information that is requested in the HTTP input form.

\b Code \b Example (see \ref netCGI_ProcessQuery)
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGI_Charset (void)
\details
The function \b netCGI_Charset overrides the default character encoding in a web browser. If this function is implemented and
returns a non-\token{NULL} pointer, the web server adds a character encoding HTTP header. The browser then uses this information to
correctly decode the character set. 

If this function is not existing (or returns \token{NULL}), then the 'charset' parameter is not generated in web server's
response. The browser then uses the default character encoding. This might cause troubles in displaying web pages that are
encoded in different character sets. Example: an English user might not see the umlaut characters on German web pages.

The \b netCGI_Charset function is in the \b %HTTP_Server_CGI.c module. The prototype is defined in rl_net.h.

\note This function is optional.

\b Code \b Example
\code
const char *netCGI_Charset (void) {
  return ("utf-8");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGI_ContentType (const char *file_ext)
\details
The function \b netCGI_ContentType allows you to add new MIME types for the Content-Type HTTP header in the response to the web
service application requests. The function returns a pointer to the Content-Type HTTP header. You can use this function
to add new file types to the Network Component library.

The argument \a file_ext specifies the file extension of a requested file, which is not supported in Network Component library.

The default content type for unsupported file types is:
\code
Content-Type: application/octet-stream\r\n
\endcode
This header is used if the file type is not supported in Web server and \b netCGI_ContentType function does not exist in the project
or if it returns a \token{NULL} pointer.

The \b netCGI_ContentType function is in the \b %HTTP_Server_CGI.c module. The prototype is defined in rl_net.h.

\note This function is optional. If missing, or returning \token{NULL}, a default content type is used for unsupported file types.

\b Code \b Example
\code
const char *netCGI_ContentType (const char *file_ext) {
  // Example
  if (strcmp (file_ext, "wav") == 0) {
    return ("audio/wav");
  }
  return (NULL);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGI_CustomHeader (void)
\details
The function \b netCGI_CustomHeader allows you to add custom HTTP headers to web server response. If this function is implemented
and returns a non-\token{NULL} pointer, the web server adds custom HTTP headers. The function returns a pointer to one or more
custom HTTP headers. Each header must be terminated with the "\r\n".

With this function you can implement HTTP security headers to prevent web server vulnerabilities.

\note This function is optional. If missing, or returning \token{NULL}, no custom HTTP header is added.

\b Code \b Example
\code
const char *netCGI_CustomHeader (void) {
  return ("Strict-Transport-Security: max-age=31536000; includeSubDomains\r\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGI_Redirect (const char *file_name)
\details
The function \b netCGI_Redirect allows you to redirect URL address of a missing resource to a new location. The function returns
a pointer to the Location HTML header. Web server calls this function, if the requested resource is not found on the server.

When \b netCGI_Redirect function returns valid URL location, Web server returns <b>301 Moved Permanently</b> error code with 
HTML header containing a new location in the response to the web service application request.

The argument \a file_name specifies the full path name of a requested resource.

The \b netCGI_ContentType function is in the \b %HTTP_Server_CGI.c module. The prototype is defined in rl_net.h.

\note This function is optional. If missing, or returning \token{NULL}, server returns <b>404 Not Found</b> to the client
on file not found error.

\b Code \b Example
\code
const char *netCGI_Redirect (const char *file_name) {
  if (strcmp (file_name, "lxi/identification") == 0) {
    return ("/lxi_identification.cgx");
  }
  return (NULL);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netCGI_ProcessRequest (const char *method, const char *uri, const char *header, uint32_t header_len)
\details
The function \b netCGI_ProcessRequest allows you to access HTTP request parameters. The function is called when an HTTP
request is received and before the resource file is opened. You can use this function to extend the existing functionality
of the HTTP server with additional options. 

The argument \a method specifies the HTTP request method used in the request, such as: GET, POST, HEADER, and so on. The
\a method is a pointer to the \token{null}-terminated string.

The argument \a uri specifies the HTTP request path, which is a pointer to a \token{null}-terminated string. Arguments are
not included. The path is pre-processed and all percent encoded characters are already decoded before the function is called. 

The argument \a header is a pointer to HTTP headers contained in the request. 

The argument \a header_len specifies the length of the HTTP request headers.

\note This function is optional.

\b Code \b Example
\code
void netCGI_ProcessRequest (const char *method, const char *uri, const char *header, uint32_t header_len) {
  if (strcmp(method, "GET") == 0) {
    // GET method is used
  }
  if (strcmp(uri, "network.cgi") == 0) {
    // Name of resource requested
  }
  // Further process HTTP headers, terminated with "\r\n"
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netCGI_ProcessCookie (const char *method, const char *uri, const char *cookie, uint32_t cookie_len)
\details
The function \b netCGI_ProcessCookie allows you to access HTTP cookies received in an HTTP request. The function is called
when received an HTTP request and before opening the resource file. You can use this function to process session cookies
provided by a the WEB browser. 

The argument \a method specifies the HTTP request method used in the request, such as: GET, POST, HEADER, and so on. The
\a method is a pointer to the \token{null}-terminated string.

The argument \a uri specifies the HTTP request path, which is a pointer to a \token{null}-terminated string. Arguments are
not included. The path is pre-processed and all percent encoded characters are already decoded before the function is called. 

The argument \a cookie is a pointer to HTTP cookie header contained in the request. The cookie header may contain more
than one cookie. Cookies are separated by a semicolon.

The argument \a cookie_len specifies the length of the HTTP cookie header.

\note This function is optional.

\b Code \b Example
\code
void netCGI_ProcessCookie (const char *method, const char *uri, const char *cookie, uint32_t cookie_len) {
  if (strcmp(cookie, "sessionid=x4aPh6w35t") == 0) {
    // Cookie name:  sessionid
    // Cookie value: x4aPh6w35t
    cookie_valid = 1;
  }
  if (strcmp(uri, "network.cgi") == 0) {
    // Name of resource requested
  }
   ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netCGI_SetCookie (const char *cookie)
\details
The function \b netCGI_SetCookie sets the cookie that shall be returned to the client. The cookie is composed of the \b cookie_name
and \b cookie_value.

The argument \a cookie is a pointer to a cookie that needs to be set, which is a \token{null}-terminated string. The function
copies the contents of the \a cookie to the internal memory. If more than one cookie needs to be set, you can call the function
several times to set all the required cookies. 

You enable the processing of cookies by specifying the \ref netCGI_ProcessCookie function in the code. If the function is not
available, cookies are automatically disabled on the web server.

Possible \ref netStatus return values:
- \em netOK: Cookie successfully set.
- \em netInvalidParameter: Invalid \a cookie provided.
- \em netError: Cookies not enabled or no memory available for the cookie.
- \em netWrongState: Function called from an invalid context, not from a CGI callback function.

\note
When the function ends, the content of \a cookie becomes irrelevant and may be discarded. 

\b Code \b Example
\code
void netCGI_ProcessData (uint8_t code, const char *data, uint32_t len) {
  if (cookie_valid == 0)
    // The cookie not received from the browser, set it
    netCGI_SetCookie ("sessionid=x4aPh6w35t");
  }
   ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netCGX_ContentType (void)
\details
The function \b netCGX_ContentType allows you to change the Content-Type HTML header in the response to the web
service application requests. The function returns a pointer to the new Content-Type HTML header. You can use this function
to override the default content type header from the Network Component library. This content type header is used in cgx
script responses.

The default content type header in cgx script response is:
\code
Content-Type: text/xml\r\n
\endcode
This header is used if the \b netCGX_ContentType function does not exist in the project or if it returns a \token{NULL} pointer.

The \b netCGX_ContentType function is in the \b %HTTP_Server_CGI.c module. The prototype is defined in rl_net.h.

\note This function is optional. If missing, or returning \token{NULL}, a default "text/xml" content type is used.

\b Code \b Example
\code
const char *netCGX_ContentType (void) {
  return ("text/xml; charset=utf-8");
}
\endcode
*/

/**
@}
*/

/**
\addtogroup smtpc_user_api
@{
*/

//  ==== SMTP Client User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSMTPc_Connect (const NET_ADDR *addr)
\details
The function \b netSMTPc_Connect starts the SMTP client. The SMTP client then connects to an SMTP server specified with the
argument \a addr which points to a buffer containing the IP address and port of the SMTP server. If the specified port is \token{0},
the client uses a standard SMTP server port \token{25} to connect to the server.

Possible \ref netStatus return values:
- \em netOK: Mail client started successfully.
- \em netInvalidParameter: Invalid SMTP server address provided.
- \em netWrongState: Mail client is busy.

\note The function \b netSMTPc_Connect is deprecated, use the \ref netSMTPc_SendMail function instead.

\b Code \b Example
\code
const NET_ADDR4 smtp_server = { NET_ADDR_IP4, 0, 192, 168, 0, 253 };
 ..
// Start SMTP client, use default SMTP port
if (netSMTPc_Connect ((NET_ADDR *)&smtp_server) != netOK) {
  // Failed to start SMTP process
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSMTPc_SendMail (const NET_SMTP_MAIL *mail, const NET_SMTP_MTA *mta)
\details
The function \b netSMTPc_SendMail sends an email in blocking mode. The function blocks the calling thread and returns,
when an email is sent. The function resolves server IP address from the host name, connects to the server and sends an email.

The argument \a mail points to a structure that contains a description of an email to send. All entries in a structure are
pointers to \token{null}-terminated strings. When more parameters are specified (for example several \em To addresses), use 
a semicolon ';' character as a parameter separator. 

The argument \a mta points to a structure with mail transfer agent parameters. This structure contains SMTP server address,
port number, flags and user credentials for authentication. Server address can be either a fully qualified domain name or 
an IP address presented in string format.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid or not supported parameter provided.
- \em netWrongState: Mail client is busy.
- \em netDnsResolverError: DNS host resolver failed.
- \em netServerError: Mail server failed.
- \em netAuthenticationFailed: User credentials are not valid.
- \em netFileError: Requested mail attachment is not existing.
- \em netError: Mail client internal error.

\note To use this function, you must enable the \ref netDNSc_Func "DNS client" in the selection of RTE Components.

\b Code \b Example (multiple recipients and friendly names)
\code
NET_SMTP_MAIL mail;
NET_SMTP_MTA  server;
char buffer[200];
 ..
mail.From       = "John <john@example.net>";
mail.To         = "Mary <mary@example.net>; Joe <joe@example.net>"; 
mail.Cc         = "Tony <tony@example.net>";
mail.Bcc        = "Support<support@example.net>";
mail.Subject    = "Mail demo";
mail.Message    = buffer;
mail.Attachment = NULL;
mail.Encoding   = NULL;
 
sprintf (buffer, "%s", "Hello from SMTP client!");
 
server.Address  = "mail.example.net";
server.Port     = 0;
server.Flags    = 0;
server.Username = "my_username";
server.Password = "my_password";
 
// Send mail, use default SMTP port
if (netSMTPc_SendMail (&mail, &server) != netOK) {
  // Failed to send an email
}
\endcode

\b Code \b Example (\em utf-8 encoding for 'µ' character)
\code
const NET_SMTP_MAIL mail = {
  "john@example.net",            // From
  "mary@example.net",            // To 
  NULL,                          // Cc
  NULL,                          // Bcc
  "µVision test",                // Subject
  "Here is µVision test log!",   // Message
  NULL,                          // Attachment
  "utf-8"                        // Encoding
};

\endcode
*/

/**
@}
*/

/**
\addtogroup smtpc_operation
@{
*/

//  ==== SMTP Client User Callbacks ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netSMTPc_Process (netSMTPc_Request request, char *buf, uint32_t buf_len, uint32_t *pvar)
\details
The callback function \b netSMTPc_Process provides additional parameters for the SMTP client session such as the credentials
to login to the SMTP server, email address of the sender and recipient, etc. The SMTP client calls this function several times 
to complete sending an email.

The argument \a request is an SMTP client signal:
|Request Name                       | Description                      |
|-----------------------------------|----------------------------------|
| \token{netSMTPc_RequestUsername}  | Username to login to SMTP server |
| \token{netSMTPc_RequestPassword}  | Password to login to SMTP server |
| \token{netSMTPc_RequestSender}    | Email address of the sender      |
| \token{netSMTPc_RequestRecipient} | Email address of the recipient   |
| \token{netSMTPc_RequestSubject}   | Subject of email                 |
| \token{netSMTPc_RequestBody}      | Email body in plain ASCII format |

The argument \a buf points to the output buffer where the function writes the requested data.

The argument \a buf_len specifies the length of the output buffer in bytes.

The argument \a pvar points to the local session buffer with a length of 4 bytes. The SMTP Client clears the data in the \a pvar
pointer to \token{0} before the function is called for the first time.

 
\b Code \b Example

The following example is available in the user code template file \b %SMTP_Client_UIF.c. Customize it to the application's
needs.

\code
// Request parameters for SMTP client session.
uint32_t netSMTPc_Process (netSMTPc_Request request, char *buf, uint32_t buf_len, uint32_t *pvar) {
  uint32_t len = 0;
 
  switch (request) {
    case netSMTPc_RequestUsername:
      // Username to login to SMTP server
      len = sprintf (buf, "guest");
      break;
 
    case netSMTPc_RequestPassword:
      // Password to login to SMTP server
      len = sprintf (buf, "guest");
      break;
 
    case netSMTPc_RequestSender:
      // Email address of the sender
      len = sprintf (buf, "me@domain.com");
      break;
 
    case netSMTPc_RequestRecipient:
      // Email address of the recipient
      len = sprintf (buf, "you@domain.com");
      break;
 
    case netSMTPc_RequestSubject:
      // Subject of email
      len = sprintf (buf, "Hello");
      break;
 
    case netSMTPc_RequestBody:
      // Email body in plain ascii format
      len = sprintf (buf, "Hello, how are you?\r\n");
  }
  return (len);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netSMTPc_Notify (netSMTPc_Event event)
\details
The callback function \b netSMTPc_Notify is called automatically when a SMTP event occurred and notifies the user application
when the SMTP client operation ends.

The argument \a event is an SMTP client signal as defined in \ref netSMTPc_Event. 

The function accepts one of the following SMTP events:
|Event                                      |Description|
|-------------------------------------------|-----------|
|\token{netSMTPc_EventSuccess}              |The email has been sent successfully.|
|\token{netSMTPc_EventTimeout}              |SMTP Server response has timed out, and hence the SMTP client has aborted the operation. The email has not been sent.|
|\token{netSMTPc_EventAuthenticationFailed} |User authentication on SMTP Server failed. The email has not been sent.|
|\token{netSMTPc_EventError}                |Protocol error occurred while sending email. The email has not been sent.|


\b Code \b Example

The following example is available in the user code template file \b %SMTP_Client_UIF.c. Customize it to the application's
needs.

\code
// Notify the user application when SMTP client operation ends.
void netSMTPc_Notify (netSMTPc_Event event) {
  switch (event) {
    case netSMTPc_EventSuccess:
      // Email successfully sent
      break;
 
    case netSMTPc_EventTimeout:
      // Timeout sending email
      break;
 
    case netSMTPc_EventAuthenticationFailed:
      // User authentication failed
      break;

    case netSMTPc_EventError:
      // Error when sending email
      break;
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netSMTPc_AcceptAuthentication (const NET_ADDR *addr)
\details
The callback function \b netSMTPc_AcceptAuthentication informs the Network Component if the SMTP client should log on to a
SMTP server when sending e-mails. The Network Component library calls this function and asks the user what to do if the SMTP
server has advertised the user authentication. It is now on the user to accept the authentication.

The argument \a addr points to a buffer containing the IP address and port of the remote SMTP server.

\note This function is called if the SMTP server has advertised user authentication.

\b Code \b Example

The following example is available in the user code template file \b %SMTP_Client_UIF.c. Customize it to the application's
needs.

\code
bool netSMTPc_AcceptAuthentication (const NET_ADDR *addr) {
  if ((addr->addr_type == NET_ADDR_IP4) && 
      (addr->addr[0] == 192)            &&
      (addr->addr[1] == 168)            &&
      (addr->addr[2] == 0  )            &&
      (addr->addr[3] == 1  )) {
    // Deny authentication from local smtp server
    return (false);
  }
  return (true);
}
\endcode
*/

/**
@}
*/

/**
\addtogroup smtpc_fs_interface
@{
*/

//  ==== SMTP Client File System Interface ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void void *netSMTPc_fopen (const char *fname)
\details
The function \b netSMTPc_fopen opens a file for reading.

The argument \a fname specifies the name of the file to open.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %SMTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void netSMTPc_fclose (void *file)
\details
The function \b netSMTPc_fclose closes the file identified by the \a file stream pointer.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %SMTP_Client_FS.c module.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t netSMTPc_fread (void *file, uint8_t *buf, uint32_t len)
\details
The function \b netSMTPc_fread reads \a len bytes from the file identified by the \a file stream pointer in the function
argument.

The argument \a buf is a pointer to the buffer where the function stores the data read from the file.

The function interfaces to the File System Component and will be called by the Network Component automatically. If another
file system will be used, refer to the reference implementation in the \b %SMTP_Client_FS.c module.

\note The function must read \a len bytes. The SMTP client stops reading and closes the file if the return value
is less than \a len bytes. 
*/

/**
@}
*/


//  ==== SNTP Client User API ====
/**
\addtogroup starting_sntp
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNTPc_GetTime (const NET_ADDR *addr, netSNTPc_cb_t cb_func)
\details
In \b unicast mode, the non-blocking function \b netSNTPc_GetTime sends a get time request to NTP server specified with the
argument \a addr. If the IP address is not specified (\a addr is \token{NULL}), then the IP address of the NTP Server configured
in \b Net_Config_SNTP_Client.h is used.

In \b broadcast mode, it opens an UDP socket for receiving broadcast NTP messages. You can use broadcast mode, if you have a
broadcasting NTP server in your local network. NTP messages that come from the specified NTP server are accepted. Messages that
come from a different NTP server are ignored. If the specified NTP server address is unknown address (0.0.0.0), then messages
from any NTP server are accepted.

The argument \a addr is a pointer to the structure containing the IP address and port of a local or public NTP server.

If the IP address is not specified (\a addr is \token{NULL}), then the IP address of the NTP Server configured in
\b Net_Config_SNTP_Client.h is used. <b>Broadcast Mode</b> gets also enabled here.

The argument \a cb_func points to a user-defined callback function called by the SNTP client when an NTP message is received
from the server. Refer to \ref netSNTPc_cb_t.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid or not supported parameter.
- \em netWrongState: SNTP client state incorrect for the current operating mode.
- \em netServerError: NTP or SNTP server IP address undefined.

\b Code \b Example
\code
const NET_ADDR4 ntp_server = { NET_ADDR_IP4, 0, 217, 79, 179, 106 };
static void time_callback (uint32_t seconds, uint32_t seconds_fraction);
 
void get_time (void) {
  if (netSNTPc_GetTime ((NET_ADDR *)&ntp_server, time_callback) == netOK) {
    printf ("SNTP request sent.\n");
  }
  else {
    printf ("SNTP not ready or bad parameters.\n");
  }
}
 
static void time_callback (uint32_t seconds, uint32_t seconds_fraction) {
  if (seconds == 0) {
    printf ("Server not responding or bad response.\n");
  }
  else {
    printf ("%d seconds elapsed since 1.1.1970\n", seconds);
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNTPc_GetTimeX (const char *server, uint32_t *seconds, uint32_t *seconds_fraction)
\details
The blocking function \b netSNTPc_GetTimeX sends a get time request to NTP server specified with the argument \a server and
returns current time retrieved from the server. If the address is not specified (\a server is \token{NULL}), then the IP address
of the NTP Server configured in \b Net_Config_SNTP_Client.h is used.

The argument \a server is a fully qualified domain name or an absolute IP address of a local or public NTP server. If \a server
is a hostname, the client uses the DNS resolver to resolve the destination IP address.

The argument \a seconds points to a user-provided variable, that will receive the time in seconds from the server.

The argument \a seconds_fraction points to a user-provided variable, that will receive the fraction of seconds. If the
pointer is not specified (\a seconds_fraction is \token{NULL}), then the fraction of seconds is not returned.

Possible \ref netStatus return values:
- \em netOK: Operation completed successfully.
- \em netInvalidParameter: Invalid or not supported parameter.
- \em netWrongState: SNTP client is busy in unicast mode.
- \em netDnsResolverError: DNS host resolver failed.
- \em netServerError: NTP or SNTP server IP address undefined.
- \em netError: Operation failed, returned time is not valid.

\note
- To use this function, you must enable the \ref netDNSc_Func "DNS client" in the selection of RTE Components.
- The \b netSNTPc_GetTimeX function only works in unicast mode. Use the \ref netSNTPc_GetTime for the broadcast mode.

\b Code \b Example
\code
uint32_t ctime;
 
if (netSNTPc_GetTimeX ("time1.google.com", &ctime, NULL) == netOK) {
  printf ("%d seconds elapsed since 1.1.1970\n", ctime);
}
else {
  printf ("SNTP not ready or bad parameters.\n");
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNTPc_SetMode (netSNTPc_Mode mode)
\details
The function \b netSNTPc_SetMode changes the operation mode of the SNTP client to \b unicast mode or \b broadcast mode.
It is used to change the operation mode of SNTP client when the client is running.

The argument \a mode specifies the operation mode to change to.

Possible \ref netStatus return values:
- \em netOK: Operation mode successfully set up.
- \em netInvalidParameter: Invalid operation mode provided.
- \em netWrongState: SNTP client is busy.

\b Code \b Example
\code
netSNTPc_SetMode (netSNTPc_ModeBroadcast);
\endcode
*/

/**
@}
*/


/**
\addtogroup snmp_user_api
@{
*/

//  ==== SNMP Agent User API ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNMP_Trap (const NET_ADDR *addr, uint8_t generic, uint8_t specific, const uint16_t *obj_list)
\details
The function \b netSNMP_Trap sends a message to the Trap Manager.

The argument \a addr points to the IP address and port of the Trap server. If the IP address of the Trap Manager is
\token{NULL}, then the IP address of Trap Server configured in \b Net_Config_SNMP_Agent.h is used.

The argument \a generic specifies the generic trap type:
|Type|Description               |
|:--:|--------------------------|
|0   |coldStart trap            |
|1   |warmStart trap            |
|2   |linkDown trap             |
|3   |linkUp trap               |
|4   |authenticationFailure trap|
|5   |egpNeighborLoss trap      |
|6   |enterpriseSpecific trap   |

The argument \a specific denotes a specific trap type. It must be set to \token{0} for all generic traps from <b>0..5</b>. It
defines a specific trap type for generic \b enterpriseSpecific trap.

The argument \a obj_list points to the objects from the MIB table, which will be included in the trap message
variable-bindings. This argument is a pointer to the object list array. This array is of variable size. The first element
specifies the count of objects in the object list array, followed by the object MIB index values.
|Array Index|Array Value               |
|:---------:|--------------------------|
|obj[0]     |number of objects n       |
|obj[1]     |MIB index of first object |
|obj[2]     |MIB index of second object|
|..         |..                        |
|obj[n]     |MIB index of last object  |

If \a obj_list is \token{NULL}, or <b>obj[0] = 0</b>, then no object values will be bound to the trap message.

Possible \ref netStatus return values:
- \em netOK: Trap message sent successfully.
- \em netInvalidParameter: Invalid parameter provided.
- \em netWrongState: MIB table not registered.
- \em netError: \b sysObjectId missing in the MIB table or message too big.

\note The maximum number of objects that can be bound to the trap message is limited to \b 20 objects. 

\b Code \b Example
\code
uint16_t obj[2];
 
// Add "KeyIn" value to trap message. 
obj[0] = 1;
obj[1] = 8;    // Index of "KeyIn" entry in MIB table.
netSNMP_Trap (NULL, 6, 1, obj);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNMP_SetCommunity (const char *community)
\details
The function \b netSNMP_SetCommunity changes the SNMP community to a new community identified by \a community.

The argument \a community is a pointer to a \token{null}-terminated string. The function copies the content of the \a community
to the SNMP community. The maximum length of the \a community string is limited to \token{18} characters.

Possible \ref netStatus return values:
- \em netOK: The new \a community successfully set.
- \em netInvalidParameter: Invalid \a community provided.

\note
When the function ends, the content of \a community becomes irrelevant and may be discarded.

\b Code \b Example
\code
uint16_t obj[2];
 
// Change the community to "private".
netSNMP_SetCommunity ("private");
 
// Add "KeyIn" value to trap message.
obj[0] = 1;
obj[1] = 8;    // Index of "KeyIn" entry in MIB table.
netSNMP_Trap (NULL, 6, 1, obj);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn netStatus netSNMP_SetMIB_Table (const NET_SNMP_MIB_INFO *info, uint32_t size)
\details
The function \b netSNMP_SetMIB_Table registers SNMP-MIB table in SNMP Agent. Until a valid SNMP-MIB table is registered in
SNMP Agent, the Agent is not active and does not respond to SNMP requests.

The argument \a info points to a buffer containing the SNMP-MIB entry info.

The argument \a size is a size of the SNMP-MIB table.

Possible \ref netStatus return values:
- \em netOK: MIB table successfully registered.
- \em netInvalidParameter: Invalid MIB table provided.

\b Code \b Example
\code
// MIB data table
static const NET_SNMP_MIB_INFO mib_table[] = {
  // SysDescr Entry
  { NET_SNMP_MIB_OCTET_STR | NET_SNMP_MIB_ATR_RO,
    8, {NET_SNMP_MIB_OID0(1,3), 6, 1, 2, 1, 1, 1, 0},
    NET_SNMP_MIB_STR("Embedded System SNMP V1.0"),
    NULL },
  ..
}
 
if (netSNMP_SetMIB_Table (mib_table, sizeof(mib_table)) == netOK) {
  // SNMP agent is active now
}
\endcode
*/

/**
@}
*/


/**
\addtogroup netGen_AddrConvFunc
@{
*/

// ==== Network Address Conversion ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netIP_ntoa (int16_t addr_type, const uint8_t *ip_addr, char *string_buf, uint32_t buf_len);
\details
The function \b netIP_ntoa converts a network address to ASCII.

The argument \a addr_type specifies if the address to be converted is IPv4 or IPv6.

The argument \a ip_addr points to the buffer containing the IP address to be converted.

\b Code \b Example
\code
uint8_t ip_addr [NET_ADDR_IP6_LEN];
char ip_ascii[40];
 
netIP_ntoa (NET_ADDR_IP6, &ip_addr[0], ip_ascii, sizeof (ip_ascii));
printf ("IP address: %s\n", ip_ascii);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netIP_aton (const char *addr_string, int16_t addr_type, uint8_t *ip_addr)
\details
The function \b netIP_aton converts an ASCII to a network address.

The argument \a addr_string specifies the ASCII representation of the IP address.

The argument \a addr_type specifies if the address to be converted is IPv4 or IPv6.

The argument \a ip_addr points to the buffer that stores the converted IP address.

\b Code \b Example
\code
uint8_t ip_addr[NET_ADDR_IP6_LEN];
 
netIP_aton ("fec0::1", NET_ADDR_IP6, &ip_addr[0]);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn const char *netMAC_ntoa (const uint8_t *mac_addr, char * string_buf, uint32_t buf_len);
\details
The function \b netMAC_ntoa converts a MAC address to ASCII.

The argument \a mac_addr specifies the MAC address to be converted.

\b Code \b Example
\code
uint8_t mac [NET_ADDR_ETH_LEN];
char mac_ascii[18];
 
netMAC_ntoa (&mac[0], mac_ascii, sizeof (mac_ascii));
printf ("MAC address: %s\n", mac_ascii);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool netMAC_aton (const char *mac_string, uint8_t *mac_addr)
\details
The function \b netMAC_aton converts an ASCII string to a MAC address.

The argument \a mac_string specifies the ASCII representation of the MAC address.

The argument \a mac_addr is a pointer to the buffer that stores the converted MAC address.

\b Code \b Example
\code
uint8_t mac [NET_ADDR_ETH_LEN];
 
netMAC_aton ("1E-30-6C-A2-45-5E", &mac[0]);
\endcode
*/


/**
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup netStatusErrorCodes Status and Error Codes
\brief    Status and Error Codes returned by Network functions. 
\details
The Status and Error Codes section lists all the return values that the Network Component functions will return.
*/

/**
\ingroup netStatusErrorCodes
*/

/**
\typedef netStatus
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   network_structs  Data Format
\ingroup    netGen_Func
\brief      Structures of the Network Component
@{
\struct NET_ADDR
\details
NET_ADDR allows to store IPv4 and IPv6 addresses along with the Internet socket port number.
\em addr_type indicates the IP address format for \em addr. \em addr contains the IP address in binary format, whereby the
MSB is stored first.

\b Example:

IP Address (ASCII)                      | \em addr_type      | \em addr
:---------------------------------------|:-------------------|:--------------------------
192.168.0.1                             | \ref NET_ADDR_IP4  | 0xC0 0xA8 0x00 0x01
fe80:0000:0000:0000:1c30:6cff:fea2:455e | \ref NET_ADDR_IP6  | 0xFE 0x80 0x00 0x00 0x00 0x00 0x00 0x1C 0x30 0x6C 0xFF 0xFE 0xA2 0x45 0x5E
fe80::1c30:6cff:fea2:455e               | \ref NET_ADDR_IP6  | 0xFE 0x80 0x00 0x00 0x00 0x00 0x00 0x1C 0x30 0x6C 0xFF 0xFE 0xA2 0x45 0x5E

The functions \ref netIP_ntoa and \ref netIP_aton can be used to convert IP addresses from ASCII to binary and vice versa.

\struct NET_ADDR4
\details
NET_ADDR4 allows to store only IPv4 addresses along with the Internet socket port number. Use this struct if you only use IPv4
to save memory.
\em addr_type indicates the IP address format for \em addr.  \em addr contains the IP address in binary format, whereby the
MSB is stored first. Since only IPv4 addresses can be stored, the value for \em addr_type should be set to \ref NET_ADDR_IP4.

@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   Common_structs  Structures
\ingroup    netInterfaces_Common
\brief      Common structures for all Interfaces
@{
\struct NET_DHCP_OPTION_ITEM
\details
Carries information about the DHCP options.

@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   Ethernet_structs  Structures
\ingroup    netETH_Func
\brief      Structures of the Ethernet Interface
@{
\struct NET_ETH_LINK_INFO
\details
Contains information about the Ethernet link (speed and duplex mode).

@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   Wifi_structs  Structures
\ingroup    netWiFi_Func
\brief      Structures of the WiFi Interface
@{
\struct NET_WIFI_CONFIG
\details
Contains network configuration for station mode or access point mode.

<b>Used in:</b>
 - \ref netWiFi_Activate

\struct NET_WIFI_NET_INFO
\details
Contains network information about the wireless access point to which the station is connected.

<b>Used in:</b>
 - \ref netWiFi_GetNetInfo

\struct NET_WIFI_SCAN_INFO
\details
Contains information about the wireless access points.

<b>Used in:</b>
 - \ref netWiFi_Scan
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   snmp_structs  Structures
\ingroup    netSNMP_Func
\brief      Structures of the SNMP Service
@{
\struct NET_SNMP_MIB_INFO
\details
Contains information about the SNMP MIB objects.
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   smtp_structs  Structures
\ingroup    netSMTPc_Func
\brief      Structures of the SMTP Client
@{
\struct NET_SMTP_MAIL
\details
NET_SMTP_MAIL contains information about the email content.

- \ref From, \ref To, \ref Cc and \ref Bcc<br> specify one or more email addresses. The address string may include optional
  friendly name. In this case the address name must be separated from friendly name and specified in angle brackets. 
  Multiple addresses are separated by semicolons. Leading and trailing spaces are ignored in email address processing.

  The value of \token{NULL} indicates unspecified option. For example the value of \token{NULL} for \em Bcc indicates no 
  Blind carbon copies.

  The following example specifies three \em To recipients (the last with no friendly name), no \em Cc and no \em Bcc:
  \code
  mail.From = "John <john@example.net>";
  mail.To   = "Mary <mary@example.net>; Joe <joe@example.net>; tony@example.net";
  mail.Cc   =  NULL;
  mail.Bcc  =  NULL; 
  \endcode

- \ref Subject<br> specifies the subject of an email. The string might contain international characters. In this case the
  proper character encoding must be specified with \em Encoding member.
  \code
  mail.Subject = "Mail demo"; 
  \endcode

- \ref Message<br> contains the message content, which might also contain international characters. 
  \code
  mail.Message = "Hello from SMTP client!"
  \endcode

- \ref Attachment<br> specifies one or more attachments to an email. The attachments are actually file names, specified
  in the attachment string. Multiple attachments are separated by semicolons. The value of \token{NULL} specifies
  no attachments. If the attachments are specified, the attachment support must also be enabled in the \ref using_smtpc_conf.

  The following example adds three attachments:
  \code
  mail.Attachment = "test.log; results.txt; M:/docs/um.pdf";
  \endcode

- \ref Encoding<br> specifies the encoding type used for international characters. The value of \token{NULL} enables using
  default \em us-ascii character encoding. Other encoding types are: \em utf-8, \em iso-8859-1, etc.
  \code
  mail.Encoding = "utf-8";
  \endcode
  
<b>Parameter for:</b>
 - \ref netSMTPc_SendMail

\struct NET_SMTP_MTA
\details
NET_SMTP_MTA contains information about the SMTP server or Mail Transfer Agent address and user credentials.

- \ref Address<br> specifies a fully qualified domain name or an IP address of SMTP server. If the \em Server is specified
  as FQDN (ie. "smtp.gmail.com"), the IP address is resolved internally.

  The following example configures SMTP client for Gmail:
  \code
  mta.Address = "smtp.gmail.com";
  mta.Port    = 0;
  mta.Flags   = NET_SMTP_MTA_USETLS; 
  \endcode

- \ref Port<br> specifies a TCP port of the Server to connect to. If the \em Port number is \token{0}, the system automatically
  selects the appropriate port number for communication.
  \code
  mta.Port = 25;
  \endcode
  
- \ref Flags<br> specifies additional options for SMTP client.

  Currently only one option is defined:
  \em Flags                | Description
  :------------------------|:-----------------------------------------------------------------------------------
  \ref NET_SMTP_MTA_USETLS | Requires to use secure TLS mode (<b>SMTPS</b> must be enabled).
  \token{0}                | Selects non-secure mode.

  The value of \token{0} selects non-secure mode when <b>SMTPS</b> is not enabled. When <b>SMTPS</b> is enabled, 
  the client automatically switches to secure mode, if SMTP server supports it (explicit TLS).
  \code
  mta.Flags = 0;
  \endcode

- \ref Username<br> specifies the username to be used for authentication on SMTP server. 
  \code
  mta.Username = "my_username";
  \endcode

- \ref Password<br> specifies the password to be used for authentication on SMTP server. 
  \code
  mta.Password = "my_password";
  \endcode

<b>Parameter for:</b>
 - \ref netSMTPc_SendMail
@}
*/
