/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page USB_Device_Tutorial Examples

MDK contains multiple example projects that show how to implement an USB Device. The following examples are available
for most of the development boards:

- The \subpage dev_hid_tutorial example provides access from the USB Host to the development board's LEDs and push buttons
- The \subpage dev_msc_tutorial example provides mass storage device to the USB Host and uses SD/MMC memory card or internal RAM as storage media
- The \subpage dev_cdc_tutorial example provides virtual communication port to UART bridge to the USB Host
- The \subpage dev_cdc_ncm example shows how to connect an Ethernet device via USB (for Linux hosts)
- The \subpage dev_cdc_acm_rndis_bridge example shows how to connect an Ethernet device via USB (for Windows hosts)
- The \subpage dev_cdc_acm_rndis example contains a step-by-step instruction how to change a network application example so
  that the embedded device can be connected to a Windows host using USB.
- The \subpage dev_comp_tutorial example shows how to create a composite device using the HID and MSC classes
- The \subpage dev_mouse_tutorial example shows how to create a USB device that acts as a mouse input device
- The \subpage dev_adc_tutorial example provides an audio input/output functionality to the USB Host
- The \subpage dev_cc_tutorial example provides an example for a custom USB class

To use these examples, use the \urlout{uv4_ca_packinstaller}, select the related \b Board and \b Copy the example.

*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_hid_tutorial USB Device HID

The \ref HID "Human Interface Device (HID)" example shows simple data exchange between the USB Device and an USB Host Computer.
The examples accesses the board LEDs and push buttons from the USB Host Computer using the HID client program. The following
picture shows an exemplary connection of the development board and the USB Host Computer.

\image html "hid_example_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more
information on the general setup and the available I/O of the development board.

Build the "USB Device HID" Project
==================================

Open the example project in MDK.

Source Files
------------
- \b HID.c contains the main C function that initializes the board hardware and the USB Device Component. It also
  sends the current input status (typical buttons) via \ref USBD_HID_GetReportTrigger to the USB Host.
- The <b>USBD_User_HID_0.c</b> is an adapted code template that implements all necessary functions I/O communication.
  Refer to \ref usbd_hidFunctions for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Device HID" Project
===========================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Use an USB cable to connect your development board to the Host PC and power up your board.
- Wait for the driver installation on the PC to complete. First you will see "Installing device driver software" and after a successful installation "USB Input Device":

\image html "hid_install.png"

PC Software
-----------
The USB Device HID example can be tested on a Windows PC using the HIDClient.exe utility (located in
"C:\Keil\ARM\Utilities\HID_Client\Release"). The program runs stand-alone without installation. 

\n Steps to check the USB communication using the client utility:
- Run "C:\Keil\ARM\Utilities\HID_Client\Release\HIDClient.exe".
- Select the <b>Keil USB Device</b> to establish the communication channel.
- Press buttons on the target hardware and/or use the check boxes in the HID Client to interact with the application.
    
\image html "hid_client_test.png"


*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_msc_tutorial USB Device Mass Storage

A mass storage USB Device implements an USB memory stick. Together with the <b>File System</b> you can connect various
drives using MSC to an USB Host: SD cards, internal or external Flash memory and even a simple RAM disk. 
The examples accesses either on-chip RAM or a SD card where available. The USB Host can then access the new drives
using standard file access methods. The following picture shows an exemplary connection of the development board
and the USB Host Computer.

\image html "msc_dev_example_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more
information on the general setup and the available storage device on the development board.

Build the "USB Device Mass Storage" Project
===========================================

Open the example project in MDK.

Source Files
------------
- \b MassStorage.c contains the main C function that initializes the board hardware and the USB Device Component.
- The <b>USBD_User_MSC_0.c</b> is an adapted code template that implements all necessary file access functions.
  Refer to \ref usbd_mscFunctions for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Device Mass Storage" Project
===========================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Insert a SD card into the socket (if available).
- Use an USB cable to connect your development board to the Host PC and power up your board.
- Wait for the driver installation on the PC to complete. First you will see "Installing device driver software" and after a
  successful installation "Keil Disk 0 USB Device":
\image html "msc_ready.png"

PC Software
-----------
The USB Device Mass Storage example can be tested on a Windows PC using the \b Windows \b Explorer. After a successful
driver installation, the <b>AutoPlay</b> window appears:

\image html "auto_play_msc_dev.png"

If you click on <b>Open folder to view files</b> Windows Explorer automatically starts with the drive opened.



*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_cdc_tutorial USB Device Virtual COM Port

The Communication Device Class (CDC) is used for implementing virtual communication ports. This example demonstrates a bridge
between a <b>Virtual COM Port</b> on the USB Host Computer and an UART port on the evaluation board. 

The following picture shows an exemplary connection of the development board
and the USB Host Computer.

\image html "cdc_dev_example_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more
information on the general setup and the available I/O on the development board.

Build the "USB Device Virtual COM" Project
==========================================

Open the example project in MDK.

Source Files
------------
- \b VirtualCOM.c contains the main C function that initializes the board hardware and the USB Device Component.
  Furthermore, it contains the code that exchanges the data internally between the USB and the UART port.
- The <b>USBD_User_CDC_0.c</b> is an adapted code template that implements all necessary file access functions.
  Refer to \ref usbd_cdcFunctions_acm for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Device Virtual COM" Project
==========================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Connect the UART on the development board to your PC (you might need an USB to serial RS232 adapter). Use an USB cable to
  connect your development board to the Host PC and power up your board.
- The <b>Welcome to the Found New Hardware Wizard</b> appears. Installation of the driver is described in detail in the
  \b Abstract.txt file.

PC Software
-----------
The USB Device Virtual COM example can be tested on a Windows PC using a terminal emulation program. Since Hyperterminal
in not part of Windows any more, please download an appropriate program for this purpose (such as \b PuTTY for example).
Open the two COM ports "COMx" and "COMy". Any data from "COMx" will be echoed on "COMy" and visa versa:

\image html "vcom_terminals.png"

<b>About Host PC driver for Microsoft Windows</b>

The example folder contains two files relevant for driver installation on the Microsoft Windows:
 - Driver setup information file (xxx-vcom.inf) which is used to create a digitally signed driver catalog file (xxx-vcom.cat)
 - Digitally signed driver catalog file (xxx-vcom.cat)

The driver files are provided as an example, the driver setup information file should be adapted and digitally signed driver catalog file 
should be created from adapted driver setup information file.

Driver setup information file should be adapted in the following way:
 - <b>c251</b> in Vendor ID \b VID_c251 entries should be changed to the vendor ID number assigned to your company by the USB organization
   (c251 Vendor ID is reserved for Keil Software and should not be used)
 - <b>xxxx</b> in Product ID \b PID_xxxx entries should be changed to the product ID as assigned by your company
 - in <b>[DeviceList.xxx]</b> sections, entries not relevant for the device, should be removed or added as described below:
   - if device is pure CDC class device (<b>not composite</b>) then all entries ending with <b>&MI_xx should be removed</b>
   - if device is a <b>composite device</b> with one or more CDC class instances then entries <b>not ending</b> 
     with <b>&MI_xx should be removed</b> and entries <b>ending</b> with <b>&MI_xx should exist</b> 
     for each CDC class instance
     (example driver contains entries ending with &MI_00 and &MI_02 which are used for composite device containing 
      two CDC class instances and each instance uses 2 interfaces where MI_00 describes first CDC instance and 
      MI_02 entry describes second CDC instance)
 - <b>[Strings]</b> section should be changed as desired

\note Vendor ID and Product ID are configured in the USBD_Config_n.h configuration file of the embedded application.
\note For producing digitally signed driver catalog file please refer to Microsoft Windows documentation.


*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page dev_adc_tutorial USB Device Audio

The Audio Device Class (ADC) is used to send or receive audio, voice, and other sound-related functionality. This example
demonstrates a \b USB \b Audio \b Device attached to the USB Host Computer to provide this capability. 

The following picture shows an exemplary connection of the development board and the USB Host Computer. Using the USB
connection, the development board will play sound using its on-board speaker:

\image html "adc_dev_example_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more information on the
general setup and the available I/O on the development board.

Build the "USB Device Audio" Project
====================================

Open the example project in MDK.

Source Files
------------
- \b Audio.c contains the main C function that initializes the board hardware and the USB Device Component.
- The file <b>USBD_User_ADC_0.c</b> is an code template that needs to be adapted to board audio hardware. Refer to
  \ref usbd_adcFunctions for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Device Audio" Project
====================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Use a USB cable to connect your development board to the Host PC and power up your board.
- The <b>Welcome to the Found New Hardware Wizard</b> appears. Installation of the driver is described in detail in the
  \b Abstract.txt file.
- If detected correctly, you should be able to see the following message:

\image html "adc_install_ok.png" Installation succeeded

PC Software
-----------
Use any PC software that is capable of playing audio. Normally, the device that has been connected last will play the audio
data. If you do not hear any sound coming from the on-board speaker, check your system settings.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page dev_cc_tutorial Custom USB Device (WinUSB_Echo)

Using the custom USB class, you can implement any USB device that is not covered by the other classes available in the
MDK Middleware. An example is available for various development boards that is implementing a custom class to work with the Windows USB (WinUSB), a generic driver for USB devices for Microsoft Windows. The example demonstrates a WinUSB device that contains Bulk IN and Bulk OUT endpoints. All data that the device receives on the Bulk OUT endpoint is echoed back on the Bulk IN endpoint.

The following picture shows an exemplary connection of the development board and the Windows USB host computer. Using the USB connection and WinUSB_Test.exe ("install_dir\ARM\PACK\Keil\Middleware\x.y.z\Utilities\WinUSB_Test" folder 
(where "install_dir" refers to the installation directory of Arm Keil MDK, default "C:\Keil_v5") and x >= 7, y >= 5, z >= 0), you can initiate . For more information, refer to \ref winusb_app.

\image html "cc_dev_example_setup.png" Hardware setup for WinUSB Custom Class example

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more information on the general setup.

Build the "WinUSB_Echo" Project
===============================

Open the example project in MDK.

Source Files
------------
- \b main.c contains the main C function that initializes the hardware.
- \b WinUSB_Echo.c contains the app_main C function that initializes USB Device Component.
- The files <b>USBD_User_CustomClass_0.c/USBD_User_CustomClass_1.c</b> are adapted code templates that implement all
  necessary functions. Refer to \ref usbd_classFunctions for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash --> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "WinUSB_Echo" Project
===============================

Hardware Setup
--------------

The setup of the evaluation board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Use a USB cable to connect your development board to the host PC and power up your board.
- If you connect the device to a PC running Windows 8 or later, the device driver will be installed automatically. On Windows 7, you need to select a driver file that can be found in the project folder. For more information, refer to the \b Abstract.txt file in the µVision project.

PC Software
-----------

The example can be tested on a Windows PC using the WinUSB_Test.exe utility provided with MDK Middleware. The program runs stand-alone without installation. Simply run "install_dir\\ARM\PACK\Keil\MDK-Middleware\x.y.z\Utilities\WinUSB_Test\Release\WinUSB_Test.exe" application
(where x >= 7, y >= 5, z >= 0):

\image html "WinUSB_Test_application.png"


\b Device \b Selection

| Configuration Option | Selection |
|----------------------|-----------|
| GIUD                 | The GUID that is used in Windows to access the device. For this example, the GIUD is fixed. To create your own GIUD, refer to the \b Abstract.txt file. |
| Device               | Select the device that you have attached to the PC (VID should be C251). |

\b Control \b Transfer


| Configuration Option | Selection |
|----------------------|-----------|
| Setup Packet         | Normally, leave open. Will be filled automatically from the next options. |
| Direction            | Specify the communication direction. If you want to read for example the device descriptor from the device, use Device-to-Host. |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">Type</a>                | Type of the control request (standard/class/vendor). |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">Recipient</a>           | Recipient of the control transfer message (device/interface/endpoint/other). |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">bRequest</a>            | Specify the setup packet request being made. |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">wValue</a>              | Specify the wValue of the request. |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">wIndex</a>              | Specify the wIndex of the request. |
| <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml" target="_blank">wLength</a>             | Specify the wLength of the request. |

\b Data \b Phase

| Configuration Option              | Selection |
|-----------------------------------|-----------|
| Data (aa bb cc ..)                | Shows the transmitted data |
| Transfer button                   | Start the data transfer    |
| File                              | Select a file for transfer or for saving transferred data |
| Transfer to/from File button      | Start the data transfer to/from file |

\b Bulk/Interrupt \b Transfer

| Configuration Option                | Selection |
|-------------------------------------|-----------|
| Interface                           | Select USB interface number |
| IN Transfer Endpoint                | Select IN endpoint to be used for bulk/interrupt transfer |
| Number of bytes to receive          | Specify the number of bytes to be received |
| Data (aa bb cc ..)                  | Shows the received data |
| Start Reception button              | Start listening on the specified endpoint    |
| File                                | Select a file for saving received data |
| Start Reception to File button      | Start listening on the specified endpoint and save data to file |
| OUT Transfer Endpoint               | Select OUT endpoint to be used for bulk/interrupt transfer |
| Data (aa bb cc ..)                  | Enter the data to be transmitted |
| Start Transmission button           | Start sending data on the specified endpoint    |
| File                                | Select a file for data to be transmitted |
| Start Transmission from File button | Start sending data from the specified file on the OUT endpoint |


Examples
--------

\b Control \b Transfer

To setup the control endpoint and to read out the device descriptor of the device, enter the following:
- Direction: Device-to-Host
- bRequest: 06
- wValue: 0100
- wIndex 0000
- wLength: 0012

After pressing the \b Transfer button, you see the response in the Data window:

\image html "WinUSB_Test_control_transfer.png"

\b Bulk \b Transfer

To loop data from the device to the PC and back, enter the following:
- Interface: 0
- IN Transfer Endpoint: 1
- Press Start Reception to Buffer
- OUT Transfer Endpoint: 1
- Enter some data in the right-hand Data window, for example AA BB CC
- Press Start Transmission from Buffer

You now see the same data in the left-hand Data window:

\image html "WinUSB_Test_bulk_transfer.png"

<b>About Host PC driver for Microsoft Windows</b>

The example folder contains two files relevant for driver installation on the Microsoft Windows:
 - Driver setup information file (xxx-winusb_echo.inf) which is used to create a digitally signed driver catalog file (xxx-winusb_echo.cat)
 - Digitally signed driver catalog file (xxx-winusb_echo.cat)

The driver files are provided as an example, the driver setup information file should be adapted and digitally signed driver catalog file 
should be created from adapted driver setup information file.

Driver setup information file should be adapted in the following way:
 - <b>c251</b> in Vendor ID \b VID_c251 entries should be changed to the vendor ID number assigned to your company by the USB organization
   (c251 Vendor ID is reserved for Keil Software and should not be used)
 - <b>xxxx</b> in Product ID \b PID_xxxx entries should be changed to the product ID as assigned by your company
 - <b>[DeviceList.xxx]</b> sections should be changed if device is a composite device in the following way:<br>
   instead of entries like: \code %DeviceName0% = USB_Install, USB\VID_xxxx&PID_yyyy \endcode
   entries describing each custom class instance should be added like: \code %DeviceName0% = USB_Install, USB\VID_xxxx&PID_yyyy&MI_00 \endcode
   where two digit number after MI_ describes the starting interface of a custom class instance
 - <b>[Strings]</b> section should be changed as desired

\note Vendor ID and Product ID are configured in the USBD_Config_n.h configuration file of the embedded application.
\note For producing digitally signed driver catalog file please refer to Microsoft Windows documentation.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_comp_tutorial USB Composite Device

An USB Composite Device is a peripheral device that supports more than one device class. Many different devices are implemented
as composite devices. For example they consist of a certain device class, but also an USB disk that has all the necessary drivers
stored so that the device can be installed automatically, without the need to have access to a certain driver software.
\n In this example, we will implement a composite device that is made up of two devices that have been used in the previous tutorials.
We will have access to the development board's \b buttons (from the HID example) and the <b>SC card</b> (from the MSC example).

\image html "comp_dev_example_setup.png"

Build the "USB Composite" Project
=================================
Open the \ref dev_msc_tutorial "MSC example project" in MDK. From the \ref dev_hid_tutorial "HID example project", copy HID.c
and USBD_User_HID.c and add them to the project. Open the <b>Manage Run-Time Environment</b> window. Add one USB:Device:HID component to the
project. After clicking OK, you will see that the USB Component in the Project window will have an additional entry:
USBD_Config_HID_0.h. As the HID example uses LEDs and push-buttons, you might need to add these <b>Board Support</b> related
items as well. Check the RTE Component selection of the HID example for further detail.

Source Files
------------
Now we have two main functions in the project. We need to delete one of them. Open the MassStorage.c file.
Copy the lines
\code
finit ("M0:");           /* Initialize SD Card 0 */
fmount("M0:");           /* Mount SD Card 0 */
\endcode
to the HID.c file right before the lines
\code
USBD_Initialize    (0);
USBD_Connect       (0);
\endcode
Insert
\code
#include "rl_fs.h"
\endcode
to the \c \#includes at the beginning of the HID.c file. Afterwards, remove the MassStorage.c from your project.
Now you have only one main function left.

USB Device Configuration
------------------------
Before running the program on the target hardware, you need to edit the USBD_Config_HID_0.h file. Open the file, switch to
the <b>Configuration Wizard</b> and go to the <b>Bulk Endpoint Settings</b>. As the file is generic and has no information
about other classes available in the project, the Endpoint 1 is configured for IN and OUT. This endpoint is already used
in the USBD_Config_MSC_0.h file. So change the number for IN and for OUT to '2'. This will make the HID Component use the
Endpoint 2 for data exchange with the USB Host and no conflicts will occur with the MSC class.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.

You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Composite" Project
=================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Insert a SD card into the socket.
- Use an USB cable to connect your development board to the Host PC and power up your board.
- Wait for the driver installation on the PC to complete. First you will see "Installing device driver software" and after a
  successful installation "USB Input Device" and "Keil Disk 0 USB Device".

\note 
If devices do not install correctly then probably device is using same Vendor ID and Product ID as some device 
that was previously already installed. There are two possible solutions: either change Product ID in USBD_Config_0.h file 
or uninstall previously installed device that uses same Vendor ID and Product ID.

PC Software
-----------
The HID part of this example can be tested on a Windows PC using the HIDClient.exe utility (located in
"C:\Keil\ARM\Utilities\HID_Client\Release"). The program runs stand-alone without installation. 
\n Steps to check the USB communication using the client utility:
- Run "C:\Keil\ARM\Utilities\HID_Client\Release\HIDClient.exe".
- Select the <b>Keil USB Device</b> to establish the communication channel.
- Press buttons on the target hardware and/or use the check boxes in the HID Client to interact with the application.
The Mass Storage part of this example can be tested on a Windows PC using the \b Windows \b Explorer.
- After a successful driver installation, the <b>AutoPlay</b> window appears.
- If you click on <b>Open folder to view files</b> Windows Explorer automatically starts with the drive opened.

*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_mouse_tutorial USB Mouse

The USB Mouse example application shows how to control the mouse pointer of a host PC with a microcontroller device using
USB Device HID.

The following picture shows an exemplary connection of the development board (in this case a
<a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a>) to a host PC.
Using the joystick on the development board you can move the mouse pointer on the screen. Pressing the joystick down will
issue a left-click action.

\image html "mouse_dev_example_setup.png"

Create the "USB Mouse" Project
=================================
In this example, we are using the <a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a> board with the STM32F407IGHx device.
Create a new project in MDK (Select Device <b>STMicroelectronics:STM32F4 Series: STM32F407:STM32F407IG:STM32F407IGHx</b>).
In the <b>Manage Run-Time Environment</b> window, select the following components:
- <b>Board Support:Joystick (API):Joystick</b>  (Variant \b MCBSTM32F400)
- <b>CMSIS:Core</b>
- <b>CMSIS:RTOS2 (API):Keil RTX5</b>
- <b>CMSIS Driver:USB Device (API):Full-speed</b>
- <b>Device:STM32Cube Framework (API):Classic</b>
- <b>USB:Device: 1</b>
- <b>USB:Device:HID:1</b>

Click the <b>Resolve</b> button and then <b>OK</b>.

Before continuing to add the required source code, you need to add a template file called <b>USBD_User_HID_Mouse_0.c</b>:

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>User Code Template</b> and select the <b>USB Device HID Mouse</b> template.
- Click <b>Add</b> to copy the file <b>USBD_User_HID_Mouse_0.c</b> to the project.

Source Files
------------
- Click on <b>New (Ctrl + N)</b> to create a new file.
- Save it (<b>File -> Save</b>) as <b>main.h</b>.
- Copy the following code into the main.h file and save it again:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Inc/main.h 
  * @author  MCD Application Team
  * @brief   Header for main.c module
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */
  
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
extern uint64_t app_main_stk[];
extern const osThreadAttr_t app_main_attr;

/* Exported macro ------------------------------------------------------------*/


/* Exported functions ------------------------------------------------------- */
extern void app_main (void *arg);

#endif /* __MAIN_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>main</b> in the <b>Name</b> box.
- Copy the following code into the main.c file:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Src/main.c 
  * @author  MCD Application Team
  * @brief   Main program body
  *
  * @note    modified by ARM
  *          The modifications allow to use this file as User Code Template
  *          within the Device Family Pack.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

#ifdef _RTE_
#include "RTE_Components.h"             // Component selection
#endif
#ifdef RTE_CMSIS_RTOS2                  // when RTE component CMSIS RTOS2 is used
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2
#endif

#ifdef RTE_CMSIS_RTOS2_RTX5
/**
  * Override default HAL_GetTick function
  */
uint32_t HAL_GetTick (void) {
  static uint32_t ticks = 0U;
         uint32_t i;

  if (osKernelGetState () == osKernelRunning) {
    return ((uint32_t)osKernelGetTickCount ());
  }

  /* If Kernel is not running wait approximately 1 ms then increment 
     and return auxiliary tick counter value */
  for (i = (SystemCoreClock >> 14U); i > 0U; i--) {
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
  }
  return ++ticks;
}
#endif

/** @addtogroup STM32F4xx_HAL_Examples
  * @{
  */

/** @addtogroup Templates
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);
static void Error_Handler(void);

/* Private functions ---------------------------------------------------------*/
/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{

  /* STM32F4xx HAL library initialization:
       - Configure the Flash prefetch, Flash preread and Buffer caches
       - Systick timer is configured by default as source of time base, but user 
             can eventually implement his proper time base source (a general purpose 
             timer for example or other time source), keeping in mind that Time base 
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
             handled in milliseconds basis.
       - Low Level Initialization
     */
  HAL_Init();

  /* Configure the system clock to 168 MHz */
  SystemClock_Config();
  SystemCoreClockUpdate();


  /* Add your application code here
     */

#ifdef RTE_CMSIS_RTOS2
  /* Initialize CMSIS-RTOS2 */
  osKernelInitialize ();

  /* Create application main thread */
  osThreadNew(app_main, NULL, &app_main_attr);

  /* Start thread execution */
  osKernelStart();
#endif

  /* Infinite loop */
  while (1)
  {
  }
}

/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (HSE)
  *            SYSCLK(Hz)                     = 168000000
  *            HCLK(Hz)                       = 168000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 4
  *            APB2 Prescaler                 = 2
  *            HSE Frequency(Hz)              = 8000000
  *            PLL_M                          = 25
  *            PLL_N                          = 336
  *            PLL_P                          = 2
  *            PLL_Q                          = 7
  *            VDD(V)                         = 3.3
  *            Main regulator output voltage  = Scale1 mode
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
  
  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }

  /* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
  if (HAL_GetREVID() == 0x1001)
  {
    /* Enable the Flash prefetch */
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  }
}
/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1)
  {
  }
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>app_main</b> in the <b>Name</b> box.
- Copy the following code into the app_main.c file:
\verbatim
#include "main.h"
#include "rl_usb.h"

#include "Board_Joystick.h"

// Main stack size must be multiple of 8 Bytes
#define APP_MAIN_STK_SZ (1024U)
uint64_t app_main_stk[APP_MAIN_STK_SZ / 8];
const osThreadAttr_t app_main_attr = {
  .stack_mem  = &app_main_stk[0],
  .stack_size = sizeof(app_main_stk)
};

/*------------------------------------------------------------------------------
 *        Application
 *----------------------------------------------------------------------------*/
__NO_RETURN void app_main (void *arg) {
  uint32_t state, state_ex = 0;
  uint8_t  mouse_in_report[4];
  bool     update;

  (void)arg;

  Joystick_Initialize();

  USBD_Initialize    (0);               /* USB Device 0 Initialization        */
  USBD_Connect       (0);               /* USB Device 0 Connect               */

  while (1) {
    state  = Joystick_GetState();
    update = 0;
    mouse_in_report[0] = 0;
    mouse_in_report[1] = 0;
    mouse_in_report[2] = 0;
    mouse_in_report[3] = 0;
 
    if ((state ^ state_ex) & JOYSTICK_CENTER) {
      mouse_in_report[0] = (state & JOYSTICK_CENTER) ? 1 : 0;   /* Left Click */
      update   = 1;
      state_ex = state;
    }
    if (state & JOYSTICK_LEFT  ) { mouse_in_report[1] = (uint8_t)(-4); update = 1; } /* X Left  */
    if (state & JOYSTICK_RIGHT ) { mouse_in_report[1] =            4 ; update = 1; } /* X Right */
    if (state & JOYSTICK_UP    ) { mouse_in_report[2] = (uint8_t)(-4); update = 1; } /* Y Up    */
    if (state & JOYSTICK_DOWN  ) { mouse_in_report[2] =            4 ; update = 1; } /* Y Down  */
 
    if (update) {
      USBD_HID_GetReportTrigger(0, 0, mouse_in_report, 4);
    }
  }
}
\endverbatim

Before building the project, you need to edit these configuration files (in Configuration Wizard view):
- Under <b>Device</b>, double-click <b>RTE_Device.h</b> and:
  - enable <b>I2C1 (Inter-integrated Circuit Interface 1) [Driver_I2C1]</b> (for the Joystick connected to I2C1) and:
    - set <b>I2C1_SCL Pin</b> to \b PB8
    - set <b>I2C1_SDA Pin</b> to \b PB9
  - enable <b>USB OTG Full-speed</b> and under it:
    - enable <b>Device [Driver_USBD0]</b>

- Under <b>USB</b>, double-click <b>USBD_Config_0.h</b> and under <b>USB Device 0:Device Settings</b> change:
  - set <b>Product ID</b> to \b 0x3502

- Under <b>USB</b>, double-click <b>USBD_Config_HID_0.h</b> and under <b>USB Device: Human Interface Device class (HID) 0:Human Interface Device Class Settings</b> change:
  - set <b>Maximum Input Report Size (in bytes)</b> to \b 4 as this is the size of report that is sent for a mouse
    position change and button presses from the main function
  - enable <b>Use User Provided HID Report Descriptor</b> and:
    - set <b>User Provided HID Report Descriptor Size (in bytes)</b> to \b 52

Before building and downloading the project to the target, make sure that the correct debugger is set in the <b>Options for
Target</b> dialog (ALT + F7). You may then build and download the example project to the evaluation board using the µVision
commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Mouse" Project
================================

Hardware Setup
--------------
- Verify all jumper settings on the target hardware.
- Connect the development board to a host PC attaching a Micro-USB cable to the <b>USBFS</b> port. Observe how it is
  recognized as a USB HID device with the mouse protocol:

\image html "hid_compliant_mouse.png"

- Play around with the joystick and see how the mouse moves on the screen.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_cdc_ncm Ethernet-over-USB (for Linux hosts)

The Ethernet-over-USB example connects a computer via USB to a Cortex-M system that provides an Ethernet interface for
network connectivity. The Linux Kernel provides native support for the CDC (NCM) USB Device class. This example shows how to
connect a Ubuntu system via USB to an MCBSTM32F400 development board.

The following picture shows an exemplary connection of the development board (in this case a
<a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a>) to a host PC.

\image html "eth_over_usb_example_setup.png"

Create the "Ethernet-over-USB" Project
======================================
In this example, we are using the <a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a> board with the STM32F407IGHx device.
Create a new project in MDK (Select Device <b>STMicroelectronics:STM32F4 Series: STM32F407:STM32F407IG:STM32F407IGHx</b>).
In the <b>Manage Run-Time Environment</b> window, select the following components:
- <b>CMSIS:Core</b>
- <b>CMSIS:RTOS2 (API):Keil RTX5</b>
- <b>CMSIS Driver:Ethernet MAC (API):Ethernet MAC</b>
- <b>CMSIS Driver:Ethernet PHY (API):KSZ8081RNA</b>
- <b>CMSIS Driver:USB Device (API):High-speed</b>
- <b>Device:STM32Cube Framework (API):Classic</b>
- <b>USB:Device: 1</b>
- <b>USB:Device:CDC:1</b>

Click the <b>Resolve</b> button and then <b>OK</b>.

Before continuing to add the required source code, you need to add a template file called <b>USBD_User_CDC_NCM_ETH_0.c</b>:

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>User Code Template</b> and select the <b>USB Device CDC NCM Ethernet Bridge</b> template.
- Click <b>Add</b> to copy the file <b>USBD_User_CDC_NCM_ETH_0.c</b> to the project.

Source Files
------------
- Click on <b>New (Ctrl + N)</b> to create a new file.
- Save it (<b>File -> Save</b>) as <b>main.h</b>.
- Copy the following code into the main.h file and save it again:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Inc/main.h 
  * @author  MCD Application Team
  * @brief   Header for main.c module
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */
  
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
extern uint64_t app_main_stk[];
extern const osThreadAttr_t app_main_attr;

/* Exported macro ------------------------------------------------------------*/


/* Exported functions ------------------------------------------------------- */
extern void app_main (void *arg);

#endif /* __MAIN_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>main</b> in the <b>Name</b> box.
- Copy the following code into the main.c file:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Src/main.c 
  * @author  MCD Application Team
  * @brief   Main program body
  *
  * @note    modified by ARM
  *          The modifications allow to use this file as User Code Template
  *          within the Device Family Pack.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

#ifdef _RTE_
#include "RTE_Components.h"             // Component selection
#endif
#ifdef RTE_CMSIS_RTOS2                  // when RTE component CMSIS RTOS2 is used
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2
#endif

#ifdef RTE_CMSIS_RTOS2_RTX5
/**
  * Override default HAL_GetTick function
  */
uint32_t HAL_GetTick (void) {
  static uint32_t ticks = 0U;
         uint32_t i;

  if (osKernelGetState () == osKernelRunning) {
    return ((uint32_t)osKernelGetTickCount ());
  }

  /* If Kernel is not running wait approximately 1 ms then increment 
     and return auxiliary tick counter value */
  for (i = (SystemCoreClock >> 14U); i > 0U; i--) {
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
  }
  return ++ticks;
}
#endif

/** @addtogroup STM32F4xx_HAL_Examples
  * @{
  */

/** @addtogroup Templates
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);
static void Error_Handler(void);

/* Private functions ---------------------------------------------------------*/
/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{

  /* STM32F4xx HAL library initialization:
       - Configure the Flash prefetch, Flash preread and Buffer caches
       - Systick timer is configured by default as source of time base, but user 
             can eventually implement his proper time base source (a general purpose 
             timer for example or other time source), keeping in mind that Time base 
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
             handled in milliseconds basis.
       - Low Level Initialization
     */
  HAL_Init();

  /* Configure the system clock to 168 MHz */
  SystemClock_Config();
  SystemCoreClockUpdate();


  /* Add your application code here
     */

#ifdef RTE_CMSIS_RTOS2
  /* Initialize CMSIS-RTOS2 */
  osKernelInitialize ();

  /* Create application main thread */
  osThreadNew(app_main, NULL, &app_main_attr);

  /* Start thread execution */
  osKernelStart();
#endif

  /* Infinite loop */
  while (1)
  {
  }
}

/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (HSE)
  *            SYSCLK(Hz)                     = 168000000
  *            HCLK(Hz)                       = 168000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 4
  *            APB2 Prescaler                 = 2
  *            HSE Frequency(Hz)              = 8000000
  *            PLL_M                          = 25
  *            PLL_N                          = 336
  *            PLL_P                          = 2
  *            PLL_Q                          = 7
  *            VDD(V)                         = 3.3
  *            Main regulator output voltage  = Scale1 mode
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
  
  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }

  /* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
  if (HAL_GetREVID() == 0x1001)
  {
    /* Enable the Flash prefetch */
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  }
}
/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1)
  {
  }
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>app_main</b> in the <b>Name</b> box.
- Copy the following code into the app_main.c file:
\verbatim
#include "main.h"
#include "rl_usb.h"

// Main stack size must be multiple of 8 Bytes
#define APP_MAIN_STK_SZ (1024U)
uint64_t app_main_stk[APP_MAIN_STK_SZ / 8];
const osThreadAttr_t app_main_attr = {
  .stack_mem  = &app_main_stk[0],
  .stack_size = sizeof(app_main_stk)
};

/*------------------------------------------------------------------------------
 *        Application
 *----------------------------------------------------------------------------*/
__NO_RETURN void app_main (void *arg) {

  (void)arg;

  USBD_Initialize    (0);               /* USB Device 0 Initialization        */
  USBD_Connect       (0);               /* USB Device 0 Connect               */

  while (1) {
    osThreadFlagsWait (0, osFlagsWaitAny, osWaitForever);
  }
}
\endverbatim

Before building the project, you need to edit these configuration files (in Configuration Wizard view):
- Under <b>Device</b>, double-click <b>RTE_Device.h</b> and:
  - enable <b>ETH (Ethernet Interface) [Driver_ETH_MAC0]</b> and:
    - disable <b>ENET:MII (Media Independent Interface)</b>
    - enable <b>ENET:RMII (Reduced Media Independent Interface)</b> and:
      - set <b>ETH_RMII_TXD0 Pin</b> to \b PG13
      - set <b>ETH_RMII_TXD1 Pin</b> to \b PG14
      - set <b>ETH_RMII_TX_EN Pin</b> to \b PG11
  - enable <b>USB OTG High-speed</b> and under it:
    - enable <b>Device [Driver_USBD1]</b>

- Under <b>USB</b>, double-click <b>USBD_Config_0.h</b> and under <b>USB Device 0</b> change:
  - set <b>Connect to hardware via Driver_USBD#</b> to \b 1
  - enable <b>High-speed</b>
  - under <b>Device Settings</b> change:
    - set <b>Max Endpoint 0 Packet Size</b> to \b 64
    - set <b>Product ID</b> to \b 0x3518

- Under <b>USB</b>, double-click <b>USBD_Config_CDC_0.h</b> and under <b>USB Device: Communication Device Class (CDC) 0</b> change:
  - set <b>Communication Class Subclass</b> to <b>Network Control Model (NCM)</b>

Before building and downloading the project to the target, make sure that the correct debugger is set in the <b>Options for
Target</b> dialog (ALT + F7). You may then build and download the example project to the evaluation board using the µVision
commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "Ethernet-over-USB" Project
=====================================

Hardware Setup
--------------
- Verify all jumper settings on the target hardware.
- Connect the development board to a host Linux PC (native or in a virtual machine) attaching a Micro-USB cable to
  the <b>USBHS</b> port and using an Ethernet cable to the \b ETH connector.
- Using a virtual machine, you need to connect to the VM:

\image html vbox_usb_attach.png "Attach USB Device to Virtual Machine"

- Within the Linux system (here Ubuntu), you should be able to see a wired Ethernet connection (with the MAC address
  1E:30:6C:A2:45:5E):

\image html ubuntu_ncm.png "Wired Ethernet Connection using the USB CDC NCM Device"

\note Set the MAC address in the USB CDC configuration file \ref usbd_cdcFunctions_ncm_conf "USBD_Config_CDC_0.h".

Troubleshooting
===============
Especially when working with virtual machines, the USB connection is not passed onto the guest system properly. Then it can
help to restart the guest. Also, to make Ubuntu use the network adapter that you like, do the following:
In Ubuntu's search, enter "network". The \b Network \b Connections program will be available in the search results:

\image html ubuntu_network_connections.png

Double-click to open and then mark the \b Wired \b connection \b 1 and click \b Edit:

\image html ubuntu_network_connections_wired1.png

Select the MAC address of your Ethernet-over-USB device and press \b Save and \b Close:

\image html ubuntu_network_connections_wired1_selection.png

This should instruct Ubuntu to use your device for the network connection. Also, try to disconnect any other network adapter
from the virtual machine.
*/
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_cdc_acm_rndis_bridge USB Device RNDIS to Ethernet Bridge

The USB Device RNDIS to Ethernet Bridge example connects a Windows host via USB to a Cortex-M system that provides an
Ethernet interface for network connectivity. 

The following picture shows an exemplary connection of the development board (in this case a
<a class="el" href="https://www.keil.com/boards2/keil/mcb4300/" target="_blank">MCB4300</a>) to a host PC.


\image html usb_dev_rndis_eth_bridge.png


The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more information on the
general setup.

Build the "RNDIS to Ethernet Bridge" project
===============================

Open the example project in MDK.

Source Files
------------
- \b main.c contains the main C function that initializes the Keil RTX real-time operating system.
- \b RNDIS.c contains the app_main C function that initializes the GLCD and the USB Device Component.
- The files <b>USBD_User_CDC_ACM_RNDIS_ETH_0.c</b> implements the application specific functionality of the CDC ACM class
  using the RNDIS protocol and is used to implement a Network Interface Card (NIC) to Ethernet Bridge to the USB Host. Refer
  to \ref usbd_cdcFunctions_acm for details about these template functions.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbd_res_req.
  
You may now build and download the example project to the development board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash --> <b> Download (F8) </b>

After these steps, the project should start executing on your development kit.
In case of errors, refer to the development board user's guide for configuration information.

Using the "RNDIS to Ethernet Bridge" Project
===============================

Hardware Setup
--------------

The setup of the development board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Power your development board externally.
- Connect a USB cable between your development board and the host PC.
- You should see new "Ethernet" connection with a "Remote NDIS compatible device" in your network
  control panel:
  \image html usb_dev_rndis_eth_bridge_control_panel.png
  if driver is not installed automatically please install driver from example folder.

<b>About Host PC driver for Microsoft Windows</b>

The example folder contains two files relevant for driver installation on the Microsoft Windows:
 - Driver setup information file (xxx-rndis.inf) which is used to create a digitally signed driver catalog file (xxx-rndis.cat)
 - Digitally signed driver catalog file (xxx-rndis.cat)

The driver files are provided as an example, the driver setup information file should be adapted and digitally signed driver catalog file 
should be created from adapted driver setup information file.

Driver setup information file should be adapted in the following way:
 - <b>c251</b> in Vendor ID \b VID_c251 entries should be changed to the vendor ID number assigned to your company by the USB organization
   (c251 Vendor ID is reserved for Keil Software and should not be used)
 - <b>xxxx</b> in Product ID \b PID_xxxx entries should be changed to the product ID as assigned by your company
 - in <b>[DeviceList.xxx]</b> sections, entries not relevant for the device, should be removed or added as described below:
   - if device is pure RNDIS CDC class device (<b>not composite</b>) then all entries ending with <b>&MI_xx should be removed</b>
   - if device is a <b>composite device</b> with one or more RNDIS CDC class instances then entries <b>not ending</b> 
     with <b>&MI_xx should be removed</b> and entries <b>ending</b> with <b>&MI_xx should exist</b> 
     for each RNDIS CDC class instance
     (example driver contains entries ending with &MI_00 and &MI_02 which are used for composite device containing 
      two RNDIS CDC class instances and each instance uses 2 interfaces where MI_00 describes first RNDIS instance and 
      MI_02 entry describes second RNDIS CDC instance)
 - <b>[Strings]</b> section should be changed as desired

\note Vendor ID and Product ID are configured in the USBD_Config_n.h configuration file of the embedded application.
\note For producing digitally signed driver catalog file please refer to Microsoft Windows documentation.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\page dev_cdc_acm_rndis USB Web Server (for Windows hosts)

This example does not work out-of-the-box. You need to copy a network example for your development board using Pack
Installer. Then, you need to change some settings and add user code, to be able to connect your network enabled device to a
Windows hosts using USB.

\note The following description is based on the HTTP Server for a MCB1800 development board.

The following picture shows an exemplary connection of the development board (in this case a
<a class="el" href="https://www.keil.com/boards2/keil/mcb1800/" target="_blank">MCB1800</a>) to a host PC.

\image html "usb_web_server_example.png"

Create the "USB Web Server" project
===================================

- Copy the HTTP Server example using Pack Installer
- Change following settings in RTE:
  - Disable CMSIS Driver:Ethernet MAC (API)
  - Disable CMSIS Driver:Ethernet PHY (API)
  - Enable CMSIS Driver:Ethernet (API):RNDIS
  - Enable an appropriate CMSIS Driver:USB Device (API)
  - Set USB:Device = 1
  - Enable USB:CORE
  - Set USB:Device:CDC = 1
- Enable the selected USB port in RTE_Device.h or using external tools (for example STM32CubeMX for STMicroelectronics
   devices)
- Disable the Ethernet port in RTE_Device.h or using external tools (for example STM32CubeMX for STMicroelectronics
   devices)
- Add a user code template to your sources (right-click on Source group in Project window -> Add New Item to Group 'Source'
   -> User Code Template -> USB:USB Device:CDC: USB Device CDC ACM RNDIS Virtual Ethernet -> Add)
- Disable DHCP in network settings (open Network:Net_Config_ETH_0.h and disable Dynamic Host Configuration) 
- Open USB:USBD_Config_0.h and check/change settings:
  - Set the correct hardware driver interface number
  - Enable high-speed operation (if available)
  - Device Settings:
    - Max Endpoint 0 Packet Size = 64 Bytes
  - Product ID = set to required (if you are using Windows 7, set it to 0x3709 for Keil MCB boards)
  - Microsoft OS Descriptors Settings:OS String = enable
- Open USB:USBD_Config_CDC_0.h and check/change settings:
  - USB Device: Communication Device Class (CDC) 0:
     - Communication Class Subclass = Abstract Control Model (ACM)
     - Communication Class Protocol = Vendor-specific (RNDIS)
     - Interrupt Endpoint Settings:
       - Endpoint Settings:
         - Full/Low-speed:
           - Maximum Endpoint Packet Size In bytes) = 16
         - High-speed:
           - Maximum Endpoint Packet Size In bytes) = 16
     - Bulk Endpoint Settings:
       - Endpoint Settings:
         - Full/Low-speed:
           - Maximum Endpoint Packet Size In bytes) = 64
         - High-speed:
           - Maximum Endpoint Packet Size In bytes) = 512
     - Communication Device Class Settings: Abstract Control Model Settings:
       - Communication Class Interface String = USB Remote NDIS6 based Device
       - Call Management Capabilities:
         - Call Management channel = Communication Class Interface only
         - Device Call Management handling = None
     - Abstract Control Management Capabilities:
       - all disabled
     - Maximum Communication Device Send Buffer Size = 2048
     - Maximum Communication Device Receive Buffer Size = 2048
- If <b>RTX v5</b> is used <b>no changes to RTX settings</b> are necessary as all resources are allocated statically.
- Add this include to the main module:
  \code
  #include "rl_usb.h"
  \endcode
- Add these lines of code to the HTTP_Server.c module before endless loop in \c main or \c app_main function:
  \code
  USBD_Initialize (0U); // USB Device 0 Initialization
  USBD_Connect    (0U); // USB Device 0 Connect
  \endcode

Build the project and download to the target.

Using the "USB Web Server" project
==================================

Hardware Setup
--------------
- Verify all jumper settings on the target hardware.
- Connect the development board to a host PC attaching a Micro-USB cable to the <b>USB0</b> port.
- Make sure that the board is not powered using this USB port. An external power supply is recommended.
- After the device is recognized on the Windows PC:
 - If the high-speed port is used, the driver should install on Windows 7 and later automatically 
 - If not, please use the provided .inf file from the USB RNDIS example (for example for MCB4300 evaluation board), 
   but change .inf file Product ID according to one set in USBD_Config_0.h file
 - Set your computer's IP address to 192.168.0.101 to match the settings of the embedded device:
   - Go to Control Panel -> Network and Sharing Center -> Change Adapter Settings 
   - Right-click on Local Area Connection n (Remote NDIS56 based Device):
     \image html nw_connections_win_host.png
   - Select properties -> Internet Protocol Version 4 (TCP/IPv4) properties and use the following address:
      - IP address: 192.168.0.101
      - Subnet mask: 255.255.255.0
   OK and close all dialogs
 - Open a web browser and enter the address 192.168.0.100
 - Use "admin" without a password to log in:
   \image html web_server_if.png
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page USB_Host_Tutorial Examples

MDK Professional contains multiple example projects that show how to implement an USB Host. The following examples are
available for most of the development boards:

- The \subpage host_hid_tutorial example shows how to interact with an USB keyboard from a microcontroller.
- The \subpage host_msc_tutorial example shows how to access an USB memory stick from a microcontroller.
- The \subpage host_cdc_tutorial example shows how to communicate with an USB CDC Device from a microcontroller.
- The \subpage host_cust_tutorial example shows how to communicate with any USB Device from a microcontroller.
  Here, it will be demonstrated using a USB to serial RS232 adapter with 
  <a class=el href="https://www.prolific.com.tw/US/index.aspx" target="_blank">Prolific PL2303</a>
  UART-to-USB bridge chip.

To use these examples, use the \urlout{uv4_ca_packinstaller}, select the related \b Board and \b Copy the example.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page host_hid_tutorial USB Host Keyboard

The following example application shows how to interact with a <b>USB keyboard</b> from a microcontroller. 
To keep it simple, the graphical LCD on the evaluation board is used to show the keyboard inputs. This is done using 
the \b Compiler software component with the appropriate user code templates.

\image html "usbh_hid_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more information on the
general setup and the available I/O of the development board.

Build the "USB Host Keyboard" Project
======================================
Open the example project in MDK (\urlout{uv4_ca_packinstaller} web page explains this).

Source Files
------------
- \b Keyboard.c contains the main C function that initializes the board hardware and the USB Host Component. It also reads
  the input from the attached keyboard.
- In \b stdout_display.c, the function \c stdout_putchar is retargeted to the function \c GLCD_DrawChar of the graphics
  display.

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbh_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Host Keyboard" Project
======================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Connect a USB keyboard to one of the development board's USB connectors.
- After downloading the code onto the board, you should be able to see something similar on the graphics display:

\image html "usbh_keyboard_glcd.png"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page host_msc_tutorial USB Host Mass Storage

The following example application shows how to access an <b>USB memory stick</b> from a microcontroller. 
This example will create or overwrite a file called \b Test.txt on the USB Stick with the content "USB Host Mass Storage!".
The following picture shows an exemplary connection of the development board and an USB memory stick.

\image html "usbh_msc_setup.png"

The \b Abstract.txt file contained in the \b Documentation group of the \b Project window gives you more information on the
general setup and the available I/O of the development board.

Build the "USB Host Mass Storage" Project
=========================================
Open the example project in MDK (the \urlout{uv4_ca_packinstaller} web page explains this).

Source Files
------------
- \b MassStorage.c contains the main C function that initializes the board hardware, the flash storage device and the USB
  Host Component. Also, it contains that code that will write a file with a message onto the attached USB stick. 

If you are using RTOS other than CMSIS-RTOS2 RTX5 for your project please make sure to satisfy \ref usbh_res_req.
  
You may now build and download the example project to the evaluation board using the µVision commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Host Mass Storage" Project
=========================================

Hardware Setup
--------------
The setup of the Evaluation Board hardware is described in the \b Abstract.txt file.
- Verify all jumper settings on the target hardware.
- Simply connect an USB memory stick to one of the development board's USB connectors and run the program.
- Detach the USB memory stick and attach it to a PC to check the availability of the \b Test.txt file.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page host_cust_tutorial USB Host Custom Class

This example application shows how to communicate with serial RS232 adapter with
<a class=el href="https://www.prolific.com.tw/US/index.aspx" target="_blank">Prolific PL2303</a>
UART-to-USB bridge chip from a microcontroller. It is a simple demonstration
on how to send data from the USB Host via the USB to serial RS232 adapter to an attached serial terminal. Here, the USB Host sends "Test!" to the
USB to serial RS232 adapter and stores all incoming data from the device into the array \c receive_buf. This example is using the Custom
Class because the PL2303 is not USB CDC ACM compliant.

The following picture shows an exemplary connection of the development board and an PL2303 based Device. The PL2303 Device is
connected to a PC via RS232 to check incoming messages.

\image html "usbh_cust_pl2303_example_setup.png"

Create the "USB Host Custom Class PL2303" Project
=================================================
In this example, we are using the <a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a> board with the STM32F407IGHx device.
Create a new project in MDK (Select Device <b>STMicroelectronics:STM32F4 Series: STM32F407:STM32F407IG:STM32F407IGHx</b>).
In the <b>Manage Run-Time Environment</b> window, select the following components:
- <b>Board Support:LED (API):LED</b> (Variant \b MCBSTM32F400)
- <b>CMSIS:Core</b>
- <b>CMSIS:RTOS2 (API):Keil RTX5</b>
- <b>CMSIS Driver:USART (API):PL2303</b>
- <b>CMSIS Driver:USB Host (API):Full-speed</b>
- <b>Device:STM32Cube Framework (API):Classic</b>
- <b>USB</b> (Variant \b MDK)
- <b>USB:Host: 1</b>
- <b>USB:Host:Custom Class</b>

Click the <b>Resolve</b> button and then <b>OK</b>. 

Before continuing to add the required source code, you need to add a template file called \b USBH_PL2303.c:
- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>User Code Template</b> and scroll down on  the left side, until you see the \b USB component template files.
- Choose <b>USB Host Prolific 2303</b>
- Click on <b>Add</b>.

Source Files
------------
- Click on <b>New (Ctrl + N)</b> to create a new file.
- Save it (<b>File -> Save</b>) as <b>main.h</b>.
- Copy the following code into the main.h file and save it again:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Inc/main.h 
  * @author  MCD Application Team
  * @brief   Header for main.c module
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */
  
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
extern uint64_t app_main_stk[];
extern const osThreadAttr_t app_main_attr;

/* Exported macro ------------------------------------------------------------*/


/* Exported functions ------------------------------------------------------- */
extern void app_main (void *arg);

#endif /* __MAIN_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>main</b> in the <b>Name</b> box.
- Copy the following code into the main.c file:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Src/main.c 
  * @author  MCD Application Team
  * @brief   Main program body
  *
  * @note    modified by ARM
  *          The modifications allow to use this file as User Code Template
  *          within the Device Family Pack.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

#ifdef _RTE_
#include "RTE_Components.h"             // Component selection
#endif
#ifdef RTE_CMSIS_RTOS2                  // when RTE component CMSIS RTOS2 is used
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2
#endif

#ifdef RTE_CMSIS_RTOS2_RTX5
/**
  * Override default HAL_GetTick function
  */
uint32_t HAL_GetTick (void) {
  static uint32_t ticks = 0U;
         uint32_t i;

  if (osKernelGetState () == osKernelRunning) {
    return ((uint32_t)osKernelGetTickCount ());
  }

  /* If Kernel is not running wait approximately 1 ms then increment 
     and return auxiliary tick counter value */
  for (i = (SystemCoreClock >> 14U); i > 0U; i--) {
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
  }
  return ++ticks;
}
#endif

/** @addtogroup STM32F4xx_HAL_Examples
  * @{
  */

/** @addtogroup Templates
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);
static void Error_Handler(void);

/* Private functions ---------------------------------------------------------*/
/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{

  /* STM32F4xx HAL library initialization:
       - Configure the Flash prefetch, Flash preread and Buffer caches
       - Systick timer is configured by default as source of time base, but user 
             can eventually implement his proper time base source (a general purpose 
             timer for example or other time source), keeping in mind that Time base 
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
             handled in milliseconds basis.
       - Low Level Initialization
     */
  HAL_Init();

  /* Configure the system clock to 168 MHz */
  SystemClock_Config();
  SystemCoreClockUpdate();


  /* Add your application code here
     */

#ifdef RTE_CMSIS_RTOS2
  /* Initialize CMSIS-RTOS2 */
  osKernelInitialize ();

  /* Create application main thread */
  osThreadNew(app_main, NULL, &app_main_attr);

  /* Start thread execution */
  osKernelStart();
#endif

  /* Infinite loop */
  while (1)
  {
  }
}

/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (HSE)
  *            SYSCLK(Hz)                     = 168000000
  *            HCLK(Hz)                       = 168000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 4
  *            APB2 Prescaler                 = 2
  *            HSE Frequency(Hz)              = 8000000
  *            PLL_M                          = 25
  *            PLL_N                          = 336
  *            PLL_P                          = 2
  *            PLL_Q                          = 7
  *            VDD(V)                         = 3.3
  *            Main regulator output voltage  = Scale1 mode
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
  
  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }

  /* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
  if (HAL_GetREVID() == 0x1001)
  {
    /* Enable the Flash prefetch */
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  }
}
/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1)
  {
  }
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>app_main</b> in the <b>Name</b> box.
- Copy the following code into the app_main.c file:
\verbatim
#include "main.h"
#include "rl_usb.h"

#include "Board_LED.h"

#include "Driver_USART.h"
 
/* UART Driver */
extern ARM_DRIVER_USART       Driver_USART9;
#define ptrUART_USB         (&Driver_USART9)

// Main stack size must be multiple of 8 Bytes
#define APP_MAIN_STK_SZ (1024U)
uint64_t app_main_stk[APP_MAIN_STK_SZ / 8];
const osThreadAttr_t app_main_attr = {
  .stack_mem  = &app_main_stk[0],
  .stack_size = sizeof(app_main_stk)
};

static uint8_t  receive_buf[64];

/*------------------------------------------------------------------------------
 *        UART Done Callback
 *----------------------------------------------------------------------------*/
void UART_Done (uint32_t event) {
  switch (event) {
    case ARM_USART_EVENT_SEND_COMPLETE:
      // All requested data was transmitted
      LED_On(1);
      break;
    case ARM_USART_EVENT_RECEIVE_COMPLETE:
      // After 64 bytes were received, restart new reception
      ptrUART_USB->Receive (receive_buf, 64);
      LED_On(2);
      break;
  }
}

/*------------------------------------------------------------------------------
 *        Application
 *----------------------------------------------------------------------------*/
__NO_RETURN void app_main (void *arg) {
  static bool con_last = false;
         bool con;

  (void)arg;

  LED_Initialize    ();

  USBH_Initialize (0);                        /* Initialize USB Host 0        */

  while (1) {
    con = (USBH_CustomClass_GetStatus(0) == usbOK);
    if (con ^ con_last) {
      if (con) {
        con_last = true;
        LED_On(0);
        osDelay(1000);

        /* Initialize and configure UART <-> USB Bridge */
        ptrUART_USB->Initialize  (UART_Done);
        ptrUART_USB->PowerControl(ARM_POWER_FULL);
        ptrUART_USB->Control     (ARM_USART_MODE_ASYNCHRONOUS |
                                  ARM_USART_DATA_BITS_8       |
                                  ARM_USART_PARITY_NONE       |
                                  ARM_USART_STOP_BITS_1       |
                                  ARM_USART_FLOW_CONTROL_NONE ,
                                  115200                      );
        ptrUART_USB->Control     (ARM_USART_CONTROL_TX, 1);
        ptrUART_USB->Control     (ARM_USART_CONTROL_RX, 1);
        ptrUART_USB->Receive     (receive_buf, 64);
        ptrUART_USB->Send        ("Test!",     5);
      } else {
        con_last = false;
        LED_Off(0);
      }
    } else {
      if (con) {
        // Receive data can be checked by polling as callback will be called 
        // only when all requested number of bytes were received 
        // (in this case 64 bytes)
        if (ptrUART_USB->GetRxCount() == 5) {
          // If 5 bytes were received
        }
      }
      osDelay(1000);
    }
  }
}
\endverbatim

Before building the project, you need to edit these configuration files (in Configuration Wizard view):
- Under <b>Device</b>, double-click <b>RTE_Device.h</b> and:
  - enable <b>USB OTG Full-speed</b> and under it:
    - enable <b>Host [Driver_USBH0]</b>
    - disable <b>Host [Driver_USBH0]:Overcurrent Detection Pin</b>

- Double-click <b>USB:USBH_Config_0.h</b> and under <b>USB Host 0</b> change:
  - set <b>Maximum Pipes in system</b> to \b 4

Before building and downloading the project to the target, make sure that the correct debugger is set in the <b>Options for
Target</b> dialog (ALT + F7). You may then build and download the example project to the evaluation board using the µVision
commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Host Custom Class PL2303" Project
================================================

Hardware Setup
--------------
- Verify all jumper settings on the target hardware.
- Connect an USB to serial  RS232 adapter using the Prolific PL2303 to the development board's \b USBFS connector.
- Connect the serial line to a PC and open a terminal using 115200 baud data rate.
- You should see the message "Test!" in the terminal window. You can also send messages from the PC to the microcontroller
  device. For that, please check the \c receive_buf buffer called by the \c ->Receive function.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\page host_cdc_tutorial USB Host CDC ACM

This example application shows how to communicate with an <b>USB CDC ACM Device</b> from a microcontroller. It is a simple demonstration
on how to send data from the USB Host to the attached USB CDC ACM Device. Here, the USB Host sends "Test!" to the USB CDC ACM Device
and stores all incoming data from the device into the array \c receive_buf.

The following picture shows an exemplary connection of the development board and an USB CDC ACM Device implemented on another
development board. This USB CDC ACM Device is connected to a PC via RS232 to check incoming messages.

\image html "usbh_cdc_example_setup.png"

Create the "USB Host CDC" Project
=================================
In this example, we are using the <a class="el" href="https://www.keil.com/boards2/keil/mcbstm32f400/" target="_blank">MCBSTM32F400</a> board with the STM32F407IGHx device.
Create a new project in MDK (Select Device <b>STMicroelectronics:STM32F4 Series: STM32F407:STM32F407IG:STM32F407IGHx</b>).
In the <b>Manage Run-Time Environment</b> window, select the following components:
- <b>Board Support:LED (API):LED</b> (Variant \b MCBSTM32F400)
- <b>CMSIS:Core</b>
- <b>CMSIS:RTOS2 (API):Keil RTX5</b>
- <b>CMSIS Driver:USART (API):CDC</b>
- <b>CMSIS Driver:USB Host (API):Full-speed</b>
- <b>Device:STM32Cube Framework (API):Classic</b>
- <b>USB</b> (Variant \b MDK)
- <b>USB:Host: 1</b>
- <b>USB:Host:CDC</b>

Click the <b>Resolve</b> button and then <b>OK</b>.

Source Files
------------
- Click on <b>New (Ctrl + N)</b> to create a new file.
- Save it (<b>File -> Save</b>) as <b>main.h</b>.
- Copy the following code into the main.h file and save it again:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Inc/main.h 
  * @author  MCD Application Team
  * @brief   Header for main.c module
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */
  
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_hal.h"
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
extern uint64_t app_main_stk[];
extern const osThreadAttr_t app_main_attr;

/* Exported macro ------------------------------------------------------------*/


/* Exported functions ------------------------------------------------------- */
extern void app_main (void *arg);

#endif /* __MAIN_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/ 
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>main</b> in the <b>Name</b> box.
- Copy the following code into the main.c file:
\verbatim
/**
  ******************************************************************************
  * @file    Templates/Src/main.c 
  * @author  MCD Application Team
  * @brief   Main program body
  *
  * @note    modified by ARM
  *          The modifications allow to use this file as User Code Template
  *          within the Device Family Pack.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2017-2018 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

#ifdef _RTE_
#include "RTE_Components.h"             // Component selection
#endif
#ifdef RTE_CMSIS_RTOS2                  // when RTE component CMSIS RTOS2 is used
#include "cmsis_os2.h"                  // ::CMSIS:RTOS2
#endif

#ifdef RTE_CMSIS_RTOS2_RTX5
/**
  * Override default HAL_GetTick function
  */
uint32_t HAL_GetTick (void) {
  static uint32_t ticks = 0U;
         uint32_t i;

  if (osKernelGetState () == osKernelRunning) {
    return ((uint32_t)osKernelGetTickCount ());
  }

  /* If Kernel is not running wait approximately 1 ms then increment 
     and return auxiliary tick counter value */
  for (i = (SystemCoreClock >> 14U); i > 0U; i--) {
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
    __NOP(); __NOP(); __NOP(); __NOP(); __NOP(); __NOP();
  }
  return ++ticks;
}
#endif

/** @addtogroup STM32F4xx_HAL_Examples
  * @{
  */

/** @addtogroup Templates
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
static void SystemClock_Config(void);
static void Error_Handler(void);

/* Private functions ---------------------------------------------------------*/
/**
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{

  /* STM32F4xx HAL library initialization:
       - Configure the Flash prefetch, Flash preread and Buffer caches
       - Systick timer is configured by default as source of time base, but user 
             can eventually implement his proper time base source (a general purpose 
             timer for example or other time source), keeping in mind that Time base 
             duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
             handled in milliseconds basis.
       - Low Level Initialization
     */
  HAL_Init();

  /* Configure the system clock to 168 MHz */
  SystemClock_Config();
  SystemCoreClockUpdate();


  /* Add your application code here
     */

#ifdef RTE_CMSIS_RTOS2
  /* Initialize CMSIS-RTOS2 */
  osKernelInitialize ();

  /* Create application main thread */
  osThreadNew(app_main, NULL, &app_main_attr);

  /* Start thread execution */
  osKernelStart();
#endif

  /* Infinite loop */
  while (1)
  {
  }
}

/**
  * @brief  System Clock Configuration
  *         The system Clock is configured as follow : 
  *            System Clock source            = PLL (HSE)
  *            SYSCLK(Hz)                     = 168000000
  *            HCLK(Hz)                       = 168000000
  *            AHB Prescaler                  = 1
  *            APB1 Prescaler                 = 4
  *            APB2 Prescaler                 = 2
  *            HSE Frequency(Hz)              = 8000000
  *            PLL_M                          = 25
  *            PLL_N                          = 336
  *            PLL_P                          = 2
  *            PLL_Q                          = 7
  *            VDD(V)                         = 3.3
  *            Main regulator output voltage  = Scale1 mode
  *            Flash Latency(WS)              = 5
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  
  /* Enable Power Control clock */
  __HAL_RCC_PWR_CLK_ENABLE();
  
  /* The voltage scaling allows optimizing the power consumption when the device is 
     clocked below the maximum system frequency, to update the voltage scaling value 
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 25;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }
  
  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 
     clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;  
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;  
  if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    /* Initialization Error */
    Error_Handler();
  }

  /* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported  */
  if (HAL_GetREVID() == 0x1001)
  {
    /* Enable the Flash prefetch */
    __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  }
}
/**
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
static void Error_Handler(void)
{
  /* User may add here some code to deal with this error */
  while(1)
  {
  }
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{ 
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
\endverbatim

- Right-click on <b>Source Group 1</b> and select <b>Add New Item to Group 'Source Group 1'...</b>.
- Click on <b>C File (.c)</b> and enter <b>app_main</b> in the <b>Name</b> box.
- Copy the following code into the app_main.c file:
\verbatim
#include "main.h"
#include "rl_usb.h"

#include "Board_LED.h"

#include "Driver_USART.h"
 
/* UART Driver */
extern ARM_DRIVER_USART       Driver_USART9;
#define ptrUART_USB         (&Driver_USART9)

// Main stack size must be multiple of 8 Bytes
#define APP_MAIN_STK_SZ (1024U)
uint64_t app_main_stk[APP_MAIN_STK_SZ / 8];
const osThreadAttr_t app_main_attr = {
  .stack_mem  = &app_main_stk[0],
  .stack_size = sizeof(app_main_stk)
};

static uint8_t  receive_buf[64];

/*------------------------------------------------------------------------------
 *        UART Done Callback
 *----------------------------------------------------------------------------*/
void UART_Done (uint32_t event) {
  switch (event) {
    case ARM_USART_EVENT_SEND_COMPLETE:
      // All requested data was transmitted
      LED_On(1);
      break;
    case ARM_USART_EVENT_RECEIVE_COMPLETE:
      // After 64 bytes were received, restart new reception
      ptrUART_USB->Receive (receive_buf, 64);
      LED_On(2);
      break;
  }
}

/*------------------------------------------------------------------------------
 *        Application
 *----------------------------------------------------------------------------*/
__NO_RETURN void app_main (void *arg) {
  static bool con_last = false;
         bool con;

  (void)arg;

  LED_Initialize    ();

  USBH_Initialize (0);                        /* Initialize USB Host 0        */

  while (1) {
    con = (USBH_CDC_ACM_GetStatus(0) == usbOK);
    if (con ^ con_last) {
      if (con) {
        con_last = true;
        LED_On(0);
        osDelay(1000);

        /* Initialize and configure UART <-> USB Bridge */
        ptrUART_USB->Initialize  (UART_Done);
        ptrUART_USB->PowerControl(ARM_POWER_FULL);
        ptrUART_USB->Control     (ARM_USART_MODE_ASYNCHRONOUS |
                                  ARM_USART_DATA_BITS_8       |
                                  ARM_USART_PARITY_NONE       |
                                  ARM_USART_STOP_BITS_1       |
                                  ARM_USART_FLOW_CONTROL_NONE ,
                                  115200                      );
        ptrUART_USB->Control     (ARM_USART_CONTROL_TX, 1);
        ptrUART_USB->Control     (ARM_USART_CONTROL_RX, 1);
        ptrUART_USB->Receive     (receive_buf, 64);
        ptrUART_USB->Send        ("Test!",     5);
      } else {
        con_last = false;
        LED_Off(0);
      }
    } else {
      if (con) {
        // Receive data can be checked by polling as callback will be called 
        // only when all requested number of bytes were received 
        // (in this case 64 bytes)
        if (ptrUART_USB->GetRxCount() == 5) {
          // If 5 bytes were received
        }
      }
      osDelay(1000);
    }
  }
}
\endverbatim

Before building the project, you need to edit these configuration files (in Configuration Wizard view):
- Under <b>Device</b>, double-click <b>RTE_Device.h</b> and:
  - enable <b>USB OTG Full-speed</b> and under it:
    - enable <b>Host [Driver_USBH0]</b>
    - disable <b>Host [Driver_USBH0]:Overcurrent Detection Pin</b>

- Double-click <b>USB:USBH_Config_0.h</b> and under <b>USB Host 0</b> change:
  - set <b>Maximum Pipes in system</b> to \b 4

Before building and downloading the project to the target, make sure that the correct debugger is set in the <b>Options for
Target</b> dialog (ALT + F7). You may then build and download the example project to the evaluation board using the µVision
commands:
 - \b Project --> <b> Build target (F7) </b>
 - \b Flash &nbsp;&nbsp;--> <b> Download (F8) </b>
 - \b Debug --> <b> Start/Stop Debug Session (Ctrl + F5) </b>
 - \b Debug --> <b> Run (F5) </b>

After these steps, the project should start executing on your evaluation kit.
In case of errors, refer to the Evaluation Board User's Guide for configuration information.

Using the "USB Host CDC" Project
================================

Hardware Setup
--------------
- Verify all jumper settings on the target hardware.
- Connect an USB CDC ACM Device (for example another development board with this example project: \ref dev_cdc_tutorial) to the
  development board's \b USBFS connector.
*/