/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/* Reference Section */
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/*  ==== Documentation for rl_usb.h ==== */
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//  ==== USB Device Functions ====
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/

/**
\defgroup   usbd    USB Device 
\brief      API Interface of the USB Device Component. 
\details

Refer to \ref USB_Device for more information of the USB Device Component.

\section usbd_dev_threads USB Device Threads and Function Calls
Each <b>USB Device</b> instance has a separate configuration file <b>USBD_Config_<i>n</i>.h</b>
whereby 
- <b><i>class</i></b> is the short name of the device class (ADC, CDC, HID, MSC).
- <b><i>n</i></b> refers to the instance number of the USB Device Class. 

For example, you might have 2 mass storage device instances as a part of the device. The configuration files will have the names
<b>USBD_Config_MSC_0.h</b> and <b>USBD_Config_MSC_1.h</b>. The user code will be placed in the files
<b>USBD_User_MSC_0.c</b> and <b>USBD_User_MSC_1.c</b>. 

\note Within template files, the place-holder for a device instance is marked \b \%Instance\%. Please replace \b \%Instance\%
with the corresponding device class instance number.

A configuration file defines:
- The assignment of the USB Device to a certain USB Driver, which interfaces to an USB Controller in the microcontroller.
- The USB Transfer Rate (Low-/Full- or High-speed) of the USB Device.

- <b>Device Settings</b> configure:
  - Maximum Endpoint 0 Packet Size 
  - Vendor ID: sets the vendor identification number and is required for any end product. The Vendor ID gets assigned
    by the <a href="https://www.usb.org/getting-vendor-id" target="_blank">USB-IF</a>.
    \attention It is not permitted to use the pre-defined Vendor ID (\token{0xC251}) for final products.
  - Product ID: every device variant needs an unique Product ID so that the USB Host can handle drivers for the device.
  - Device Release Number: is typically shown in the USB Host computer as "Firmware Revision". The number is 
      interpreted as "binary coded decimal", meaning that \token{0x0101} will be shown as firmware revision \token{1.01}.

- <b>Configuration Settings</b> define:
  - Power: specifies whether an USB Device is bus-powered or not.
  - Remote Wakeup: specifies whether an USB Device is capable of sending wake-up signal to the USB Host.
  - Maximum Power Consumption: if the USB Device is bus-powered, then the
    maximum power consumption must be specified. The USB Host uses this information to stay within the power limits of the
    USB bus.

- <b>String Settings</b> specify:
  - Language ID: sets the language.
  - Manufacturer String: defines the manufacturer of the USB Device
  - \anchor prod_string Product String: defines the name of the USB Device
  - Serial Number String: specifies if USB device will contain serial number string
  - Default value: specifies the default serial number of an USB device (can be empty)
  - Maximum Length (in characters): specifies the maximum number of serial number string characters that can be set during run-time

These settings are used to create \ref USB_Device_Descriptor, \ref USB_Configuration_Descriptor, and
\ref USB_Interface_Descriptor.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_coreFunctions Core
\ingroup usbd
\brief Initialize and manage the USB Device Core statically and at run-time.
\details 
The Core of the USB Device has standard functions that are used to initialize and start the USB Device. These functions must
be used before any class specific functions are called:
- Initialize the USB Device Controller, Hardware Driver and a specific USB Device using \ref USBD_Initialize.
- Connect a specific USB Device to the USB Bus by calling \ref USBD_Connect.

These two functions are accompanied by the \ref USBD_Disconnect and \ref USBD_Uninitialize functions. 
Use them to properly disconnect and uninitialize the device from the USB bus.

Static and Run-Time Configuration
---------------------------------
The USB Device Core is statically configured using the \ref usbd_coreFunctions_conf "USBD_Config_n.h" file. However,
for mass-production it is often required to be able to configure some USB Device settings at run-time (for example the serial
number which needs to be unique for every single device). To achieve this, the following device configuration functions are
part of the \ref USBD_User_Device_UCT "USBD_User_Device_n.c" user code template. They enable user specific
\ref USB_Endpoints "USB Control Endpoint 0" request handling. This allows the user to intercept all Control Endpoint 0 requests
and handle them overriding the default USB Component handling:
- \ref USBD_Devicen_Initialize is used to add device specific initialization code.
- \ref USBD_Devicen_Uninitialize is used to uninitialize the USB device.
- \ref USBD_Devicen_Reset is used to implement custom USB Device reset event handling.
- The callback function \ref USBD_Devicen_Endpoint0_InDataSent is called when the USB Device sent IN DATA on Control Endpoint
  0.
- The callback function \ref USBD_Devicen_Endpoint0_OutDataReceived is called when the USB Device received an OUT DATA
  request on Control Endpoint 0.
- The callback function \ref USBD_Devicen_Endpoint0_SetupPacketReceived is called when the USB Device Instance n received a
  SETUP PACKET on Control Endpoint 0.
- The callback function \ref USBD_Devicen_Endpoint0_SetupPacketProcessed is called when a SETUP PACKET was processed by the
  USB Component.

  
### Setup Packets on Control Endpoint 0 ###
Setup packets sent to Control Endpoint 0 are received by the USB Device Core. The USB Device Core will call the
\ref USBD_Devicen_Endpoint0_SetupPacketReceived function and pass the setup packet to it. Depending on the 
return code of \b USBD_Devicen_Endpoint0_SetupPacketReceived, the USB Device Core either passes the processing to the Custom Class 
function if custom class is used and if message is addressed to a custom class by calling 
\ref USBD_CustomClassn_Endpoint0_SetupPacketReceived function or continues to process the received setup packet itself.
Depending on the return code of \b USBD_CustomClassn_Endpoint0_SetupPacketReceived, processing of the setup packet is 
either done or continues to be processed by USB Device Core.

USB Device Core will call \ref USBD_Devicen_Endpoint0_SetupPacketProcessed and depending on return code it will call 
\ref USBD_CustomClassn_Endpoint0_SetupPacketProcessed to inform the application that setup packet has been processed by USB Device Core.

If custom handling of request was used and request contains data stage, USB Device Core will call \ref USBD_Devicen_Endpoint0_OutDataReceived and 
depending on return code it will call \ref USBD_CustomClassn_Endpoint0_OutDataReceived after data expected by request was received, it will call 
\ref USBD_Devicen_Endpoint0_InDataSent and depending on return code it will call \ref USBD_CustomClassn_Endpoint0_InDataSent 
after data expected by request was sent.

\msc
 a [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osPriorityAboveNormal",  textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                         textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers", textbgcolour="#E0E0FF"],
 c note c [label="USB Bus",                             textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 c box c  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];

 ...;
 c box c  [label="SETUP packet"],
 b box b  [label="USBD_Devicen_Endpoint0_SetupPacketReceived\n(no data stage)", URL="\ref USBD_Devicen_Endpoint0_SetupPacketReceived"];
 c box c  [label="OUT ZLP"];

 ...;
 c box c  [label="SETUP packet"],
 b box b  [label="USBD_Devicen_Endpoint0_SetupPacketReceived\n(data from device to host)", URL="\ref USBD_Devicen_Endpoint0_SetupPacketReceived"];

 ...;
 c box c  [label="IN data sent"],
 b box b  [label="USBD_Devicen_Endpoint0_InDataSent", URL="\ref USBD_Devicen_Endpoint0_InDataSent"];
 c box c  [label="OUT ZLP"];

 ...;
 c box c  [label="SETUP packet"],
 b box b  [label="USBD_Devicen_Endpoint0_SetupPacketReceived\n(data from host to device)", URL="\ref USBD_Devicen_Endpoint0_SetupPacketReceived"];

 ...;
 c box c  [label="OUT data received"],
 b box b  [label="USBD_Devicen_Endpoint0_OutDataReceived", URL="\ref USBD_Devicen_Endpoint0_OutDataReceived"];
 c box c  [label="IN ZLP"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 c box c  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create a USB Device":
  - Select required USB Device Class during the \ref RTE_Software_Component_Selection.
  - Set the static USB Device parameters in the configuration file \ref usbd_coreFunctions_conf "USBD_Config_n.h".
  - Implement the application and run-time specific behavior using \ref USBD_User_Device_UCT "USBD_User_Device_n.c".

\anchor UCT_USBD_User_Device
\b User \b Code \b Templates
\n There are two user code templates available that help to configure the USB Device at run-time:
-# \ref USBD_User_Device_UCT "USBD_User_Device_n.c" contains all the callback functions that need to be implemented by the
   user.
-# \ref USBD_User_Device_SerNum_UCT "USBD_User_Device_SerNum_n.c" is a code template that creates a custom serial number for
   a USB Device. This serial number will override the one that is set in the \ref usbd_coreFunctions_conf "USBD_Config_n.h"
   file.

\anchor USBD_User_Device_UCT
<b>User Code Template USBD_User_Device_n.c</b>

The following source code can be used to implement the application specific behavior of a USB Device.

\include "USBD_User_Device.c"

\anchor USBD_User_Device_SerNum_UCT
<b>User Code Template USBD_User_Device_SerNum_n.c</b>

The following source code can be used to set an application specific serial number for the USB Device.

\include "USBD_User_Device_SerNum.c"
*/


/**
\defgroup usbd_coreFunctions_api User API
\ingroup usbd_coreFunctions
\brief User API reference of the USB Device Core.
\details
For a general function overview refer to the section \ref usbd_coreFunctions.
*/

/**
\addtogroup usbd_coreFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_GetVersion (void)

\details
The function \b USBD_GetVersion retrieves version of the USB Device Component.

Version is encoded as follows:
 - decimal digits 9..7: major
 - decimal digits 6..4: minor
 - decimal digits 3..0: patch

\note Example: value 10020003 decimal represents version: major = 1, minor = 2, patch = 3
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_Initialize (uint8_t device)
\details
The function \b USBD_Initialize initializes the USB Device Controller Core and Hardware Driver (such as the USB clock and
pins). It starts all the tasks and sets up the main USB interrupt service routine. In any application, the \b USBD_Initialize
function must be called before invoking any other USB Device function. The function does not initialize any non-USB hardware
features.

The argument \a device specifies the instance of the USB Device.

<b>Code Example</b>
\code
#include "rl_usb.h"
  
__NO_RETURN void app_main (void *arg) {
  ...
  USBD_Initialize (0);       // USB Device 0 Initialization
  USBD_Connect    (0);       // USB Device 0 Connect       
  ...
  for (;;) {
    ...
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/

/**
\fn usbStatus USBD_Uninitialize (uint8_t device)
\details
De-initialize the USB Device Controller Core and Hardware Driver. Invoke this function when USB is not to be used any more.

The argument \a device specifies the instance of the USB Device.

*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_Connect (uint8_t device)
\details
The function \b USBD_Connect connects the USB Device to the USB Bus. This typically initiates the enumeration on the USB
Host side for the USB Device.

The argument \a device specifies the instance of the USB Device.

<b>Code Example</b>
\code
#include "rl_usb.h"
  
__NO_RETURN void app_main (void *arg) {
  ...
  USBD_Initialize (0);       // USB Device 0 Initialization
  USBD_Connect    (0);       // USB Device 0 Connect       
  ...
  for (;;) {
    ...
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_Disconnect (uint8_t device)

\details
The function \b USBD_Disconnect disconnects the USB Device from the USB Bus. After executing this function the USB Device
can no longer be accessed from the USB Host.

The argument \a device specifies the instance of the USB Device.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_Configured (uint8_t device)
\details
The function \b USBD_Configured retrieves the configuration status of the USB Device. It determines whether the USB Device
has been configured and is ready to communicate.

The argument \a device specifies the instance of the USB Device.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_STATE USBD_GetState (uint8_t device)
\details
The function \b USBD_GetState retrieves the bus state of the USB Device. It determines whether the USB Device
has valid VBUS, on which speed it was enumerated and if it is active on the bus.

The argument \a device specifies the instance of the USB Device.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_SetSerialNumber (uint8_t device, const char *string)
\details
The function \b USBD_SetSerialNumber is used to set Serial Number String of the USB Device during run-time.
This function should be called before USBD_Connect function.

The argument \a device specifies the instance of the USB Device.

The argument \a string is a pointer to the new string to be used for Serial Number.
  
<b>Code Example</b>
\code
#include "rl_usb.h"
  
__NO_RETURN void app_main (void *arg) {
  ...
  USBD_Initialize      (0);          // USB Device 0 Initialization
  USBD_SetSerialNumber (0, "1234");  // USB Device 0 new Serial Number
  USBD_Connect         (0);          // USB Device 0 Connect       
  ...
  for (;;) {
    ...
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Initialize (void)
\details
If available, the function \b USBD_Devicen_Initialize is called automatically upon initialization of the USB Device and needs no invocation in the user code. Modify this function for custom USB Device handling. This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".


<b>Code Example</b>
\code
#include "rl_usb.h"
 
int main (void)  {
  ..
  USBD_Initialize (0);   // USB Device 0 Initialization calls USBD_Devicen_Initialize() automatically
  USBD_Connect (0);      // USB Device 0 Connect
  ..
}
\endcode
*/

 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Uninitialize (void)
\details
If available, the function \b USBD_Devicen_Uninitialize is called automatically upon un-initialization of the USB Device and
needs no invocation in the user code. Modify this function for custom USB Device handling. This function can be found in the
user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".


<b>Code Example</b>
\code
#include "rl_usb.h"
 
int main (void)  {
  ..
  USBD_Initialize (0);   // USB Device 0 Initialization 
  ..
  USBD_Uninitialize (0); // USB Device 0 Un-Initialization calls USBD_Devicen_Uninitialize() automatically
  ..
}
\endcode  
*/

 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_VbusChanged (bool level)
\details
The callback function \b USBD_Devicen_VbusChanged is called when the state of the VBUS pin of the USB Device Instance \a n 
changes level.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".

*/
 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Reset (void)
\details
The callback function \b USBD_Devicen_Reset is called when reset signaling was detected by the USB Device Instance \a n.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/
 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_HighSpeedActivated (void)
\details
The callback function \b USBD_Devicen_HighSpeedActivated is called when the bus speed of the USB Device Instance \a n 
changes to high speed.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Suspended (void)
\details
The callback function \b USBD_Devicen_Suspended is called when bus of the USB Device Instance \a n was suspended (no SOFs 
for 3 ms).

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Resumed (void)
\details
The callback function \b USBD_Devicen_Resumed is called when bus activity has been resumed by the USB Device Instance \a n.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_ConfigurationChanged (uint8_t val)
\details
The callback function \b USBD_Devicen_ConfigurationChanged is called when the USB Device Instance \a n was requested by the USB Host 
to change the configuration.

The argument \a val specifies the activated configuration.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_EnableRemoteWakeup (void)
\details
The callback function \b USBD_Devicen_EnableRemoteWakeup is called when the USB Device Instance \a n receives Set Feature 
request on the Control Endpoint 0 to enable remote wakeup feature on the device.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_DisableRemoteWakeup (void)
\details
The callback function \b USBD_Devicen_DisableRemoteWakeup is called when the USB Device Instance \a n receives Clear Feature 
request on the Control Endpoint 0 to disable remote wakeup feature on the device.

This function can be modified in the user code template file \ref USBD_User_Device_UCT "USBD_User_Device_n.c".
*/

 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_Devicen_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len)
\details
The callback function \b USBD_Devicen_Endpoint0_SetupPacketReceived is called when the USB Device Instance \a n received a
SETUP PACKET on Control Endpoint 0.

The argument \a setup_packet is a pointer to the received setup packet.

The argument \a buf is a pointer to the data buffer that is used for data stage requested by setup packet.

The argument \a len is a pointer to the number of data bytes in the data stage requested by setup packet.

This function can be modified in the user code template file <b> USBD_User_Device_<i>n</i>.c</b>.

\b Code \b Example
\code
usbdRequestStatus USBD_Device0_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len) {
 
  switch (setup_packet->bmRequestType.Type) {
    case USB_REQUEST_STANDARD:
      if ((setup_packet->bmRequestType.Dir       == USB_REQUEST_DEVICE_TO_HOST) && 
          (setup_packet->bmRequestType.Recipient == USB_REQUEST_TO_DEVICE     ) && 
          (setup_packet->bRequest                == USB_REQUEST_GET_DESCRIPTOR) && 
          (setup_packet->wValueH                 == USB_DEVICE_DESCRIPTOR_TYPE) && 
          (setup_packet->wIndex                  == 0                         )) {
        *buf = (uint8_t *)device%Instance%_dev_desc;
        *len = sizeof    (device%Instance%_dev_desc);
        return usbdRequestOK;
      }
      break;
    case USB_REQUEST_CLASS:
      break;
    case USB_REQUEST_VENDOR:
      break;
    case USB_REQUEST_RESERVED:
      break;
  }
 
  return usbdRequestNotProcessed;
}
\endcode
*/
 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_Devicen_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet)
\details
The callback function \b USBD_Devicen_Endpoint0_SetupPacketProcessed is called when a SETUP PACKET was processed by the USB
Component.

The argument \a setup_packet is a pointer to the processed setup packet.

This function can be modified in the user code template file <b> USBD_User_Device_<i>n</i>.c</b>.

\b Code \b Example
\code
void USBD_Device0_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet) {
 
  switch (setup_packet->bmRequestType.Type) {
    case USB_REQUEST_STANDARD:
      break;
    case USB_REQUEST_CLASS:
      break;
    case USB_REQUEST_VENDOR:
      break;
    case USB_REQUEST_RESERVED:
      break;
  }
}
\endcode
*/
 
 
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_Devicen_Endpoint0_OutDataReceived (uint32_t len)
\details
The callback function \b USBD_Devicen_Endpoint0_OutDataReceived is called when the USB Device received an OUT DATA on
Control Endpoint 0.

The argument \a len specifies the number of received data bytes.

This function can be modified in the user code template file <b> USBD_User_Device_<i>n</i>.c</b>.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_Devicen_Endpoint0_InDataSent (uint32_t len)
\details
The callback function \b USBD_Devicen_Endpoint0_InDataSent is called when the USB Device sent IN DATA on Control Endpoint 0.

The argument \a len specifies the number of sent data bytes.

This function can be modified in the user code template file <b> USBD_User_Device_<i>n</i>.c</b>.
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_coreFunctions_conf Configuration
\ingroup usbd_coreFunctions
\brief Configuration of the USB Device Core.
\details
The configuration file <b>USBD_Config_<i>n</i>.h</b> contains generic settings for the USB Device and parameters that are
necessary to create \ref USB_Descriptors . Some parts of the USB descriptors are configured in the respective device class
configuration files (\ref usbd_adcFunctions_conf "USBD_Config_ADC.h", \ref usbd_cdcFunctions_acm_conf "USBD_Config_CDC.h",
\ref usbd_classFunctions_conf "USBD_Config_CustomClass.h", \ref usbd_hidFunctions_conf "USBD_Config_HID.h" and
\ref usbd_mscFunctions_conf "USBD_Config_MSC.h").

\image  html usbd_config_0_h.png "USB Device Core Configuration File"

The configuration file <b>USBD_Config_<i>n</i>.h</b> contains the following settings:
- <b>Connect to hardware via Driver_USBD#</b> sets the \b CMSIS-Driver \b Number to be used (according to the selected USB
  controller). For devices with single USB Device Controller it will typically be '0'.
- \b High-Speed may be selected if supported by the USB controller.
- <b>Device Settings</b> are used to create the \ref USB_Device_Descriptor.
  - <b>Max Endpoint 0 Packet Size</b> sets the maximum packet size for Endpoint 0.
  - The <b>Vendor ID</b> (VID) needs to be set to a private VID. The default Vendor ID is owned by Keil and must not be used
    for actual products. Please visit <a class="el" href="https://www.usb.org/getting-vendor-id" target="_blank">USB-IF</a>
    for more information on how to apply for a valid Vendor ID.
  - Every device variant needs an unique <b>Product ID</b>. Together with the \b VID, it is used by the Host computer's
    operating system to find a driver for your device.
  - The <b>Device Release Number</b> will be shown in Windows and Linux systems as “Firmware Revision”. The number will
    be interpreted as “binary coded decimal”, meaning that 0x0101 will be shown as firmware revision 1.01.
- <b>Configuration Settings</b> are used to create the \ref USB_Configuration_Descriptor.
  - <b>Power</b> determines whether the device is self- or bus-powered.
  - Enable <b>Remote Wakeup</b> if the device supports a remote wakeup functionality.
  - <b>Maximum Power Consumption (in mA)</b> advertises the maximum current drawn from the bus in this specific
    configuration when the USB Device is fully operational.
- <b>String Settings</b> are used to create the string descriptor within the \ref USB_Device_Descriptor.
  - <b>Language ID</b> set the product's language.
  - <b>Manufacturer String</b> describes the product's manufacturer.
  - <b>Product String</b> describes the product.
  - Enable <b>Serial Number String</b> to be able to assign a serial number string to the product.
    - <b>Default value</b> describes the device's default serial number string when enabled.
    - <b>Maximum Length (in characters)</b> describes the maximum number of serial number string characters that can be set at run-time.
- <b>Microsoft OS Descriptor Settings</b> are used to create the <a class="el" href="https://learn.microsoft.com/en-us/previous-versions/gg463179(v=msdn.10)" target="_blank">Microsoft OS Descriptors</a>.
  - Enable <b>OS String</b> for device to contain Microsoft OS string descriptor.
    - <b>Vendor Code</b> specifies the vendor code used to retrieve associated feature descriptors.
- <b>Control Transfer Buffer Size</b> specifies the maximum size of control transfer.
- <b>Data Buffers</b> is used for locating the USB data buffers in memory.
  - <b>Locate</b> specifies if the USB data buffers are located in a specific memory (via the linker script).
    This is usually necessary in case that USB Controller has some specific requirements regarding memory for USB transfers.
    For example if USB Controller can only access specific memory, or if this memory needs to be non-cacheable.
  - <b>Section Name</b> specifies the section name for the USB data buffers that is used by the linker script to position it in memory.
    Default section name is <c>.driver.usbd<instance></c>, for example for USB Device 0 the default section name is <c>.driver.usbd0</c>.
- Use the <b>OS Resources Settings</b> to optimize the usage of OS resources.
  - The default <b>Core Thread Stack Size</b> is \a 1024 bytes.
  - The default Core Thread priority is <b>osPriorityAboveNormal</b>.
    This priority can be changed by changing USBD<i>n</i>_CORE_THREAD_PRIORITY define in this configuration file.
    This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
    Due to this requirement it is recommended to keep this setting at default.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_DevClassFunctions Device Class
\ingroup usbd
\brief Implement application specific behavior of USB Device classes.
\details
To be USB standard compliant, the various USB Device classes have the need for USB Device class specific functionality, reflecting
the individual technical requirements of each class. In addition, you might need to change the standard behavior to suit
your application's needs.
\n This application specific behavior can be added in so called \urlout{uv4_ca_sourcefiles}.
They are available for every supported USB Device class in the USB Middleware. They provide pre-defined functions for USB
Device class functionality. Applying changes to these routines will add further functionality, that is required in a certain application.
The general functionality is explained in the sections above for each USB Device class.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_adcFunctions_api User API
\ingroup usbd_adcFunctions
\brief User API reference of the Audio Device Class.
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_adcFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_Initialize (void);
\details
The function \b USBD_ADCn_Initialize initializes the hardware resources of the Audio Device Class USB Device. It is called
during \ref USBD_Initialize. The function may be used to allocate resources and initialize peripherals.

Modify this function to the application's needs.

<b>Code Example</b>
\code
void USBD_ADC0_Initialize (void) {
  USBD_ADC_SetSpeakerVolumeRange    (0, 0, 0, 100, 1, 50);
  USBD_ADC_SetMicrophoneVolumeRange (0, 0, 0, 100, 1, 50);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_Uninitialize (void);
\details
The function \b USBD_ADCn_Uninitialize de-initializes/releases the hardware resources of the Audio Device Class USB Device.
It is called during \ref USBD_Uninitialize. If \ref USBD_ADCn_Initialize has been adapted to the application,
\b USBD_ADCn_Uninitialize should release resources and de-initialize peripherals.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_PlayStart (void);
\details
The callback function \b USBD_ADCn_PlayStart is called when a playback was started by the USB Host.

<b>Code Example</b>
\code
void USBD_ADC0_PlayStart (void) {
  Audio_Start (AUDIO_STREAM_OUT);     // Start playback audio stream
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_PlayStop (void);
\details
The callback function \b USBD_ADCn_PlayStart is called when a playback was stopped by the USB Host.

<b>Code Example</b>
\code
void USBD_ADC0_PlayStop (void) {
  Audio_Stop (AUDIO_STREAM_OUT);      // Stop playback audio stream
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_SetSpeakerMute (uint8_t ch, bool on);
\details
The callback function \b USBD_ADCn_SetSpeakerMute is called when the speaker mute setting was changed by the USB Host.

The argument \a ch specifies the channel that is used.

The argument \a on specifies the activated mute setting.

<b>Code Example</b>
\code
void USBD_ADC0_SetSpeakerMute (uint8_t ch, bool on) {
  if (on) {
    // start scaling samples to 0
  } else {
    // start scaling samples to volume
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_SetSpeakerVolume (uint8_t ch, uint16_t vol);
\details
The callback function \b USBD_ADCn_SetSpeakerVolume is called when the speaker volume setting was changed by the USB Host.

The argument \a ch specifies the channel that is used.

The argument \a vol specifies the changed volume setting.

<b>Code Example</b>
\code
void USBD_ADC0_SetSpeakerVolume (uint8_t ch, uint16_t vol) {
  // store new volume and use it for scaling samples
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_RecordStart (void);
\details
The callback function \b USBD_ADCn_RecordStart is called when a recording was started by the USB Host.

<b>Code Example</b>
\code
void USBD_ADC0_RecordStart (void) {
  Audio_Start (AUDIO_STREAM_IN);      // Start recording audio stream
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_RecordStop (void);
\details
The callback function \b USBD_ADCn_RecordStop is called when a recording was stopped by the USB Host.

<b>Code Example</b>
\code
void USBD_ADC0_RecordStop (void) {
  Audio_Stop (AUDIO_STREAM_IN);       // Stop recording audio stream
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_SetMicrophoneMute (uint8_t ch, bool on);
\details
The callback function \b USBD_ADCn_SetMicrophoneMute is called when the microphone mute setting was changed by 
the USB Host.

The argument \a ch specifies the channel that is used.

The argument \a on specifies the activated mute setting.

<b>Code Example</b>
\code
void USBD_ADC0_SetMicrophoneMute (uint8_t ch, bool on) {
  if (on) {
    // start scaling samples to 0
  } else {
    // start scaling samples to volume
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_SetMicrophoneVolume (uint8_t ch, uint16_t vol);
\details
The callback function \b USBD_ADCn_SetMicrophoneVolume is called when the microphone volume setting was changed by 
the USB Host.

The argument \a ch specifies the channel that is used.

The argument \a vol specifies the changed volume setting.

<b>Code Example</b>
\code
void USBD_ADC0_SetMicrophoneVolume (uint8_t ch, uint16_t vol) {
  // store new volume and use it for scaling samples
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBD_ADCn_ReceivedSamples (void)

\details
The function \b USBD_ADCn_ReceivedSamples notifies that half of USB buffer for audio samples has been received starting
from empty buffer.

Modify this function to the application needs.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_ADC_SetSpeakerVolumeRange (uint8_t instance, uint8_t ch, uint16_t min, uint16_t max, uint16_t res, uint16_t cur);
The function \b USBD_ADC_SetSpeakerVolumeRange sets the range for the speaker volume control.

The argument \a instance specifies the instance of the ADC class to be used.

The argument \a ch specifies the channel on the \a instance.

The argument \a min sets the minimum volume level.

The argument \a max sets the maximum volume level.

The argument \a res defines the volume resolution.

The argument \a cur sets the current volume level.

<b>Code Example</b>
\code
USBD_ADC_SetSpeakerVolumeRange (0, 0, 0, 100, 1, 50);
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_ADC_SetMicrophoneVolumeRange (uint8_t instance, uint8_t ch, uint16_t min, uint16_t max, uint16_t res, uint16_t cur);
The function \b USBD_ADC_SetMicrophoneVolumeRange sets the range for the microphone volume control.

The argument \a instance specifies the instance of the ADC class to be used.

The argument \a ch specifies the channel on the \a instance.

The argument \a min sets the minimum volume level.

The argument \a max sets the maximum volume level.

The argument \a res defines the volume resolution.

The argument \a cur sets the current volume level.

<b>Code Example</b>
\code
USBD_ADC_SetMicrophoneVolumeRange (0, 0, 0, 100, 1, 50);
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn  uint32_t USBD_ADC_ReceivedSamplesAvailable (uint8_t instance);
The function \b USBD_ADC_ReceivedSamplesAvailable signals the number of audio samples that have been received from the USB
Host and are available to be read.

The argument \a instance specifies the instance of the ADC class to be used.

<b>Code Example</b>
\code
uint16_t spkr_data[1024];
 
if (USBD_ADC_ReceivedSamplesAvailable(0) > 1024) {
  // If number of samples available is more than 1024 read new samples
  USBD_ADC_ReadSamples (0, (void *)spkr_data, 1024);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn  uint32_t USBD_ADC_WrittenSamplesPending (uint8_t instance);
The function \b USBD_ADC_WrittenSamplesPending signals the number of audio samples that were written and are pending. 
These signals must be still sent to the USB Host.

The argument \a instance specifies the instance of the ADC class.

\sa \ref USBD_ADC_WriteSamples

<b>Code Example</b>
\code
uint16_t mic_data[1024];
 
if (USBD_ADC_WrittenSamplesPending(0) < 1024) {
  // If number of samples pending is below 1024 write more samples
  USBD_ADC_WriteSamples (0, (void *)mic_data, 1024);
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn  int32_t USBD_ADC_ReadSamples (uint8_t instance, void *buf, int32_t num);
The function \b USBD_ADC_ReadSamples reads audio samples that have been received from an USB Host.

The argument \a instance specifies the instance of the ADC class to be used.

The argument \a buf is a pointer to the buffer that stores the received samples.
The data type is \em uint8_t, \em uint16_t or \em uint32_t and is specified by the USBD_ADCn_OUT_BBITRESOLUTION in USBD_Config_ADC_n.h file
(USBD_ADCn_OUT_BBITRESOLUTION = 8 -> \em uint8_t, USBD_ADCn_OUT_BBITRESOLUTION = 16 -> \em uint16_t, USBD_ADCn_OUT_BBITRESOLUTION >= 24 -> \em uint32_t).

If stereo mode is used channels are encoded one sample per channel (sample 0 = L0, sample 1 = R0, sample 2 = L1, sample 3 = R1, ...)

The argument \a num specifies the maximum number of samples to be read.

<b>Code Example</b>
\code
uint16_t spkr_data[1024];
  
USBD_ADC_ReadSamples (0, (void *)spkr_data, 1024);
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn  int32_t USBD_ADC_WriteSamples (uint8_t instance, const void *buf, int32_t num)
The function \b USBD_ADC_WriteSamples writes audio samples to be transferred to an USB Host.

The argument \a instance specifies the instance of the ADC class to be used.

The argument \a buf is a pointer to the buffer containing the samples to be written.
The data type is \em uint8_t, \em uint16_t or \em uint32_t and is specified by the USBD_ADCn_IN_BBITRESOLUTION in USBD_Config_ADC_n.h file
(USBD_ADCn_IN_BBITRESOLUTION = 8 -> \em uint8_t, USBD_ADCn_IN_BBITRESOLUTION = 16 -> \em uint16_t, USBD_ADCn_IN_BBITRESOLUTION >= 24 -> \em uint32_t).

If stereo mode is used, channels are encoded one sample per channel (sample 0 = L0, sample 1 = R0, sample 2 = L1, sample 3 = R1, ...)

The argument \a num specifies the maximum number of samples to be written.

\note USB transferring will start when half of USB buffer for audio samples has been written. 

\sa \ref USBD_ADC_WrittenSamplesPending
 
<b>Code Example</b>
\code
uint16_t mic_data[1024];
 
if (USBD_ADC_WrittenSamplesPending(0) < 1024) {
  // If number of samples pending is below 1024 write more samples
  USBD_ADC_WriteSamples (0, (void *)mic_data, 1024);
}
\endcode
*/

/**
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_adcFunctions ADC: Audio Device Class
\ingroup usbd_DevClassFunctions

\brief Implement application specific behavior of an Audio Device Class (ADC) USB Device.

\details
Use the following class specific functions to customize the functionality of an Audio Device Class (ADC) Device. Adapt these
functions in the \urlout{uv4_ca_sourcefiles} file \b USBD_User_ADC_Audio_<i>n</i>.c.

Refer to:
  - \ref ADC for an overview of the ADC class.
\if USBD_EXAMPLE_ADC
  - \ref usbd_example_adc for an example project that uses the ADC class.
\endif

The USB Component allows multiple instances of the ADC class. This feature is used to create USB Composite Devices.
Each ADC class instance has a separate files and interface functions:
  - A configuration file \ref usbd_adcFunctions_conf "USBD_Config_ADC_n.h".
  - An application-specific user source code file, which can be implemented with the \urlout{uv4_ca_sourcefiles} <b>USBD_User_ADC_Audio_<i>n</i>.c</b>.
  - Functions that start with the prefix <b>USBD_ADCn_</b> are available for each instance of an ADC class.	

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>3</i>.
Most applications only require one instance of an ADC class. For the first ADC class instance the instance number is 0:
  - <b>USBD_Config_ADC_0.h</b>
  - <b>USBD_User_ADC_Audio_0.c</b>
  - The function prefix is <b>USBD_ADC0_</b>
  
<b>Software Structure</b>

The handling for the ADC class endpoint events is implemented in \b USBD_ADCn_Thread which is started by
\ref USBD_Initialize. Each instance of an ADC class runs an instance of the \b USBD_ADCn_Thread. This thread handles the
Isochronous IN/OUT Endpoints of the USB ADC Device.

\msc
 a [label="",                                                      textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osPriorityAboveNormal",             textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_ADCn_Thread\n osPriorityAboveNormal",               textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="",                                                      textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                                    textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",            textbgcolour="#E0E0FF"],
 c note c [label="Handle ADC Isochronous IN/OUT Endpoint Events",  textbgcolour="#E0FFE0"],
 d note d [label="USB Bus",                                        textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 d box d  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];
 d box d  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];

 ...;
 a box a  [label="USBD_ADC_WriteSamples", URL="\ref USBD_ADC_WriteSamples"],
 c box c  [label="Send data"],
 d box d  [label="Isochronous IN"];

 ...;
 d box d  [label="Isochronous OUT"],
 c box c  [label="Receive data"],
 a box a  [label="USBD_ADCn_ReceivedSamples", URL="\ref USBD_ADCn_ReceivedSamples"];
 a box a  [label="USBD_ADC_ReadSamples", URL="\ref USBD_ADC_ReadSamples"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 d box d  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with an ADC class:
  - Set the required number for USB:Device:ADC class instances during the \ref RTE_Software_Component_Selection.
  - Set the parameters in the configuration file \ref usbd_adcFunctions_conf "USBD_Config_ADC_n.h".
  - Implement the application specific behavior using these \ref UCT_USBD_User_ADC "template".

\anchor UCT_USBD_User_ADC
\b User \b Code \b Templates
\n There is one user code template available that helps to add support for an ADC device:
-# \ref USBD_User_ADC_UCT "USBD_User_ADC_Audio.c" is a code template for the application specific functionality of a USB ADC Device with Audio Interface.

\anchor USBD_User_ADC_UCT
<b>User Code Template USBD_User_ADC_Audio.c</b>

The following source code can be used to implement the application specific behavior of an USB ADC Device with Audio Interface.

\include "USBD_User_ADC_Audio.c"
*/

/**
\defgroup usbd_adcFunctions_conf Configuration
\ingroup usbd_adcFunctions
\brief Configuration of the USB Device ADC Class.
\details
This configuration file defines:
- The assignment of the ADC class to the USB Device instance.
- \ref USB_Endpoints "USB Endpoint" assignments for the ADC class with parameters for Full/Low-speed communication.
- Class Settings for the Interface Descriptor.

The settings in this configuration file are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and
\ref USB_Endpoint_Descriptor "Endpoint Descriptor" of the related USB Device Class.

\image  html usbd_config_adc_h.png "ADC Class Configuration File"

The USB Device ADC Class configuration file <b>USBD_Config_ADC_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects the USB Device that is to be used for this Device Class instance.
- <b>Isochronous Endpoint Settings</b>
 - <b>Isochronous OUT Endpoint Settings</b> enables or disables settings for an
   \ref USB_Isochronous_Transfers "Isochronous" OUT \ref USB_Endpoints "Endpoint".
  - <b>Isochronous OUT Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
  - <b>Endpoint Settings</b>
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Endpoint polling Interval (in ms)</b> specifies the frequency of requests initiated by USB Host for getting audio
     samples data.
 - <b>Isochronous IN Endpoint Settings</b> enables or disables settings for an 
   \ref USB_Isochronous_Transfers "Isochronous" IN \ref USB_Endpoints "Endpoint".
  - <b>Isochronous IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
  - <b>Endpoint Settings</b>
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Endpoint polling Interval (in ms)</b> specifies the frequency of requests initiated by USB Host for getting audio
     samples data.
- <b>Audio Device Class Settings</b>
 - <b>Audio Control Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Audio Output Settings (Speaker)</b>
  - <b>Audio Streaming (Zero Bandwidth) Interface String</b> is used to create \ref USB_Descriptors.
  - <b>Audio Streaming (Operational) Interface String</b> is used to create \ref USB_Descriptors.
  - <b>Channel Configuration</b> is used for memory allocation in the USB component.
  - <b>Sample Frequency (in Hz)</b> is used for memory allocation in the USB component.
  - <b>Audio Subframe Size</b> is used for memory allocation in the USB component.
  - <b>Sample Resolution</b> is used for memory allocation in the USB component.
  - <b>Buffer Size (in samples)</b> is used for memory allocation in the USB component.
 - <b>Audio Input Settings (Microphone)</b>
  - <b>Audio Streaming (Zero Bandwidth) Interface String</b> is used to create \ref USB_Descriptors.
  - <b>Audio Streaming (Operational) Interface String</b> is used to create \ref USB_Descriptors.
  - <b>Channel Configuration</b> is used for memory allocation in the USB component.
  - <b>Sample Frequency (in Hz)</b> is used for memory allocation in the USB component.
  - <b>Audio Subframe Size</b> is used for memory allocation in the USB component.
  - <b>Sample Resolution</b> is used for memory allocation in the USB component.
  - <b>Buffer Size (in samples)</b> is used for memory allocation in the USB component.
- <b>OS Resource Settings</b>
 - <b>Audio Device Class Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Audio Device Class Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_ADC<i>n</i>_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_cdcFunctions_acm CDC: Communication Device Class (ACM)
\ingroup usbd_DevClassFunctions

\brief Implement application specific behavior of a Communication Device Class (CDC) USB Device using the sub-class Abstract
Control Model (ACM).

\details
The CDC (ACM) class in the USB Component is used for data communication. You can typically use it in applications that previously
used a serial COM or UART communication.

Refer to:
  - \ref CDC for an overview of the CDC class.
  - \ref usbd_example_cdc example project.

The USB Component allows multiple instances of the CDC class. This feature is used to create USB Composite Devices.
Each CDC class instance has a separate files and interface functions:
  - A CDC configuration file \ref usbd_cdcFunctions_acm_conf "USBD_Config_CDC_n.h".
  - An application-specific user source code file, which can be implemented with the \urlout{uv4_ca_sourcefiles} \ref USBD_User_CDC_ACM_UCT "USBD_User_CDC_ACM_n.c".
  - Functions that start with the prefix <b>USBD_CDCn_ACM</b> are available for each instance of a CDC ACM class.

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>7</i>.
Most applications only require one instance of a CDC ACM class. For the first CDC ACM class instance the instance number is 0:
  - <b>USBD_Config_CDC_0.h</b>
  - <b>USBD_User_CDC_ACM_0.c</b>
  - The function prefix is <b>USBD_CDC0_ACM</b>

\b Descriptor \b Requirements

The following descriptors are required in an USB CDC ACM Device:
- Standard Device Descriptor
- Standard Configuration Descriptor
- Interface Association Descriptor
- CDC Header Functional Descriptor
- CDC Union Functional Descriptor
- Call Management Functional Descriptor
- Abstract Control Management Functional Descriptor
- Standard Interface Descriptor for the CDC Class communication interface
- Standard Endpoint Descriptor for Interrupt IN endpoint
- Standard Interface Descriptor for the CDC Class data interface
- Standard Endpoint Descriptors for Bulk IN and Bulk OUT endpoints

The necessary descriptors are automatically generated by the USB Middleware Component. The page \ref USB_Descriptors provides
more information on the topic.

<b>Software Structure</b>

The handling for the CDC class endpoint events is implemented in \b USBD_CDCn_Int_Thread and \b USBD_CDCn_Bulk_Thread which are started by
\ref USBD_Initialize. Each instance of a CDC class runs an instance of \b USBD_CDCn_Int_Thread and \b USBD_CDCn_Bulk_Thread.

The thread USBD_CDCn_Int_Thread handles Interrupt IN Endpoint whereas the USBD_CDCn_Bulk_Thread handles the Bulk IN and Bulk OUT Endpoints.

\msc
 a [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osPriorityAboveNormal",      textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_CDCn_Int_Thread\n osPriorityAboveNormal",   textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="USBD_CDCn_Bulk_Thread\n osPriorityAboveNormal",  textcolor="green",  linecolor="green",  arclinecolor="green"],
 e [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                             textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",     textbgcolour="#E0E0FF"],
 c note c [label="Handle CDC Interrupt IN Endpoint Events", textbgcolour="#E0FFE0"],
 d note d [label="Handle CDC Bulk IN/OUT Endpoint Events",  textbgcolour="#E0FFE0"],
 e note e [label="USB Bus",                                 textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 e box e  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];
 e box e  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];

 ...;
 a box a  [label="USBD_CDC_ACM_Notify_SerialState", URL="\ref USBD_CDC_ACM_Notify_SerialState"],
 c box c  [label="Send modem line and error status change notification"],
 e box e  [label="Interrupt IN"];

 ...;
 a box a  [label="USBD_CDC_ACM_WriteData", URL="\ref USBD_CDC_ACM_WriteData"],
 d box d  [label="Send data"],
 e box e  [label="Bulk IN"];
 a box a  [label="USBD_CDCn_ACM_DataSent", URL="\ref USBD_CDCn_ACM_DataSent"];

 ...;
 d box d  [label="Received data"],
 a box a  [label="USBD_CDCn_ACM_DataReceived", URL="\ref USBD_CDCn_ACM_DataReceived"],
 e box e  [label="Bulk OUT"];

 a box a  [label="USBD_CDC_ACM_ReadData", URL="\ref USBD_CDC_ACM_ReadData"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 e box e  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with a CDC ACM class:
  - Set the required number for USB:Device:CDC class instances during the \ref RTE_Software_Component_Selection.
  - Set the parameters in the configuration file \ref usbd_cdcFunctions_acm_conf "USBD_Config_CDC_n.h".
  - Implement the application specific behavior using one of the following templates.

\anchor USBD_User_CDC_ACM_UCT
<b>User Code Template USBD_User_CDC_ACM_n.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (ACM) Device.

\include "USBD_User_CDC_ACM.c"

\anchor USBD_User_CDC_ACM_UART_UCT
<b>User Code Template USBD_User_CDC_ACM_UART_n.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (ACM) Device that can be used as a USB <-> UART bridge.

\include "USBD_User_CDC_ACM_UART.c"

\anchor USBD_User_CDC_ACM_RNDIS_VETH_UCT
<b>User Code Template USBD_User_CDC_ACM_RNDIS_VETH_n.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (ACM) Device that can be used for virtual Ethernet using the RNDIS protocol.

\include "USBD_User_CDC_ACM_RNDIS_VETH.c"

\anchor USBD_User_CDC_ACM_RNDIS_ETH_UCT
<b>User Code Template USBD_User_CDC_ACM_RNDIS_ETH_n.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (ACM) Device that can be used as a USB <-> Ethernet bridge using the RNDIS protocol.

\include "USBD_User_CDC_ACM_RNDIS_ETH.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_cdcFunctions_acm_api User API
\ingroup usbd_cdcFunctions_acm
\brief User API reference of the Communication Device Class (ACM).
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_cdcFunctions_acm_api
@{
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_ACM_Initialize (void)
\details
The function \b USBD_CDCn_ACM_Initialize initializes the hardware resources of the port used as the Virtual COM Port.
It is called during \ref USBD_Initialize. The function may be used to allocate resources and initialize peripherals.

Modify this function to the application's needs.

\note Remember to release used resources and de-initialize peripherals using \ref USBD_CDCn_ACM_Uninitialize.

<b>Code Example</b>
\n The following code initializes an UART that is mapped as the Virtual COM Port to the CDC class. 
\code
bool USBD_CDCn_ACM_Initialize (void) {
 
  UART_Initialize ();
}  
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_ACM_Uninitialize (void)
\details
The function \b USBD_CDCn_ACM_Uninitialize de-initializes/releases the hardware resources of the port used as the Virtual
COM Port. It is called during \ref USBD_Uninitialize. If \ref USBD_CDCn_ACM_Initialize has been adapted to the application,
\b USBD_CDCn_ACM_Uninitialize should release resources and should de-initialize peripherals.
  
<b>Code Example</b>
\code
bool USBD_CDCn_ACM_Uninitialize (void) {
 
  UART_Uninitialize ();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_ACM_Reset (void)
\details
The function \b USBD_CDCn_ACM_Reset resets the internal states of the port used as the Virtual COM Port.

Modify this function to the application's needs.

<b>Code Example</b>
\n The following code resets an UART that is mapped as the Virtual COM Port to the CDC class. 
\code
void USBD_CDCn_ACM_Reset (void) {
 
  UART_Reset ();
}  
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_ACM_SendEncapsulatedCommand (const uint8_t *buf, uint16_t len)
\details
The function \b USBD_CDCn_ACM_SendEncapsulatedCommand is used for transferring data from USB Host to standard 
CDC ACM USB Device, and content of data is specified by protocol used.
This command is used for RNDIS device in which case protocol is Vendor-specific and specified by 
Remote Network Driver Interface Specification.

The argument \a buf is a pointer to the encapsulated command request received by the USB Device.

The argument \a len is number of bytes, that encapsulated command data contains, and is available for reading.

Modify this function to the application needs.

\note Callback when Send Encapsulated Command request comes on Control Endpoint 0. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_ACM_GetEncapsulatedResponse (uint16_t max_len, uint8_t **buf, uint16_t *len)
\details
The function \b USBD_CDCn_ACM_GetEncapsulatedResponse is used for transferring data from standard CDC ACM USB Device to 
USB Host, and content of data is specified by protocol used.
This command is used for RNDIS device in which case protocol is Vendor-specific and specified by 
Remote Network Driver Interface Specification.

The argument \a max_len is a maximum number of bytes that USB Host expects to receive.

The argument \a buf is a pointer to the buffer containing response to get encapsulated response request to be sent by the 
USB Device.

The argument \a len is a pointer to number of bytes, that encapsulated response data contains, and will be returned to 
USB Host.

Modify this function to the application needs.

\note Callback when Get Encapsulated Response request comes on Control Endpoint 0.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_ACM_SetLineCoding (const CDC_LINE_CODING *line_coding)
\details
The function \b USBD_CDCn_ACM_SetLineCoding changes communication settings of the port used as the Virtual COM Port.

The argument \a line_coding is a pointer to the CDC Line Coding structure containing the requested coding settings.

Modify this function to the application needs.

\note Callback when Set Line Coding request comes on Control Endpoint 0. 

<b>Code Example</b>
\n The following code configures an UART that is mapped as the Virtual COM Port to the CDC class. 
\code
void USBD_CDCn_ACM_SetLineCoding (const CDC_LINE_CODING *line_coding) {
 
  UART_Config.Baudrate    = line_coding->dwDTERate;
  UART_Config.DataBits    = (UART_DataBits) line_coding->bDataBits;
  UART_Config.Parity      = (UART_Parity)   line_coding->bParityType;
  UART_Config.StopBits    = (UART_StopBits) line_coding->bCharFormat;
  UART_Config.FlowControl = UART_FLOW_CONTROL_RTS_CTS;
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_ACM_GetLineCoding (CDC_LINE_CODING *line_coding)
\details
The function \b USBD_CDCn_ACM_GetLineCoding retrieves communication settings of the port used as the Virtual COM Port.

The argument \a line_coding is a pointer to the CDC Line Coding structure containing coding settings.

Modify this function to the application needs.

\note Callback when Get Line Coding request comes on Control Endpoint 0.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_ACM_SetControlLineState (uint16_t state)

\details
The function \b USBD_CDCn_ACM_SetControlLineState sets control line state on the port used as the Virtual COM Port.

The argument \a state represents control signal bitmap (0. bit - DTR line state, 1. bit - RTS line state).

Modify this function to the application needs.

\note Callback when Set Control Line State request comes on Control Endpoint 0. 

<b>Code Example</b>
\n The following code outputs the line state to LEDs. 
\code
void USBD_CDCn_ACM_SetControlLineState (uint16_t state) {
 
  ((state & 1) ? (LED_On (0)) : (LED_Off (0)));
  ((state & 2) ? (LED_On (1)) : (LED_Off (1)));
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_ACM_DataReceived (uint32_t len)

\details
The function \b USBD_CDCn_ACM_DataReceived notifies that there is newly received data available.

The argument \a len is number of bytes available to read.

Modify this function to the application needs.

\note Callback when new data is received on Bulk OUT Endpoint.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_ACM_DataSent (void)

\details
The function \b USBD_CDCn_ACM_DataSent notifies that all data was sent.

\note Callback when all data was sent on Bulk IN Endpoint.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_ACM_WriteData (uint8_t instance, const uint8_t *buf, int32_t len)

\details
The function \b USBD_CDC_ACM_WriteData asynchronously prepares data that will be returned to the USB Host upon request.

The argument \a instance specifies the CDC class instance that is to be used.

The argument \a buf is a pointer to the buffer containing the data to be written.

The argument \a len specifies the number of bytes to be written.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int USBD_CDC_ACM_PutChar (uint8_t instance, int ch)

\details
The function \b USBD_CDC_ACM_PutChar asynchronously prepares a data byte that will be returned to the USB Host upon request.

The argument \a instance specifies the CDC class instance that is to be used.

The argument \a ch represents the character to be written.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_ACM_ReadData (uint8_t instance, uint8_t *buf, int32_t len)

\details
The function \b USBD_CDC_ACM_ReadData reads data from the intermediate buffer that was received from the USB Host
and stores them into a buffer.

The argument \a instance specifies the CDC class instance that is to be used.

The argument \a buf is a pointer to the buffer where received data will be stored.

The argument \a len specifies the number of bytes to be read.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int USBD_CDC_ACM_GetChar (uint8_t instance)
The function \b USBD_CDC_ACM_GetChar reads a data character from the intermediate buffer that was received from the USB Host
by the CDC device instance that is specified by the argument \a instance.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_ACM_DataAvailable (uint8_t instance)

\details
The function \b USBD_CDC_ACM_DataAvailable returns the number of bytes available in the intermediate buffer that was received 
from the USB Host by the CDC device instance that is specified by the argument \a instance.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_CDC_ACM_Notify_SerialState (uint8_t instance, uint16_t state) 

\details
The function \b USBD_CDC_ACM_Notify_SerialState sends error and line status information about the Virtual COM Port over the Interrupt
Endpoint.

The argument \a instance specifies the CDC device that is to be used with \b USBD_CDC_ACM_Notify_SerialState.

The argument \a state specifies the error status and the line state.

\note
Bits 0 (bRxCarrier) and 1 (bTxCarrier) are consistent states signals and notify should be called whenever their state changes.
For all other bits the notify should be called only when respective state has been activated or error has occurred.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_CDC_ACM_Notify_ResponseAvailable (uint8_t instance) 

\details
The function \b USBD_CDC_ACM_Notify_ResponseAvailable sends notification that response is available over the Interrupt
Endpoint.

The argument \a instance specifies the CDC device that is to be used with \b USBD_CDC_ACM_Notify_ResponseAvailable.
*/


/**
@}
*/


/**
\defgroup usbd_cdcFunctions_acm_conf Configuration
\ingroup usbd_cdcFunctions_acm
\brief Configuration of the USB Device CDC (ACM) Class.
\details
This configuration file defines:
- The assignment of the CDC class to the USB Device instance.
- \ref USB_Endpoints "USB Endpoint" assignments for the CDC class with parameters for Full/Low-speed and High-speed
  communication.
- Class Settings for the Interface Descriptor.

These settings are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and \ref USB_Endpoint_Descriptor
"Endpoint Descriptor" of the related USB Device Class. It is important that the settings match the application specific
behavior in the related C source file USBD_User_CDC_ACM_<i>n</i>.c.

\image  html usbd_config_cdc_acm_h.png "CDC Class Configuration File"

The USB Device CDC Class configuration file <b>USBD_Config_CDC_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects USB Device that is used for this Device Class instance.
- <b>Communication Class Subclass</b> specifies the model used by the CDC class. Select the <c>Abstract Control Model (ACM)</c>.
- <b>Communication Class Protocol</b> specifies the protocol used by the CDC class. For Virtual COM device select the 
  <tt>No protocol (Virtual COM)</tt>, and for RNDIS device select the <tt>Vendor-specific (RNDIS)</tt>.
- <b>Interrupt Endpoint Settings</b>
 - <b>Interrupt IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Endpoint Settings</b>
  - <b>Full/Low-speed (High-speed disabled)</b>: These parameters apply when High-speed is disabled in
    \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Endpoint polling Interval (in ms)</b> specifies the frequency of requests initiated by USB Host for getting a
     notification.
  - <b>High-speed</b>: These parameters apply when High-speed is enabled in \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Additional transactions per microframe</b> specifies additional transactions per microframe.
   - <b>Endpoint polling Interval (in 125 us intervals)</b> specifies the frequency of requests initiated by USB Host for getting a
     notification.
- <b>Bulk Endpoint Settings</b>
 - <b>Bulk IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Bulk OUT Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Endpoint Settings</b>
  - <b>Full/Low-speed (High-speed disabled)</b>: These parameters apply when High-speed is disabled in
    \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
  - <b>High-speed</b>: These parameters apply when High-speed is enabled in \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Maximum NAK Rate</b> specifies the interval in which Bulk Endpoint can NAK.
- <b>Communication Class Settings</b>
 - <b>Communication Class Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Data Class Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Abstract Control Model Settings</b>
  - <b>Call Management Capabilities</b> settings are used to create Call Management Functional Descriptor:
    - <b>Call Management channel</b> is used to specify channel of exchanging call management commands. 
         Select required option, for Virtual COM device typically this is set to <c>Communication and Data Class Interface</c>, 
         and for RNDIS device this is typically set to <c>Communication Class Interface only</c>.
    - <b>Device Call Management handling</b> is used to specify level of handling of call management by device.
         Select required option, for VirtualCOM device typically this is set to \c All, 
         and for RNDIS device this is typically set to \c None.
  - <b>Abstract Control Management Capabilities</b> settings are used to create Abstract Control Management Functional Descriptor:
    - <b>D3 bit</b> is used to specify if device supports the notification NetworkConnection.
                    Select required option, typically this is \c disabled for both Virtual COM and RNDIS device.
    - <b>D2 bit</b> is used to specify if device supports the request SendBreak.
                    Select required option, for VirtualCOM device this is typically \c enabled and for RNDIS device this is typically \c disabled.
    - <b>D1 bit</b> is used to specify if device supports the following requests: SetLineCoding, GetLineCoding,
                    SetControlLineState, and notification SerialState.
                    Select required option, for Virtual COM device this is typically \c enabled and for RNDIS device this is typically \c disabled.
    - <b>D0 bit</b> is used to specify if device supports the following requests: SetCommFeature, ClearCommFeature and GetCommFeature.
                    Select required option, for Virtual COM device this is typically \c enabled and for RNDIS device this is typically \c disabled.
  - <b>Maximum Communication Device Send Buffer Size</b> is used for memory allocation in the USB component.
  - <b>Maximum Communication Device Receive Buffer Size</b> is used for memory allocation in the USB component.
 - <b>Network Control Model Settings</b> are only valid for the \ref usbd_cdcFunctions_ncm "Network Control Model" sub-class.
- <b>OS Resources Settings</b>
 - <b>Communication Device Class Interrupt Endpoint Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Communication Device Class Interrupt Endpoint Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_CDC<i>n</i>_INT_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
 - <b>Communication Device Class Bulk Endpoints Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Communication Device Class Bulk Endpoints Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_CDC<i>n</i>_BULK_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_cdcFunctions_ncm CDC: Communication Device Class (NCM)
\ingroup usbd_DevClassFunctions

\brief Implement application specific behavior of a Communication Device Class (CDC) USB Device using the sub-class Network
Control Model (NCM) for <a href="https://en.wikipedia.org/wiki/Ethernet_over_USB" target="_blank">Ethernet-over-USB</a>
applications.

\details
The ability to connect Ethernet devices via USB ports is known as \b Ethernet-over-USB. Various industry protocols are
available to achieve this. One of the most advanced protocols is the CDC (NCM) class which is supported by the USB Component.

The <a href="http://www.linux-usb.org/usbnet/" target="_blank">usbnet</a> Kernel module in Linux hosts enables you to attach
a USB Device to the host to emulate an Ethernet device. There is no native Ethernet-over-USB support in Windows.

Refer to:
  - \ref CDC for an overview of the CDC class.
\if USBD_EXAMPLE_CDC_NCM
  - \ref usbd_example_cdc_ncm example project.
\endif

The USB Component allows multiple instances of the CDC class. This feature is used to create USB Composite Devices.
Each CDC class instance has a separate files and interface functions:
  - A CDC configuration file \ref usbd_cdcFunctions_ncm_conf "USBD_Config_CDC_n.h".
  - An application-specific user source code file, which can be implemented with the \urlout{uv4_ca_sourcefiles} \ref USBD_User_CDC_NCM_UCT "USBD_User_CDC_NCM_n.c", 
    or \ref USBD_User_CDC_NCM_ETH_UCT "USBD_User_CDC_NCM_ETH_n.c".
  - Functions that start with the prefix <b>USBD_CDCn_NCM</b> are available for each instance of a CDC NCM class.	

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>7</i>.
Most applications only require one instance of a CDC NCM class. For the first CDC NCM class instance the instance number is 0:
  - <b>USBD_Config_CDC_0.h</b>
  - <b>USBD_User_CDC_NCM_0.c</b>
  - The function prefix is <b>USBD_CDC0_NCM</b>

\b Descriptor \b Requirements
The following descriptors are required in an USB CDC NCM Device:
- Standard Device Descriptor
- Standard Configuration Descriptor
- Interface Association Descriptor
- CDC Header Functional Descriptor
- CDC Union Functional Descriptor
- CDC Ethernet Networking Functional Descriptor
- NCM Functional Descriptor
- Standard Interface Descriptor for the CDC Class communication interface
- Standard Endpoint Descriptor for Interrupt IN endpoint
- Standard Interface Descriptor for the CDC Class data interface
- Standard Endpoint Descriptors for Bulk IN and Bulk OUT endpoints

The necessary descriptors are automatically generated by the USB Middleware Component. The page \ref USB_Descriptors provides
more information on the topic.

<b>Software Structure</b>

The handling for the CDC class endpoint events is implemented in \b USBD_CDCn_Int_Thread and \b USBD_CDCn_Bulk_Thread which are started by
\ref USBD_Initialize. Each instance of a CDC class runs an instance of \b USBD_CDCn_Int_Thread and \b USBD_CDCn_Bulk_Thread.

The thread USBD_CDCn_Int_Thread handles Interrupt IN Endpoint whereas the USBD_CDCn_Bulk_Thread handles the Bulk IN and Bulk OUT Endpoints.

\msc
 a [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osProrityAboveNormal",       textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_CDCn_Int_Thread\n osProrityAboveNormal",    textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="USBD_CDCn_Bulk_Thread\n osProrityAboveNormal",   textcolor="green",  linecolor="green",  arclinecolor="green"],
 e [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                             textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",     textbgcolour="#E0E0FF"],
 c note c [label="Handle CDC Interrupt IN Endpoint Events", textbgcolour="#E0FFE0"],
 d note d [label="Handle CDC Bulk IN/OUT Endpoint Events",  textbgcolour="#E0FFE0"],
 e note e [label="USB Bus",                                 textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 e box e  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];
 e box e  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];

 ...;
 a box a  [label="USBD_CDC_NCM_Notify_NetworkConnection", URL="\ref USBD_CDC_NCM_Notify_NetworkConnection"],
 c box c  [label="Send connection notification"],
 e box e  [label="Interrupt IN"];

 ...;
 a box a  [label="USBD_CDC_NCM_Notify_ConnectionSpeedChange", URL="\ref USBD_CDC_NCM_Notify_ConnectionSpeedChange"],
 c box c  [label="Send speed notification"],
 e box e  [label="Interrupt IN"];

 ...;
 a box a  [label="USBD_CDC_NCM_NTB_IN_Initialize", URL="\ref USBD_CDC_NCM_NTB_IN_Initialize"];
 a box a  [label="USBD_CDC_NCM_NTB_IN_CreateNDP", URL="\ref USBD_CDC_NCM_NTB_IN_CreateNDP"];
 a box a  [label="USBD_CDC_NCM_NTB_IN_WriteDatagram", URL="\ref USBD_CDC_NCM_NTB_IN_WriteDatagram"];
 a box a  [label="USBD_CDC_NCM_NTB_IN_Send", URL="\ref USBD_CDC_NCM_NTB_IN_Send"],
 d box d  [label="Send NTB"],
 e box e  [label="Bulk IN"];
 a box a  [label="USBD_CDCn_NCM_NTB_IN_Sent", URL="\ref USBD_CDCn_NCM_NTB_IN_Sent"];

 ...;
 e box e  [label="Bulk OUT"],
 d box d  [label="Received NTB"],
 a box a  [label="USBD_CDCn_NCM_NTB_OUT_Received", URL="\ref USBD_CDCn_NCM_NTB_OUT_Received"];
 a box a  [label="USBD_CDC_NCM_NTB_OUT_ProcessNDP", URL="\ref USBD_CDC_NCM_NTB_OUT_ProcessNDP"];
 a box a  [label="USBD_CDC_NCM_NTB_OUT_ReadDatagram", URL="\ref USBD_CDC_NCM_NTB_OUT_ReadDatagram"];
 a box a  [label="USBD_CDC_NCM_NTB_OUT_Release", URL="\ref USBD_CDC_NCM_NTB_OUT_Release"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 e box e  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with a CDC NCM class:
  - Set the required number for USB:Device:CDC class instances during the \ref RTE_Software_Component_Selection.
  - Set the parameters in the configuration file \ref usbd_cdcFunctions_ncm_conf "USBD_Config_CDC_n.h".
  - Implement the application specific behavior using this \ref USBD_User_CDC_NCM_UCT "template" \a or
  - Use the pre-built \ref USBD_User_CDC_NCM_ETH_UCT "template file for Ethernet-over-USB".

\anchor USBD_User_CDC_NCM_UCT
<b>User Code Template USBD_User_CDC_NCM.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (NCM) Device.

\include "USBD_User_CDC_NCM.c"

\anchor USBD_User_CDC_NCM_ETH_UCT
<b>User Code Template USBD_User_CDC_NCM_ETH_n.c</b>

The following source code contains all the required callback functions and can be used to implement the application specific
behavior of a USB CDC (NCM) Device with Ethernet-over-USB functionality.

\include "USBD_User_CDC_NCM_ETH.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_cdcFunctions_ncm_api User API
\ingroup usbd_cdcFunctions_ncm
\brief User API reference of the Communication Device Class (NCM).
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_cdcFunctions_ncm_api
@{
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_Initialize (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_IN_Initialize clears the active NTB and initializes it for adding of NDPs and datagrams.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_CreateNDP (uint8_t instance, uint8_t num_datagrams);
\details
The function \b USBD_CDC_NCM_NTB_IN_CreateNDP creates a new NDP in the NTB so that datagrams can be added to it.

The argument \a instance specifies the instance of the CDC class.

The argument \a num_datagrams specifies the maximum number of datagrams that the NDP will contain. 

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_WriteDatagram (uint8_t instance, const uint8_t *buf, uint32_t len);
\details
The function \b USBD_CDC_NCM_NTB_IN_WriteDatagram adds a datagram into the active NDP of the NTB to be sent.

The argument \a instance specifies the instance of the CDC class.

The argument \a buf is a buffer containing the data to be written.

The argument \a len specifies the number of bytes to be written.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_Send (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_IN_Send transmits the active NTB.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_IsSent (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_IN_IsSent checks whether the NTB was sent and a new one can be prepared.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_OUT_IsReceived (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_OUT_IsReceived checks whether the NTB was received and can be processed.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_OUT_Release (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_OUT_Release flushes the received NTB and releases the memory for the reception of a new NTB. 

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_OUT_ProcessNDP (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_OUT_ProcessNDP processes the next NDP in the received NTB.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_CDC_NCM_NTB_OUT_GetDatagramSize (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_OUT_GetDatagramSize returns the size of a datagram from the active NDP of the received NTB. 

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_OUT_ReadDatagram (uint8_t instance, uint8_t *buf, uint32_t max_len);
\details
The function \b USBD_CDC_NCM_NTB_OUT_ReadDatagram reads a datagram from the active NDP of the received NTB. 

The argument \a instance specifies the instance of the CDC class.

The argument \a buf specifies the buffer that receives the data that is read.

The argument \a max_len specifies the maximum number of bytes to be read.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_IN_RawSend (uint8_t instance, const uint8_t *buf, uint32_t len);
\details
The function \b USBD_CDC_NCM_NTB_IN_RawSend sends an already prepared NTB. For this option, the value of the \c \#define
\c USBD_CDCn_NCM_RAW_ENABLE in the configuration has to be '1'. 

The argument \a instance specifies the instance of the CDC class.

The argument \a buf specifies the buffer containing the NTB.

The argument \a len specifies the size of the NTB.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_CDC_NCM_NTB_OUT_RawGetSize (uint8_t instance);
\details
The function \b USBD_CDC_NCM_NTB_OUT_RawGetSize returns the number of bytes available in the NTB.

The argument \a instance specifies the instance of the CDC class.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_NTB_OUT_RawReceive (uint8_t instance, uint8_t *buf, uint32_t max_len);
\details
The function \b USBD_CDC_NCM_NTB_OUT_RawReceive receives an NDP For this option, the value of the \c \#define
\c USBD_CDCn_NCM_RAW_ENABLE in the configuration has to be '1'.

The argument \a instance specifies the instance of the CDC class.

The argument \a buf specifies the buffer that receives the NTB.

The argument \a max_len specifies the maximum number of bytes that are accepted by the buffer 
(must be multiple of Bulk Out endpoint maximum packet size).

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_Notify_NetworkConnection (uint8_t instance, uint16_t status);
\details
The function \b USBD_CDC_NCM_Notify_NetworkConnection reports to the USB Host whether the physical layer (modem, Ethernet
PHY, etc.) link is up.

The argument \a instance specifies the instance of the CDC class.

The argument \a status specifies the connection status.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_CDC_NCM_Notify_ConnectionSpeedChange (uint8_t instance, uint32_t us_bitrate, uint32_t ds_bitrate);
\details
The function \b USBD_CDC_NCM_Notify_ConnectionSpeedChange report to the USB Host any change in the upstream or downstream
speed of the networking connection. 

The argument \a instance specifies the instance of the CDC class.

The argument \a us_bitrate specifies the upstream bitrate.

The argument \a ds_bitrate specifies the downstream bitrate.

\b Code \b Example \n
Refer to the \ref USBD_User_CDC_NCM_UCT "CDC (NCM) User Code Template"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_Initialize (void);
The function \b USBD_CDCn_NCM_Initialize initializes the hardware resources of the network device. It is called during
\ref USBD_Initialize. The function may be used to allocate resources and initialize peripherals.

Modify this function to the application needs.

\note Remember to release used resources and de-initialize peripherals using \ref USBD_CDCn_NCM_Uninitialize.

<b>Code Example</b>
\code
void USBD_CDCn_NCM_Initialize (void) {
  // Add code for initialization
  ARM_ETH_MAC_CAPABILITIES capabilities;
  int32_t                  status;
 
  MAC_wstr_to_addr(wsMacAddress, (uint8_t *)&MacAddress);
 
  memset(&NCM_State, 0, sizeof(NCM_State));
  NCM_State.ntb_input_size = USBD_CDCn_NCM_DW_NTB_IN_MAX_SIZE;
  NCM_State.max_datagram_size = USBD_CDCn_NCM_W_MAX_SEGMENT_SIZE;
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x02) != 0)
  memcpy(NCM_State.net_address, &MacAddress, 6);
#endif
  NCM_State.packet_filter_bitmap = 0x0CU;
 
  LinkState = ARM_ETH_LINK_DOWN;
  LinkInfo.speed  = 0U;
  LinkInfo.duplex = 0U;
  LinkSpeed = 0U;
 
  PacketFilter = ARM_ETH_MAC_ADDRESS_BROADCAST;
 
  FrameIN_Size = 0U;
  memset(FrameIN, 0, sizeof(FrameIN));
 
  // Initialize Media Access Controller
  capabilities = EthMac->GetCapabilities();
 
  status = EthMac->Initialize(EthMac_Notify);
  if (status != ARM_DRIVER_OK) { return; }
  status = EthMac->PowerControl(ARM_POWER_FULL);
  if (status != ARM_DRIVER_OK) { return; }
 
  status = EthMac->SetMacAddress(&MacAddress);
  if (status != ARM_DRIVER_OK) { return; }
 
  // Initialize Physical Media Interface
  status = EthPhy->Initialize(EthMac->PHY_Read, EthMac->PHY_Write);
  if (status != ARM_DRIVER_OK) { return; }
  status = EthPhy->PowerControl(ARM_POWER_FULL);
  if (status != ARM_DRIVER_OK) { return; }
  status = EthPhy->SetInterface(capabilities.media_interface);
  if (status != ARM_DRIVER_OK) { return; }
  status = EthPhy->SetMode(ARM_ETH_PHY_AUTO_NEGOTIATE);
  if (status != ARM_DRIVER_OK) { return; }
 
  // Create Threads
  Connection_ThreadId = osThreadNew(Connection_Thread, NULL, &connection_thread_attr);
  DataIN_ThreadId     = osThreadNew(DataIN_Thread,     NULL, &data_in_thread_attr);
  DataOUT_ThreadId    = osThreadNew(DataOUT_Thread,    NULL, &data_out_thread_attr);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_Uninitialize (void);
\details
The function \b USBD_CDCn_NCM_Uninitialize de-initializes/releases the hardware resources of the network device. It is called
during \ref USBD_Uninitialize. If \ref USBD_CDCn_NCM_Initialize has been adapted to the application,
\b USBD_CDCn_NCM_Uninitialize should release resources and should de-initialize peripherals.
  
<b>Code Example</b>
\code
void USBD_CDCn_NCM_Uninitialize (void) {
  // Add code for de-initialization
  osThreadTerminate(Connection_ThreadId);
  osThreadTerminate(DataIN_ThreadId);
  osThreadTerminate(DataOUT_ThreadId);
 
  EthPhy->PowerControl(ARM_POWER_OFF);
  EthPhy->Uninitialize();
 
  EthMac->PowerControl(ARM_POWER_OFF);
  EthMac->Uninitialize();
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_Reset (void);
\details
The function \b USBD_CDCn_NCM_Reset resets the network device.

Modify this function to the application's needs.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_Start (void);
\details
The function \b USBD_CDCn_NCM_Start is called when the USB Host activates the data interface.

<b>Code Example</b>
\code
void USBD_CDCn_NCM_Start (void) {
  // Add code for data interface activation
  osSignalSet(Connection_ThreadId, 1U);
  osSignalSet(DataIN_ThreadId, 1U);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_Stop (void);
\details
The function \b USBD_CDCn_NCM_Stop is called when the USB Host de-activates the data interface.

<b>Code Example</b>
\code
void USBD_CDCn_NCM_Stop (void) {
  // Add code for data interface de-activation
  // Explained in ncm10.pdf document from www.usb.org in paragraph 7.2
 
  FrameIN_Size = 0U;
 
  memset(&NCM_State, 0, sizeof(NCM_State));
  NCM_State.ntb_input_size = USBD_CDCn_NCM_DW_NTB_IN_MAX_SIZE;
  NCM_State.max_datagram_size = USBD_CDCn_NCM_W_MAX_SEGMENT_SIZE;
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x02) != 0)
  memcpy(NCM_State.net_address, &MacAddress, 6);
#endif
  NCM_State.packet_filter_bitmap = 0x0CU;
 
  PacketFilter = ARM_ETH_MAC_ADDRESS_BROADCAST;
 
  (void)EthMac->SetMacAddress(&MacAddress);
  (void)EthMac->SetAddressFilter(NULL, 0);
  (void)EthMac->Control(ARM_ETH_MAC_CONFIGURE,
                       (uint32_t)(LinkInfo.speed                           ) |
                       (uint32_t)(LinkInfo.duplex << ARM_ETH_MAC_DUPLEX_Pos) |
                        PacketFilter);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetEthernetMulticastFilters (const uint8_t *addr_list, uint16_t num_of_filters);
\details
The function \b USBD_CDCn_NCM_SetEthernetMulticastFilters is called when the USB Host requests to set the USB Device's
Ethernet multicast filters.

The argument \a addr_list is a pointer to the list of 48-bit Multicast addresses.

The argument \a num_of_filters specifies the number of filters to be used.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetEthernetMulticastFilters (const uint8_t *addr_list, uint16_t num_of_filters) {
#if (USBD_CDCn_NCM_W_NUMBER_MC_FILTERS != 0)
  int32_t status;
 
  if (num_of_filters > (USBD_CDCn_NCM_W_NUMBER_MC_FILTERS & 0x7FFF)) { return false; }
 
  // Add code for handling request
  status = EthMac->SetAddressFilter((ARM_ETH_MAC_ADDR *)addr_list, num_of_filters);
  if (status != ARM_DRIVER_OK) { return false; }
 
  memcpy(&NCM_State.mc_filters, addr_list, num_of_filters * 6);
 
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size);
\details
The function \b USBD_CDCn_NCM_SetEthernetPowerManagementPatternFilter is called when the USB Host requests to set up the USB
Device's Ethernet power management pattern filter.

The argument \a filter_number specifies the filter number.

The argument \a pattern_filter is a pointer to the pattern filter structure.

The argument \a pattern_filter_size specifies the size of the pattern filter structure. 

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetEthernetPowerManagementPatternFilter (uint16_t filter_number, const uint8_t *pattern_filter, uint16_t pattern_filter_size) {
#if (USBD_CDCn_NCM_B_NUMBER_POWER_FILTERS != 0)
  if (filter_number >= USBD_CDCn_NCM_B_NUMBER_POWER_FILTERS) { return false; }
 
  // Add code for handling request
 
  NCM_State.power_filter_active[filter_number / 8] |= 1U << (filter_number % 8);
 
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active);
\details
The function \b USBD_CDCn_NCM_GetEthernetPowerManagementPatternFilter is called when the USB Host retrieves the status of the
USB Device's Ethernet power management pattern filter.

The argument \a filter_number specifies the filter number.

The argument \a pattern_active is a pointer to the pattern active boolean.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetEthernetPowerManagementPatternFilter (uint16_t filter_number, uint16_t *pattern_active) {
#if (USBD_CDCn_NCM_B_NUMBER_POWER_FILTERS != 0)
  *pattern_active = (NCM_State.power_filter_active[filter_number / 8] & (1U << (filter_number % 8))) ? 1 : 0;
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetEthernetPacketFilter (uint16_t packet_filter_bitmap);
\details
The function \b USBD_CDCn_NCM_SetEthernetPacketFilter is called when the USB Host requests to configure the USB Device's
Ethernet packet filter settings.

The argument \a packet_filter_bitmap is the packet filter's bitmap.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetEthernetPacketFilter (uint16_t packet_filter_bitmap) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x01) != 0)
  int32_t status;
 
  // Add code for handling request
  PacketFilter = ((packet_filter_bitmap & 0x01U) ? ARM_ETH_MAC_ADDRESS_ALL       : 0) |
                 ((packet_filter_bitmap & 0x02U) ? ARM_ETH_MAC_ADDRESS_MULTICAST : 0) |
                 ((packet_filter_bitmap & 0x08U) ? ARM_ETH_MAC_ADDRESS_BROADCAST : 0);
 
  status = EthMac->Control(ARM_ETH_MAC_CONFIGURE,
                           LinkInfo.speed  << ARM_ETH_MAC_SPEED_Pos  |
                           LinkInfo.duplex << ARM_ETH_MAC_DUPLEX_Pos |
                           PacketFilter);
  if (status != ARM_DRIVER_OK) { return false; }
 
  NCM_State.packet_filter_bitmap = packet_filter_bitmap;
 
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetEthernetStatistic (uint16_t feature_selector, uint32_t *data);
\details
The function \b USBD_CDCn_NCM_GetEthernetStatistic is called when the USB Host tries to retrieve an Ethernet statistic based
on the feature selector.

The argument \a feature_selector specifies the feature selector.

The argument \a data is a pointer to the statistic's value.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetEthernetStatistic (uint16_t feature_selector, uint32_t *data) {
#if (USBD_CDCn_NCM_BM_ETHERNET_STATISTICS != 0)
  if (feature_selector == 0x00U) { return true;  }
  if (feature_selector >  0x1DU) { return false; }
  *data = NCM_State.eth_statistics[feature_selector - 1];
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetNtbParameters (CDC_NCM_NTB_PARAM *ntb_params);
\details
The function \b USBD_CDCn_NCM_GetNtbParameters is called when the USB Host requests to return the parameters that describe
the NCM Transfer Blocks (NTBs) for each direction.

The argument \a ntb_params is a pointer to the NTB parameter structure.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetNtbParameters (CDC_NCM_NTB_PARAM *ntb_params) {
 
  ntb_params->wLength                 = sizeof(CDC_NCM_NTB_PARAM);
  ntb_params->bmNtbFormatsSupported   = USBD_CDCn_NCM_BM_NTB_FORMATS_SUPPORTED;
  ntb_params->dwNtbInMaxSize          = USBD_CDCn_NCM_DW_NTB_IN_MAX_SIZE;
  ntb_params->wNdpInDivisor           = USBD_CDCn_NCM_W_NDP_IN_DIVISOR;
  ntb_params->wNdpInPayloadRemainder  = USBD_CDCn_NCM_W_NDP_IN_PAYLOAD_REMINDER;
  ntb_params->wNdpInAlignment         = USBD_CDCn_NCM_W_NDP_IN_ALIGNMENT;
  ntb_params->Reserved0               = 0U;
  ntb_params->dwNtbOutMaxSize         = USBD_CDCn_NCM_DW_NTB_OUT_MAX_SIZE;
  ntb_params->wNdpOutDivisor          = USBD_CDCn_NCM_W_NDP_OUT_DIVISOR;
  ntb_params->wNdpOutPayloadRemainder = USBD_CDCn_NCM_W_NDP_OUT_PAYLOAD_REMINDER;
  ntb_params->wNdpOutAlignment        = USBD_CDCn_NCM_W_NDP_OUT_ALIGNMENT;
  ntb_params->Reserved1               = 0U;
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetNetAddress (uint8_t *net_addr);
\details
The function \b USBD_CDCn_NCM_GetNetAddress is called when the USB Host requests to return the USB Device's current EUI-48
station address.

The argument \a net_addr is a pointer to the current EUI-48 network address.
 
<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetNetAddress (uint8_t *net_addr) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x02) != 0)
  memcpy(net_addr, NCM_State.net_address, 6);
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetNetAddress (const uint8_t *net_addr);
\details
The function \b USBD_CDCn_NCM_SetNetAddress is called when the USB Host requests to set the USB Device's current EUI-48
station address.

The argument \a net_addr is a pointer to the EUI-48 network address.
 
<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetNetAddress (const uint8_t *net_addr) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x02) != 0)
  int32_t status;
 
  // Add code for handling request
  status = EthMac->SetMacAddress((ARM_ETH_MAC_ADDR *)net_addr);
  if (status != ARM_DRIVER_OK) { return false; }
 
  memcpy(NCM_State.net_address, net_addr, 6);
 
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetNtbFormat (uint16_t *ntb_format);
\details
The function \b USBD_CDCn_NCM_GetNtbFormat is called when the USB Host requests to return the NCM Transfer Block (NTBs) data
format that is currently being used by the USB Device.

The argument \a ntb_format is a pointer to the NTB format code.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetNtbFormat (uint16_t *ntb_format) {
  *ntb_format = NCM_State.ntb_format;
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetNtbFormat (uint16_t ntb_format);
\details
The function \b USBD_CDCn_NCM_SetNtbFormat is called when the USB Host requests to set the NCM Transfer Block (NTBs) data
format to be used by the USB Device for transfers to the host.

The argument \a ntb_format is a pointer to the NTB format code.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetNtbFormat (uint16_t ntb_format) {
#if (USBD_CDCn_NCM_BM_NTB_FORMATS_SUPPORTED > 1)
  if (ntb_format > 1) { return false; }
#else
  if (ntb_format > 0) { return false; }
#endif
  NCM_State.ntb_format = ntb_format;
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetNtbInputSize (uint32_t *ntb_input_size);
\details
The function \b USBD_CDCn_NCM_GetNtbInputSize is called when the USB Host requests to return the NCM Transfer Block (NTBs)
input size that is currently being used by the USB Device.

The argument \a ntb_input_size is a pointer to the NTB input size.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetNtbInputSize (uint32_t *ntb_input_size) {
  *ntb_input_size = NCM_State.ntb_input_size;
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetNtbInputSize (uint32_t ntb_input_size);
\details
The function \b USBD_CDCn_NCM_SetNtbInputSize is called when the USB Host requests to set the maximum size of NCM 
Transfer Block (NTBs) that USB Device can send to the USB Host.

The argument \a ntb_input_size is a pointer to the NTB input size.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetNtbInputSize (uint32_t ntb_input_size) {
  if (ntb_input_size > USBD_CDCn_NCM_DW_NTB_IN_MAX_SIZE) { return false; }
  NCM_State.ntb_input_size = ntb_input_size;
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size);
\details
The function \b USBD_CDCn_NCM_GetMaxDatagramSize is called when the USB Host requests to return the currently effective
maximum datagram size used by the USB Device.

The argument \a max_datagram_size is a pointer to current maximum datagram size.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetMaxDatagramSize (uint16_t *max_datagram_size) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x08) != 0)
  *max_datagram_size = NCM_State.max_datagram_size;
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetMaxDatagramSize (uint16_t max_datagram_size);
\details
The function \b USBD_CDCn_NCM_SetMaxDatagramSize is called when the USB Host requests to set the maximum datagram size that
can be sent in an NCM Transfer Block (NTBs).

The argument \a max_datagram_size is a pointer to current maximum datagram size.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetMaxDatagramSize (uint16_t max_datagram_size) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x08) != 0)
  if (max_datagram_size > USBD_CDCn_NCM_W_MAX_SEGMENT_SIZE) { return false; }
  NCM_State.max_datagram_size = max_datagram_size;
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_GetCrcMode (uint16_t *crc_mode);
\details
The function \b USBD_CDCn_NCM_GetCrcMode is called when the USB Host requests to return the currently selected CRC mode.

The argument \a crc_mode is a pointer to the current CRC mode.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_GetCrcMode (uint16_t *crc_mode) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x10) != 0)
  *crc_mode = NCM_State.crc_mode;
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_CDCn_NCM_SetCrcMode (uint16_t crc_mode);
\details
The function \b USBD_CDCn_NCM_SetCrcMode is called when the USB Host requests to set the CRC mode to be used for data
transmissions.

The argument \a crc_mode is a value of the current CRC mode.

<b>Code Example</b>
\code
bool USBD_CDCn_NCM_SetCrcMode (uint16_t crc_mode) {
#if ((USBD_CDCn_NCM_BM_NETWORK_CAPABILITIES & 0x10) != 0)
  if (crc_mode > 1) { return false; }
  NCM_State.crc_mode = crc_mode;
  return true;
#else
  return false;
#endif
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_NTB_IN_Sent (void);
\details
The function \b USBD_CDCn_NCM_NTB_IN_Sent is called when an NCM Transfer Block (NTBs) has been sent successfully.

<b>Code Example</b>
\code
void USBD_CDCn_NCM_NTB_IN_Sent (void) {
  // Add code for handling request
  osSignalSet(DataIN_ThreadId, 1U);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CDCn_NCM_NTB_OUT_Received (void);
\details
The function \b USBD_CDCn_NCM_NTB_OUT_Received is called when an NCM Transfer Block (NTBs) has been received successfully.

<b>Code Example</b>
\code
void USBD_CDCn_NCM_NTB_OUT_Received (void) {
  // Add code for handling request
  osSignalSet(DataOUT_ThreadId, 1U);
}
\endcode
*/

/**
@}
*/


/**
\defgroup usbd_cdcFunctions_ncm_conf Configuration
\ingroup usbd_cdcFunctions_ncm
\brief Configuration of the USB Device CDC (NCM) Class.
\details
This configuration file defines:
- The assignment of the CDC class to the USB Device instance.
- \ref USB_Endpoints "USB Endpoint" assignments for the CDC class with parameters for Full/Low-speed and High-speed
  communication.
- Class Settings for the Interface Descriptor.

These settings are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and \ref USB_Endpoint_Descriptor
"Endpoint Descriptor" of the related USB Device Class. It is important that the settings match the application specific
behavior in the related C source file USBD_User_CDC_NCM_<i>n</i>.c.

\image  html usbd_config_cdc_h.png "CDC Class Configuration File"

The USB Device CDC Class configuration file <b>USBD_Config_CDC_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects USB Device that is used for this Device Class instance.
- <b>Communication Class Subclass</b> specifies the model used by the CDC class. Select the <c>Network Control Model</c>.
- <b>Interrupt Endpoint Settings</b>
 - <b>Interrupt IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Endpoint Settings</b>
  - <b>Full/Low-speed (High-speed disabled)</b>: These parameters apply when High-speed is disabled in
    \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Endpoint polling Interval (in ms)</b> specifies the frequency of requests initiated by USB Host for getting a
     notification.
  - <b>High-speed</b>: These parameters apply when High-speed is enabled in \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Additional transactions per microframe</b> specifies additional transactions per microframe.
   - <b>Endpoint polling Interval (in 125 us intervals)</b> specifies the frequency of requests initiated by USB Host for getting a
     notification.
- <b>Bulk Endpoint Settings</b>
 - <b>Bulk IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Bulk OUT Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Endpoint Settings</b>
  - <b>Full/Low-speed (High-speed disabled)</b>: These parameters apply when High-speed is disabled in
    \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Maximum NAK Rate</b> specifies the interval in which Bulk Endpoint can NAK.
  - <b>High-speed</b>: These parameters apply when High-speed is enabled in \ref usbd_coreFunctions_conf "USBD_Config_n.h":
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange.
   - <b>Maximum NAK Rate</b> specifies the interval in which Bulk Endpoint can NAK.
- <b>Communication Class Settings</b>
 - <b>Communication Class Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Data Class Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Abstract Control Model Settings</b> are only used for the \ref usbd_cdcFunctions_acm "Abstract Control Model"
   sub-class.
 - <b>Network Control Model Settings</b>
  - <b>MAC Address String</b> specifies the 48-bit Ethernet MAC address of the device.
  - <b>Ethernet Statistics</b> specifies the Ethernet statistic functions that are supported. These need to be implemented
    by the user in the user code template file.
  - <b>Maximum Segment Size</b> specifies the maximum segment size (MSS) that the Ethernet device can support.
  - <b>Multicast Filtering</b> specifies multicast filtering type.
  - <b>Number of Power Filters</b> specifies the number of pattern filters that are available to wake-up the USB Host.
  - <b>Network Capabilities</b> specifies which functions are supported.
   - <b>SetCrcMode/GetCrcMode</b>
   - <b>SetMaxDatagramSize/GetMaxDatagramSize</b>
   - <b>SetNetAddress/GetNetAddress</b>
   - <b>SetEthernetPacketFilter</b>
  - <b>NTB Parameters</b> specifies the NTB parameters that are reported by the \ref USBD_CDCn_NCM_GetNtbParameters function.
   - <b>NTB Formats Supported</b> specifies the NTB formats that are supported.
    - <b>16-bit NTB (always supported)</b>
    - <b>32-bit NTB</b>
   - <b>IN Data Pipe</b> 
    - <b>Maximum NTB Size</b> specifies the maximum IN NTB size in bytes.
    - <b>NTB Datagram Payload Alignment Divisor</b> specifies the divisor used for IN NTB Datagram payload alignment.
    - <b>NTB Datagram Payload Alignment Remainder</b> specifies the remainder used to align input datagram payload within the
      NTB.
    - <b>NDP Alignment Modulus in NTB</b> specifies NDP alignment modulus for NTBs on the IN pipe.
   - <b>OUT Data Pipe</b>
    - <b>Maximum NTB Size</b> specifies the maximum OUT NTB size in bytes.
    - <b>NTB Datagram Payload Alignment Divisor</b> specifies the divisor used for OUT NTB Datagram payload alignment.
    - <b>NTB Datagram Payload Alignment Remainder</b> specifies the remainder used to align output datagram payload within
      the NTB.
    - <b>NDP Alignment Modulus in NTB</b> specifies NDP alignment modulus for NTBs on the OUT pipe.
   - <b>Raw Data Access API</b> enables or disables Raw Data Access API.
   - <b>IN NTB Data Buffering</b> specifies buffering used for sending data to USB Host if Raw Data Access is disabled.
   - <b>OUT NTB Data Buffering</b> specifies buffering used for receiving data from USB Host if Raw Data Access is disabled.
- <b>OS Resources Settings</b>
 - <b>Communication Device Class Interrupt Endpoint Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Communication Device Class Interrupt Endpoint Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_CDC<i>n</i>_INT_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
 - <b>Communication Device Class Bulk Endpoints Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Communication Device Class Bulk Endpoints Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_CDC<i>n</i>_BULK_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_hidFunctions HID: Human Interface Class
\ingroup usbd_DevClassFunctions

\brief Implement application specific behaviour of a Human Interface Device (HID) Class USB Device.

\details

The HID class in the USB Component is used for data exchange. It implements a vendor defined
HID class with Usage Page ID=0xFF00.

Refer to:
  - \ref HID for an overview of the HID class.
  - \ref usbd_example_hid for example project that use the HID class on USB Device.
  - \ref usbh_example_hid for example project that use the HID class on USB Host.

The USB Component allows multiple instances of the HID class. This feature is used to create USB Composite Devices.
Each HID class instance has a separate files and interface functions:
  - A configuration file \ref usbd_hidFunctions_conf "USBD_Config_HID_n.h".
  - An application-specific user source code file, which can be implemented with the \urlout{uv4_ca_sourcefiles} <b>USBD_User_HID_<i>n</i>.h</b>.
  - Functions that start with the prefix <b>USBD_HIDn_</b> are available for each instance of a HID class.	

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>3</i>.
Most applications only require one instance of a HID class. For the first HID class instance the instance number is 0:
  - <b>USBD_Config_HID_0.h</b>
  - <b>USBD_User_HID_0.c</b>
  - The function prefix is <b>USBD_HID0_</b>
  
\b Descriptor \b Requirements
The following descriptors are required in an USB HID Device:
- Standard Device Descriptor
- Standard Configuration Descriptor
- Standard Interface Descriptor for the HID Class
- Class-Specific HID Descriptor
- Standard Endpoint Descriptor for Interrupt IN endpoint
- Class-Specific Report Descriptor

The necessary descriptors are automatically generated by the USB Middleware Component. The report descriptor is built based
on the settings in the \b USBD_Config_HID_x.h file. The number of reports and their maximum size are specified in this file.
The page \ref USB_Descriptors provides more information on the topic.

<b>Software Structure</b>

The handling for the HID class endpoint events is implemented in \b USBD_HIDn_Thread which is started by
\ref USBD_Initialize. Each instance of a HID class runs an instance of \b USBD_HIDn_Thread 
which calls the data exchange functions \ref USBD_HIDn_GetReport and \ref USBD_HIDn_SetReport.

\ref USBD_HID_GetReportTrigger may be called from any user thread to send asynchronous data reports to the USB Host.
\ref USBD_HID_GetReportTrigger cannot be called from interrupt service routines (ISR) as it may wait for previous data to be
sent.

The HID class uses a CMSIS-RTOS2 timer set to a 4ms interval to handle polling reports. 
The polling timing is defined with \ref USB_Endpoint_Descriptor "Endpoint Descriptor".
For more information refer to "Set_Idle Request" in 
<a class=el href="https://www.usb.org/hid" target="_blank">Device Class Definition HID</a> specification which
is provided by USB Implementers Forum (USB-IF).

\msc
 a [label="",                                                   textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osProrityAboveNormal",           textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_HIDn_Thread\n osProrityAboveNormal",            textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="",                                                   textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                                 textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",         textbgcolour="#E0E0FF"],
 c note c [label="Handle HID Interrupt IN/OUT Endpoint Events", textbgcolour="#E0FFE0"],
 d note d [label="USB Bus",                                     textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 d box d  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];
 d box d  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];

 ...;
 d box d  [label="Interrupt OUT"],
 c box c  [label="Receive report"],
 a box a  [label="USBD_HIDn_SetReport", URL="\ref USBD_HIDn_SetReport"];

 ...;
 b box b  [label="Receive read report request"],
 a box a  [label="USBD_HIDn_GetReport", URL="\ref USBD_HIDn_GetReport"],
 c box c  [label="Send report"],
 d box d  [label="Interrupt IN"];

 ...;
 a box a  [label="USBD_HID_GetReportTrigger", URL="\ref USBD_HID_GetReportTrigger"],
 c box c  [label="Send report"],
 d box d  [label="Interrupt IN"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 d box d  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with a HID class:
  - Set the required number for USB:Device:HID class instances during the \ref RTE_Software_Component_Selection.
  - Set the parameters in the configuration file \ref usbd_hidFunctions_conf "USBD_Config_HID_n.h".
  - Implement the application specific behavior in using a \ref UCT_USBD_User_HID "template".

\anchor UCT_USBD_User_HID
\b User \b Code \b Templates
\n There are two user code templates available that help to add support for an HID device:
-# \ref USBD_User_HID_UCT "USBD_User_HID.c" contains all the callback functions that need to be implemented by the user.
-# \ref USBD_User_HID_Mouse_UCT "USBD_User_HID_Mouse.c" is a code template for the application specific
   functionality of a USB HID Device acting as a mouse pointer input device.

\anchor USBD_User_HID_UCT
<b>User Code Template USBD_User_HID.c</b>

The following source code can be used to implement the application specific behavior of an USB HID Device.

\include "USBD_User_HID.c"

\anchor USBD_User_HID_Mouse_UCT
<b>User Code Template USBD_User_HID_Mouse.c</b>

The following source code can be used to implement the application specific behavior of an USB HID Mouse Device.

\include "USBD_User_HID_Mouse.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_hidFunctions_api User API
\ingroup usbd_hidFunctions
\brief User API reference of the Human Interface Device Class.
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_hidFunctions_api
@{
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_HIDn_Initialize (void)
\details
The function \b USBD_HIDn_Initialize is called automatically upon initialization of a Human Interface Device Class Device
and needs no invocation in the user code.

Modify this function to the application needs to allocate resources and initialize additional peripherals.

<b>Code Example</b>
\code
#include "rl_usb.h"
#include "rl_usbd.h"
#include "usb_hid.h"
 
int main (void)  {
  ..
  USBD_Initialize (0);   // USB Device 0 Initialization calls USBD_HIDn_Initialize() automatically
  USBD_Connect (0);      // USB Device 0 Connect
  ..
}
\endcode  
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_HIDn_Uninitialize (void)
\details
The function \b USBD_HIDn_Uninitialize is called automatically upon un-initialization of a Human Interface Device Class Device
and needs no invocation in the user code. If \ref USBD_HIDn_Initialize has been adapted to the application,
\b USBD_HIDn_Uninitialize should release resources and should de-initialize peripherals. 
  
<b>Code Example</b>
\code
#include "rl_usb.h"
#include "rl_usbd.h"
#include "usb_hid.h"
 
int main (void)  {
  ..
  USBD_Initialize (0);         // USB Device 0 Initialization
  ...
  USBD_Uninitialize (0);       // USB Device 0 Un-Initialization
  ..
}
\endcode  
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_HIDn_GetReport (uint8_t rtype, uint8_t req, uint8_t rid, uint8_t *buf)
\details
The function \b USBD_HIDn_GetReport prepares data that will be returned to the USB Host. You may modify the function to the
application's needs. The function is called on any of the following events:
 - if USB Host has requested new data by request on Control Endpoint 0,
 - if USB Host set idle period different than infinite, at each idle period expiration,
 - if data was sent to USB Host.

The argument \a rtype specifies the report type:
|Value             |Description             |
|------------------|------------------------|
|HID_REPORT_INPUT  |Input report requested  |
|HID_REPORT_FEATURE|Feature report requested|

The argument \a req specifies the request type:
|Value                     |Description                                                   |
|--------------------------|--------------------------------------------------------------|
|USBD_HID_REQ_EP_CTRL      |Request came from control endpoint                            |
|USBD_HID_REQ_PERIOD_UPDATE|Request came from idle period expiration                      |
|USBD_HID_REQ_EP_INT       |Request came from previously sent report on interrupt endpoint|

The argument \a rid specifies the report ID and should be 0 if there's only one report in the system.

The argument \a buf is pointing to the buffer to report data.

<b>Code Example</b>
\code
#include "cmsis_vio.h"

#include "rl_usbd.h"
#include "usb_hid.h"

int32_t USBD_HIDn_GetReport (uint8_t rtype, uint8_t req, uint8_t rid, uint8_t *buf) {
 
  switch (rtype) {
    case HID_REPORT_INPUT:
      switch (rid) {
        case 0:
          switch (req) {
            case USBD_HID_REQ_EP_CTRL:
            case USBD_HID_REQ_PERIOD_UPDATE:
            case USBD_HID_REQ_EP_INT:
              *buf = (uint8_t)(vioGetSignal(0xFFU));
              return 1;
          }
          break;
      }
      break;
    case HID_REPORT_FEATURE:
      break;
  }
  return 0;
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_HIDn_SetReport (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, int32_t len)
\details
The function \b USBD_HIDn_SetReport handles HID report data that is received from the USB Host. The function is called when
a HID report was received. You may modify the function to the application's needs. 

The argument \a rtype specifies the report type:
|Value             |Description             |
|------------------|------------------------|
|HID_REPORT_OUTPUT |Output report received  |
|HID_REPORT_FEATURE|Feature report received |

The argument \a req specifies the request type:
|Value                     |Description                            |
|--------------------------|---------------------------------------|
|USBD_HID_REQ_EP_CTRL      |Request came through control endpoint  |
|USBD_HID_REQ_EP_INT       |Request came through interrupt endpoint|

The argument \a rid specifies the report ID and should be 0 if there's only one report in the system.

The argument \a buf is pointing to the buffer to report data.

The argument \a len specifies the length of the received report data.

<b>Code Example</b>
\code
#include "cmsis_vio.h"

#include "rl_usbd.h"
#include "usb_hid.h"

bool USBD_HIDn_SetReport (uint8_t rtype, uint8_t req, uint8_t rid, const uint8_t *buf, uint32_t len) {
  uint8_t i;
 
  switch (rtype) {
    case HID_REPORT_OUTPUT:
      vioSetSignal(0xFFU, *buf);
      break;
    case HID_REPORT_FEATURE:
      break;
  }

  return true;
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_HID_GetReportTrigger (uint8_t instance, uint8_t rid, const uint8_t *buf, uint32_t len)
\details
The function \b USBD_HID_GetReportTrigger asynchronously prepares data that will be returned to the USB Host upon request. 
It enables the USB Device to send HID report data only when the data has changed. Usually, the USB Host sets idle time 
to \em infinity upon HID Device enumeration. This means, the USB Host expects data from a device only when it has changed.
If idle time is not set to infinity, the \ref USBD_HIDn_GetReport function is called whenever the idle time period is
expired.

Use the function only for reports of type HID_REPORT_INPUT and for events that needs to update report data.
The function should only be used for reports with the \a rtype = HID_REPORT_INPUT to signal that an updated HID report is
available.

The argument \a instance specifies the instance of the HID device that is to be used.

The argument \a rid specifies the report ID and should be 0 if there's only one report in the system.

The argument \a buf is pointing to the buffer with the data to be sent.

The argument \a len specifies the number of bytes to be sent.

<b>Code Example</b>
\code
#include "cmsis_vio.h"

#include "rl_usb.h"

__NO_RETURN void app_main_thread (void *argument) {
  uint8_t but;
  uint8_t but_prev = 0U;

  (void)argument;

  USBD_Initialize(0U);                  // USB Device 0 Initialization
  USBD_Connect   (0U);                  // USB Device 0 Connect

  for (;;) {                            // Loop forever
    but = (uint8_t)(vioGetSignal(0xFFU));
    if (but != but_prev) {
      but_prev = but;
      if (USBD_Configured (0)) { USBD_HID_GetReportTrigger(0U, 0U, &but, 1U); }
    }
    osDelay(100U);                      // 100 ms delay for sampling buttons
  }
}
\endcode
*/


/**
@}
*/


/**
\defgroup usbd_hidFunctions_conf Configuration
\ingroup usbd_hidFunctions
\brief Configuration of the USB Device HID Class.
\details
This configuration file defines:
  - The assignment of the HID class to the USB Device instance.
  - \ref USB_Endpoints "USB Endpoint" assignments for the HID class with parameters for Full/Low-speed and High-speed
    communication.
  - Class Settings for the Interface Descriptor.
	
These settings are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and \ref USB_Endpoint_Descriptor
"Endpoint Descriptor" of the related USB Device Class. It is important that the settings match the application specific
behavior in the related C source file USBD_User_HID_<i>n</i>.c.

\image  html usbd_config_hid_h.png "HID Class Configuration File"

The USB Device HID Class configuration file <b>USBD_Config_HID_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects USB Device that is used for this Device Class instance.
- <b>Interrupt Endpoint Settings</b>
 - <b>Interrupt IN Endpoint Settings</b>
  - <b>Interrupt IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
     compile-time error messages.
  - <b>Endpoint Settings</b>
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange. This
     setting is available for low-/full- and high-speed endpoints.
   - <b>Additional transactions per microframe</b> specifies additional transactions per microframe.
     This setting is available only for high-speed endpoints.
   - <b>Endpoint polling Interval (in xxx)</b> specifies the frequency of requests initiated by USB Host for getting data.
     This setting is available for low-/full- and high-speed endpoints.
 - <b>Interrupt OUT Endpoint Settings</b>
  - <b>Interrupt OUT Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
     compile-time error messages.
  - <b>Endpoint Settings</b>
   - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange. This
     setting is available for low-/full- and high-speed endpoints.
   - <b>Additional transactions per microframe</b> specifies additional transactions per microframe.
     This setting is available only for high-speed endpoints.
   - <b>Endpoint polling Interval (in xxx)</b> specifies the frequency of requests sent by USB Host for setting data.
     This setting is available for low-/full- and high-speed endpoints.
- <b>Human Interface Device Class Settings</b>
 - <b>HID Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Number of Input Reports</b> is used for memory allocation in the USB component.
 - <b>Number of Output Reports</b> is used for memory allocation in the USB component.
 - <b>Maximum Input Report Size (in bytes)</b> is used for memory allocation in the USB component.
 - <b>Maximum Output Report Size (in bytes)</b> is used for memory allocation in the USB component.
 - <b>Maximum Feature Report Size (in bytes)</b> is used for memory allocation in the USB component.
 - <b>Use User Provided HID Report Descriptor</b>: if checked, you need to provide HID Report Descriptor in an array: const
   uint8_t usbd_hid0_report_descriptor[]
  - <b>User Provided HID Report Descriptor Size (in bytes) </b>: is used for memory allocation in the USB component.
- <b>OS Resources Settings</b>
 - <b>Human Interface Device Class Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Human Interface Device Class Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_HID<i>n</i>_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
    Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_mscFunctions MSC: Mass Storage Class
\ingroup usbd_DevClassFunctions

\brief Implement application specific behavior of a Mass Storage Class (MSC) USB Device.

\details
The MSC class in the USB Component is used for data storage.

Refer to:
  - \ref MSC for an overview of the MSC class.
  - \ref usbd_example_msc for example projects that use the MSC class on USB Device.
  - \ref usbh_example_msc for example projects that use the MSC class on USB Host.

The USB Component allows multiple instances of the MSC class.
Each MSC class instance has a separate files and interface functions:
  - A configuration file \ref usbd_mscFunctions_conf "USBD_Config_MSC_n.h".
  - An application-specific user source code file, which can be implemented with the \urlout{uv4_ca_sourcefiles} <b>USBD_User_MSC_<i>n</i>.c</b>.
  - Functions that start with the prefix <b>USBD_MSCn_</b> are available for each instance of a MSC class.	

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>3</i>.
Most applications only require one instance of a MSC class. For the first MSC class instance the instance number is 0:
  - <b>USBD_Config_MSC_0.h</b>
  - <b>USBD_User_MSC_0.c</b>
  - The function prefix is <b>USBD_MSC0_</b>
  
\b Software \b Structure

The handling for the MSC class endpoint events is implemented in \b USBD_MSCn_Thread which is started by \ref USBD_Initialize.
Each instance of a MSC class runs an instance of \b USBD_MSCn_Thread which calls the data functions \ref USBD_MSCn_Read and
\ref USBD_MSCn_Write.

\msc
 a [label="",                                              textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osProrityAboveNormal",      textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_MSCn_Thread\n osProrityAboveNormal",       textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="",                                              textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                            textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",    textbgcolour="#E0E0FF"],
 c note c [label="Handle MSC Bulk IN/OUT Endpoint Events", textbgcolour="#E0FFE0"],
 d note d [label="USB Bus",                                textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 d box d  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];
 d box d  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];

 ...;
 a box a  [label="USBD_MSCn_Write", URL="\ref USBD_MSCn_Write"],
 c box c  [label="Send data"],
 d box d  [label="Bulk IN"];

 ...;
 d box d  [label="Bulk OUT"],
 c box c  [label="Receive data"],
 a box a  [label="USBD_MSCn_Read", URL="\ref USBD_MSCn_Read"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 d box d  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with a MSC class:
- Set the required number for USB:Device:MSC class instances during the \ref RTE_Software_Component_Selection.
- Set the parameters in the configuration file \ref usbd_mscFunctions_conf "USBD_Config_MSC_n.h".
- Implement the application specific behavior using a \ref UCT_USBD_User_MSC "template".

\b Media \b Ownership

Sometimes, it is required to implement the ownership control over attached media and changing the ownership between USB and
File System. This is required if you have a device that connects to a PC as a USB MSC device while the storage media also
needs to be accessible to a user application. Using the two functions \ref USBD_MSCn_SetMediaOwnerUSB and
\ref USBD_MSCn_SetMediaOwnerFS you can change the owner of the media to either the USB (the host PC) or the File System (the
user application). The user code template \ref USBD_MSC_UCT "USBD_MSC.c" provides means to manage the ownership.

The following picture shows the connection of the device to the PC and the user application running on the device:

\image html usbd_msc_media_access.png "USB MSC Device connected to a PC with a user application accessing the attached storage medium"

In the file \ref USBD_MSC_UCT "USBD_MSC.c" the variable \c usbd_msc0_media_own is used to set the ownership of the media
device to the application or the File System. In the file \ref USBD_User_MSC_UCT "USBD_User_MSC.c" the variable is used to
initialize it at the beginning of the application (in the \b USBD_MSCn_Initialize function) and to check the ownership of
the media (in the \b USBD_MSCn_CheckMedia function). The application then only makes use of the two functions
\b USBD_MSCn_SetMediaOwnerUSB and \b USBD_MSCn_SetMediaOwnerFS as explained in this
\ref USBD_User_MSC_Application "code example".

\anchor UCT_USBD_User_MSC
\b User \b Code \b Templates
\n There are three user code templates available that help to add support for a MSC device:
-# \ref USBD_User_MSC_UCT "USBD_User_MSC.c" contains all the callback functions that need to be implemented by the user.
-# \ref USBD_MSC_UCT "USBD_MSC.c" is a code template for the application specific functionality of a USB Device MSC instance
   and implements ownership control for attached media devices.
-# \ref USBD_User_MSC_LUN "USBD_User_MSC_LUN.c" is a code template that includes the required callback functions to implement
   multiple logical units (LUNs).

\anchor USBD_User_MSC_UCT
\b User \b Code \b Template \b USBD_User_MSC.c

The following source code can be used to implement the application specific behavior of a USB MSC Device.

\include "USBD_User_MSC.c"


\anchor USBD_MSC_UCT
\b User \b Code \b Template \b USBD_MSC_n.c

The following source code can be used to implement ownership control for attached media devices.

\include "USBD_MSC.c"

\anchor USBD_User_MSC_Application
\b Code \b Example

This code snippet shows how to use the two functions in a user application:
\code
:
switch (DeviceState) {
  
  case DEV_IDLE:
  	break;
  
  case DEV_START_DOING_SOMETHING:
    // hide logical unit
    USBD_MSC0_SetMediaOwnerFS();  
 
    // Application has now access to the media
    // and can do something here (e.g. fopen, fread, fwrite, fclose, ...)
    DeviceState = DEV_DO_IT;
 
    break;
  
  case DEV_STOP_DOING_SOMETHING:
    // show logical unit
    USBD_MSC0_SetMediaOwnerUSB();
 
    // Media is now under control of the USB Host
    // and cannot be accessed by the application
    DeviceState = DEV_IDLE;
 
    break;
}
:
\endcode


\anchor USBD_User_MSC_LUN
\b User \b Code \b Template \b USBD_User_MSC_LUN.c

The following source code can be used to implement multiple logical units (LUNs) in a USB device.

\include "USBD_User_MSC_LUN.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_mscFunctions_api User API
\ingroup usbd_mscFunctions
\brief User API reference of the Mass Storage Class.
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_mscFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_MSCn_Initialize (void)
\details       
The function \b USBD_MSCn_Initialize is called automatically upon initialization of a Mass Storage Class Device and needs no
invocation in the user code.

Modify this function to the application's needs to allocate resources and initialize additional peripherals.

<b>Code Example</b>
\code
#include "rl_usb.h"
  
void USBD_MSC0_Initialize (void) {
 
  uint32_t param_status;
 
  usbd_mscn_media_own = MEDIA_OWN_USB;  // Initially media is owned by USB
  media_ok            = false;          // Current media status (not initialized = not ok)
 
  if (finit (MEDIA_DRIVE) != fsOK) {    // Initialize File System
    return;                             // Exit if failed
  }
 
  drv_id = fs_ioc_get_id (MEDIA_DRIVE); // Get ID of media drive
  if (drv_id < 0)           { return; } // If ID is invalid exit
 
  param_status = 0U;                    // Parameter for function call is 0
                                        // Initialize media
  if (fs_ioc_device_ctrl (drv_id, fsDevCtrlCodeControlMedia, &param_status) != fsOK) {
    return;                             // Exit if failed
  }
 
  if (fs_ioc_lock (drv_id)) {           // Lock media for USB usage
    return;                             // Exit if failed
  }
 
  media_ok = true;                      // Media was initialized and is ok
}
\endcode  
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_MSCn_Uninitialize (void)
\details      
The function \b USBD_MSCn_Uninitialize is called automatically upon de-initialization of a Mass Storage Class Device and
needs no invocation in the user code. If \ref USBD_MSCn_Initialize has been adapted to the application,
\b USBD_MSCn_Uninitialize should release resources and should de-initialize peripherals. 
  
<b>Code Example</b>
\code
#include "rl_usb.h"
 
int main (void)  {
  ..
  USBD_Initialize (0);         // USB Device 0 Initialization
  ...
  USBD_Uninitialize (0);       // USB Device 0 De-Initialization
  ..
}
\endcode  
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_GetCacheInfo (uint32_t *buffer, uint32_t *size);
\details
The function \b USBD_MSCn_GetCacheInfo enables an MSC device to reuse RAM used by the File System for caching purposes as USB
cache. This is required when a USB Host has control over the media so that it cannot be accessed by File System.

The argument \a buffer returns the cache buffer address, while the argument \a size returns the size of the cache buffer.

\b Code \b Example
\code
#include "rl_usb.h"
 
bool USBD_MSC0_GetCacheInfo (uint32_t *buffer, uint32_t *size) {
 
  fsIOC_Cache cache_info;
 
  // Get cache settings of File System
  if (fs_ioc_get_cache(drv_id, &cache_info) != fsOK) {
    return false;                       // Exit if failed
  }
 
  // Use File Systems cache for MSC
  *buffer = (uint32_t)cache_info.buffer;// Cache buffer from File System
  *size   = cache_info.size;            // Cache size
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_GetMediaCapacity (uint32_t *block_count, uint32_t *block_size);
\details
The function \b USBD_MSCn_GetMediaCapacity can be used to determine the geometry of the attached storage media.

The argument \a block_count returns the total number of blocks on the media, while the argument \a block_size
returns the block size of the media.

\b Code \b Example
\code
#include "rl_usb.h"
 
bool USBD_MSC0_GetMediaCapacity (uint32_t *block_count, uint32_t *block_size) {
 
  fsMediaInfo media_info;
 
  // Read media information of actual media
  if (fs_ioc_read_info(drv_id, &media_info) != fsOK) {
    return false;                       // Exit if failed
  }
 
  *block_count = media_info.block_cnt;  // Total number of blocks on media
  *block_size  = media_info.read_blen;  // Block size of blocks on media
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_Read (uint32_t lba, uint32_t cnt, uint8_t *buf)
\details
The function \b USBD_MSCn_Read reads the data that should be returned to the USB Host that requested it.

The argument \a lba specifies the logical address of the first block that is to be read.

The argument \a cnt specifies the number of contiguous blocks to be read from the media.

The argument \a buf is pointing to the buffer where the read data should be stored.

Modify this function to the application's needs.

<b>Code Example</b>
\code
#include rl_usb.h
 
bool USBD_MSC0_Read (uint32_t lba, uint32_t cnt, uint8_t *buf) {
 
                                        // Read data directly from media
  if (fs_ioc_read_sector (drv_id, lba, buf, cnt) != fsOK) {
    return false;
  }
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_Write (uint32_t lba, uint32_t cnt, const uint8_t *buf)
\details
The function \b USBD_MSCn_Write writes data received from the USB Host.

The argument \a lba specifies the logical address of the first block that is to be written.

The argument \a cnt specifies the number of contiguous blocks to be written to the media.

The argument \a buf is pointing to the buffer containing the data to be written.

Modify this function to the application's needs.

<b>Code Example</b>
\code
#include rl_usb.h
 
bool USBD_MSC0_Write (uint32_t lba, uint32_t cnt, const uint8_t *buf) {
 
                                        // Write data directly to media
  if (fs_ioc_write_sector (drv_id, lba, buf, cnt) != fsOK) {
    return false;
  }
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_MSCn_CheckMedia (void)
\details

The function \b USBD_MSCn_CheckMedia is called automatically upon specific USB Host requests (like Test Unit Ready) to check
if media is ready for read/write operations. It needs no invocation in the user code. If media check is not available in
hardware this function can be omitted.

Modify this function to the application's needs.

\b Code \b Example
\code
#include "rl_usb.h"
 
uint32_t USBD_MSC0_CheckMedia (void) {
 
       uint32_t param_status;
       uint8_t  media_state;            // Bit 0. media ready, Bit 1. media write protect
static uint8_t  media_ready_ex = 0U;    // Previous media ready state
       uint8_t  own;
 
  // Get current media status
  media_state = 0U;
  switch (fs_ioc_device_ctrl (drv_id, fsDevCtrlCodeCheckMedia, &param_status)) {
    case fsOK:
      if (param_status & FS_MEDIA_NOCHKMEDIA) {
        // If check media not available on hardware layer
        media_state  =  USBD_MSC_MEDIA_READY;
        break;
      }
      if (param_status & FS_MEDIA_INSERTED) {
        media_state  =  USBD_MSC_MEDIA_READY;
      }
      if (param_status & FS_MEDIA_PROTECTED) {
        media_state |=  USBD_MSC_MEDIA_PROTECTED;
      }
      break;
    case fsError:
    case fsUnsupported:
    case fsAccessDenied:
    case fsInvalidParameter:
    case fsInvalidDrive:
    case fsInvalidPath:
    case fsUninitializedDrive:
    case fsDriverError:
    case fsMediaError:
    case fsNoMedia:
    case fsNoFileSystem:
    case fsNoFreeSpace:
    case fsFileNotFound:
    case fsDirNotEmpty:
    case fsTooManyOpenFiles:
    case fsAlreadyExists:
    case fsNotDirectory:
      break;
  }
 
  // Store current owner so no new request can interfere
  own = usbd_msc0_media_own;
 
  // De-initialize media according to previous owner
  if (own & MEDIA_OWN_CHG) {                    // If owner change requested
    if (own & MEDIA_OWN_USB) {                  // If new requested owner is USB (previous owner was File System)
      (void)funmount (MEDIA_DRIVE);             // De-initialize media and dismount Drive
    } else {                                    // If new requested owner is File System (previous owner was USB)
      (void)fs_ioc_unlock (drv_id);             // Un-lock media
    }
  }
 
  // Initialize media according to current owner
  if ((own & MEDIA_OWN_CHG)        ||           // If owner change requested or
      (media_state ^ media_ready_ex)) {         // if media ready state has changed (disconnect(SD remove)/connect(SD insert))
    if (media_state & USBD_MSC_MEDIA_READY) {   // If media is ready
      if (own & MEDIA_OWN_USB){                 // If current owner is USB
        media_ok     = false;                   // Invalidate current media status (not initialized = not ok)
        param_status = 0U;                      // Parameter for function call is 0
        if (fs_ioc_device_ctrl (drv_id, fsDevCtrlCodeControlMedia, &param_status) == fsOK) {
                                                // Initialization of media has succeeded
          if (fs_ioc_lock (drv_id) == fsOK) {   // If lock media for USB usage has succeeded
            media_ok = true;                    // Media was initialized and is ok
          }
        }
      } else {                                  // If current owner is File System
        if (fmount (MEDIA_DRIVE) == fsOK) {     // Initialize media and Mount Drive for File System usage
          media_ok = true;                      // Media was initialized and is ok
        }
      }
    }
    if (own & MEDIA_OWN_CHG) {
      usbd_msc0_media_own &= ~MEDIA_OWN_CHG;    // Clear request to change media owner if it was handled
    }
    media_ready_ex = media_state & USBD_MSC_MEDIA_READY;
  }
 
  // If media is not ok or owned by File System return that it is not ready for USB
  if ((!media_ok) || (!(usbd_msc0_media_own & MEDIA_OWN_USB))) {
    return 0U;
  }
 
  return media_state;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBD_MSCn_GetMaxLUN (void)
\details
The callback function \b USBD_MSCn_GetMaxLUN returns maximum logical units (LUN) that device contains.

\b Code \b Example
\code
uint8_t USBD_MSC0_GetMaxLUN (void) {
 
  return 2U;                            // Device contains 2 logical units
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_LUN_GetMediaCapacity (uint8_t lun, uint32_t *block_count, uint32_t *block_size)
\details
The callback function \b USBD_MSCn_LUN_GetMediaCapacity retrieves the capacity of a logical unit (LUN).

The argument \a lun specifies the number of the logical unit.

The argument \a block_count specifies the number of available blocks on the media.

The argument \a block_size specifies the block size of the media.

\b Code \b Example
\code
bool USBD_MSC0_LUN_GetMediaCapacity (uint8_t lun, uint32_t *block_count, uint32_t *block_size) {
 
  (void)lun;
 
  *block_count = sizeof(memory)/2/512U; // Total number of blocks on media
  *block_size  = 512U;                  // Block size of blocks on media
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_LUN_Read (uint8_t lun, uint32_t lba, uint32_t cnt, uint8_t *buf)
\details
The callback function \b USBD_MSCn_LUN_Read reads data from a logical unit (LUN).

The argument \a lun specifies the number of the logical unit.

The argument \a lba specifies the logical address of the first block on the media to be read.

The argument \a cnt specifies the number of contiguous blocks to read from media.

The argument \a buf specifies the buffer for storing the data that is read from the media.

\b Code \b Example
\code
bool USBD_MSC0_LUN_Read (uint8_t lun, uint32_t lba, uint32_t cnt, uint8_t *buf) {
 
                                        // Read data from dummy image in RAM
  memcpy (buf, &memory[lun][lba * (512U/4U)], cnt * 512U);
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBD_MSCn_LUN_Write (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf)
\details
The callback function \b USBD_MSCn_LUN_Write writes data to a logical unit (LUN).

The argument \a lun specifies the number of the logical unit.

The argument \a lba specifies the logical address of the first block on the media to be written.

The argument \a cnt specifies the number of contiguous blocks to be written to the media.

The argument \a buf specifies the buffer storing the data that is to be written to the media.

\b Code \b Example
\code
bool USBD_MSC0_LUN_Write (uint8_t lun, uint32_t lba, uint32_t cnt, const uint8_t *buf) {
 
                                        // Write data to image in RAM
  memcpy (&memory[lun][lba * (512U/4U)], buf, cnt * 512U);
 
  return true;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_MSCn_LUN_CheckMedia (uint8_t lun)
\details
The callback function \b USBD_MSCn_LUN_CheckMedia checks the media presence and write protection status of a logical unit
(LUN).

The argument \a lun specifies the number of the logical unit.

\b Code \b Example
\code
uint32_t USBD_MSC0_LUN_CheckMedia (uint8_t lun) {
 
  (void)lun;
 
  return USBD_MSC_MEDIA_READY;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_MSCn_SetMediaOwnerUSB (void)
\details
The function \b USBD_MSCn_SetMediaOwnerUSB sets the USB Bus to the media owner of the attached media (drive). This will make
the media unavailable to the File System Component. Use \ref USBD_MSCn_SetMediaOwnerFS to enable ownership of the media for
the File System Component.

\b Code \b Example
\code
int32_t USBD_MSC0_SetMediaOwnerUSB (void) {
  uint32_t timeout_cnt;
 
  timeout_cnt = 300U;                   // 3 second timeout (300 * 10 ms)
  usbd_msc0_media_own = USBD_MSC0_MEDIA_OWN_CHG | USBD_MSC0_MEDIA_OWN_USB;
  while (usbd_msc0_media_own & USBD_MSC0_MEDIA_OWN_CHG) {
    osDelay(10);
    if ((--timeout_cnt) == 0) { return USBD_MSC0_ERROR; }
  }
 
  return USBD_MSC0_OK;
}
\endcode

This function can be modified in the user code template file <b>USBD_MSC_<i>n</i>.c</b>. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBD_MSCn_SetMediaOwnerFS (void)
\details
The function \b USBD_MSCn_SetMediaOwnerFS sets the File System Component to the media owner of the attached media (drive).
This will make the media unavailable to the USB Bus. Use \ref USBD_MSCn_SetMediaOwnerUSB to enable ownership of the media for
the USB Bus.

\b Code \b Example
\code
int32_t USBD_MSC0_SetMediaOwnerFS (void) {
  uint32_t timeout_cnt;
 
  timeout_cnt = 300U;                   // 3 second timeout (300 * 10 ms)
  usbd_msc0_media_own = USBD_MSC0_MEDIA_OWN_CHG;
  while (usbd_msc0_media_own & USBD_MSC0_MEDIA_OWN_CHG) {
    osDelay(10);
    if ((--timeout_cnt) == 0) { return USBD_MSC0_ERROR; }
  }
 
  return USBD_MSC0_OK;
}
\endcode

This function can be modified in the user code template file <b>USBD_MSC_<i>n</i>.c</b>. 
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_mscFunctions_conf Configuration
\ingroup usbd_mscFunctions
\brief Configuration of the USB Device MSC Class.
\details
This configuration file defines:
  - The assignment of the MSC class to the USB Device instance.
  - \ref USB_Endpoints "USB Endpoint" assignments for the MSC class with parameters for Full/Low-speed and High-speed
    communication.
  - Class Settings for the Interface Descriptor.
	
These settings are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and \ref USB_Endpoint_Descriptor
"Endpoint Descriptor" of the related USB Device Class. It is important that the settings match the application specific
behavior in the related C source file USBD_User_MSC_<i>n</i>.c.

\image  html usbd_config_msc_h.png "MSC Class Configuration File"

The USB Device MSC Class configuration file <b>USBD_Config_MSC_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects USB Device that is used for this Device Class instance.
- <b>Bulk Endpoint Settings</b>
 - <b>Bulk IN Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Bulk OUT Endpoint Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
 - <b>Endpoint Settings</b>
  - <b>Maximum Endpoint Packet Size (in bytes)</b> specifies the physical packet size used for information exchange. This
    setting is available for low-/full- and high-speed endpoints.
  - <b>Maximum NAK Rate</b> specifies the interval in which Bulk Endpoint can NAK. This setting is available only for
    high-speed endpoints.
- <b>Mass Storage Class Settings</b>
 - <b>Mass Storage Class Interface String</b> is used to create \ref USB_Descriptors.
 - <b>Number of Logical Units (LUN)</b> specifies the number of logical units in a USB device (up to four).
 - <b>Logical Unit n Inquiry Data</b> is returned on Get Inquiry request for Logical Unit n from the USB Host.
  - <b>Vendor Identification</b> specifies the vendor of the MSC device.
  - <b>Product Identification</b> specifies the product identification of the MSC device.
  - <b>Product Revision Level</b> specifies the product revision of the MSC device.
 - <b>Maximum Mass Storage Device Bulk Buffer Size</b> is used to create \ref USB_Descriptors.
- <b>OS Resources Settings</b>
 - <b>Mass Storage Class Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Mass Storage Device Class Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_MSC<i>n</i>_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_classFunctions Custom Class
\ingroup usbd_DevClassFunctions
\brief Implement application specific behavior of a Custom Class USB Device.
\details
The Custom Class in the USB Component may be used to implement any type of USB Device class.

Refer to:
  - \ref CustomClass for an overview of the Custom Class.

The USB Component allows multiple instances of the Custom class. This feature may be used to create USB Composite Devices.
Each Custom Class instance has separate files and interface functions:
  - A configuration file \ref usbd_classFunctions_conf "USBD_Config_CustomClass_n.h".
  - An application-specific user source code file which may be implemented with the \urlout{uv4_ca_sourcefiles} <b>USBD_User_CustomClass_<i>n</i>.c</b>.
  - Functions that start with the prefix <b>USBD_CustomClass<i>n</i>_</b> are available for each instance of a Custom Class.

This documentation uses <i>n</i> as a placeholder for the instance number <i>0</i> - <i>3</i>.
Most applications require only one instance of a Custom Class. For the first Custom Class instance 
the instance number is 0:
  - <b>USBD_Config_CustomClass_0.h</b>
  - <b>USBD_User_CustomClass_0.c</b>
  - The function prefix is <b>USBD_CustomClass0_</b>
  
Software Structure
------------------
The handling of the Custom Class endpoint events is implemented in an USBD_CustomClassn_Endpointx_Event for every endpoint.
Each endpoint (or pair of IN/OUT endpoints with the same endpoint number) uses an own thread in order to allow a parallel
functionality of every interface.

### Setup Packets on Control Endpoint 0 ###
Setup packets sent to Control Endpoint 0 are received by the USB Device Core. The USB Device Core will call the
\ref USBD_Devicen_Endpoint0_SetupPacketReceived function and pass the setup packet to it. Depending on the 
return code of \b USBD_Devicen_Endpoint0_SetupPacketReceived, the USB Device Core either passes the processing to the Custom Class 
function if custom class is used and if message is addressed to a custom class by calling 
\ref USBD_CustomClassn_Endpoint0_SetupPacketReceived function or continues to process the received setup packet itself.
Depending on the return code of \b USBD_CustomClassn_Endpoint0_SetupPacketReceived, processing of the setup packet is 
either done or continues to be processed by USB Device Core.

USB Device Core will call \ref USBD_Devicen_Endpoint0_SetupPacketProcessed and depending on return code it will call 
\ref USBD_CustomClassn_Endpoint0_SetupPacketProcessed to inform the application that setup packet has been processed by USB Device Core.

If custom handling of request was used and request contains data stage, USB Device Core will call \ref USBD_Devicen_Endpoint0_OutDataReceived and 
depending on return code it will call \ref USBD_CustomClassn_Endpoint0_OutDataReceived after data expected by request was received, it will call 
\ref USBD_Devicen_Endpoint0_InDataSent and depending on return code it will call \ref USBD_CustomClassn_Endpoint0_InDataSent 
after data expected by request was sent.

\msc
 a [label="",                                                    textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBDn_Core_Thread\n osProrityAboveNormal",            textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBD_CustomClassn_EP1_Thread\n osProrityAboveNormal", textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="USBD_CustomClassn_EP2_Thread\n osProrityAboveNormal", textcolor="violet", linecolor="violet", arclinecolor="violet"],
 e [label="",                                                    textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                                  textbgcolour="#FFCCCF"],
 b note b [label="Handle Endpoint 0 Control Transfers",          textbgcolour="#E0E0FF"],
 c note c [label="Handle Events on Endpoint 1",                  textbgcolour="#E0FFE0"],
 d note d [label="Handle Events on Endpoint 2",                  textbgcolour="#FFD6FC"],
 e note e [label="USB Bus",                                      textbgcolour="#999999"];
 
 a box a  [label="USBD_Initialize", URL="\ref USBD_Initialize"];
 ---      [label="USBD Threads started"];
 a box a  [label="USBD_Connect", URL="\ref USBD_Connect"],
 e box e  [label="Connection pull-up activate"];
 ---      [label="USBD communication established"];

 ...;
 b box b  [label="USBD_CustomClassn_EndpointStart(OUT endpoint)", URL="\ref USBD_CustomClassn_EndpointStart"],
 a box a  [label="USBD_EndpointRead", URL="\ref USBD_EndpointRead"];

 ...;
 e box e  [label="SETUP packet"],
 b box b  [label="USBD_CustomClassn_Endpoint0_SetupPacketReceived\n(no data stage)", URL="\ref USBD_CustomClassn_Endpoint0_SetupPacketReceived"];
 e box e  [label="OUT ZLP"];

 ...;
 e box e  [label="SETUP packet"],
 b box b  [label="USBD_CustomClassn_Endpoint0_SetupPacketReceived\n(data from device to host)", URL="\ref USBD_CustomClassn_Endpoint0_SetupPacketReceived"];

 ...;
 e box e  [label="IN data sent"],
 b box b  [label="USBD_CustomClassn_Endpoint0_InDataSent", URL="\ref USBD_CustomClassn_Endpoint0_InDataSent"];
 e box e  [label="OUT ZLP"];

 ...;
 e box e  [label="SETUP packet"],
 b box b  [label="USBD_CustomClassn_Endpoint0_SetupPacketReceived\n(data from host to device)", URL="\ref USBD_CustomClassn_Endpoint0_SetupPacketReceived"];

 ...;
 e box e  [label="OUT data received"],
 b box b  [label="USBD_CustomClassn_Endpoint0_OutDataReceived", URL="\ref USBD_CustomClassn_Endpoint0_OutDataReceived"];
 e box e  [label="IN ZLP"];

 ...;
 a box a  [label="USBD_EndpointWrite", URL="\ref USBD_EndpointWrite"],
 e box e  [label="Endpoint1 IN Data Sent"],
 c box c  [label="USBD_CustomClassn_Endpoint1_Event", URL="\ref USBD_CustomClassn_Endpoint1_Event"];

 ...;
 e box e  [label="Endpoint2 OUT Data Received"],
 d box d  [label="USBD_CustomClassn_Endpoint2_Event", URL="\ref USBD_CustomClassn_Endpoint2_Event"];
 a box a  [label="USBD_EndpointRead", URL="\ref USBD_EndpointRead"];

 ...;
 a box a  [label="USBD_Disconnect", URL="\ref USBD_Disconnect"],
 e box e  [label="Connection pull-up deactivate"];
 ---      [label="USBD communication stopped"];
 a box a  [label="USBD_Uninitialize", URL="\ref USBD_Uninitialize"];
 ---      [label="USBD Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbd_create_app "create an USB Device" with a Custom Class:
  - Set the required number for <b>USB:Device:Custom</b> class instances during the \ref RTE_Software_Component_Selection.
  - Set the parameters in the configuration file \ref usbd_classFunctions_conf "USBD_Config_CustomClass_n.h".
  - Implement the application specific behavior using one of the available \ref USBD_User_UCT "templates".

\anchor USBD_User_UCT
User Code Templates
-------------------

Two \urlout{uv4_ca_sourcefiles} files are available to implement the application-specific behavior:
 - \ref USBD_User_Cust_UCT "USBD_User_CustomClass.c" is used for custom handling of class requests to instances of a custom
   class.
 - \ref USBD_User_Device_Cust_UCT "USBD_User_Device_n.c" is used for custom handling of any request coming to the USB Device. Its
   primary use is to allow for custom handling of standard and vendor requests, for example overriding the serial number
   string. It allows to intercept all incoming requests and to override the default USB Component handling.
   
Both user code templates contain example code that can be used to demonstrate the features of the templates. Uncomment this
code to see how it works on your target hardware. 

\anchor USBD_User_Cust_UCT
\b USBD_User_CustomClass.c

\include "USBD_User_CustomClass.c"

\anchor USBD_User_Device_Cust_UCT
<b>USBD_User_Device_<i>n</i>.c</b>

\include "USBD_User_Device.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbd_classFunctions_api User API
\ingroup usbd_classFunctions
\brief User API reference of the Custom Device Class.
\details
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\addtogroup usbd_classFunctions_api
@{
*/


//  ==== USB Device Custom Class Functions ====

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Initialize (void);
\details
The function \b USBD_CustomClassn_Initialize is called when the USB Device containing the custom class is initialized. This
function should be adapted to clear all variables and to setup all required interfaces.

<b>Code Example</b>
\code
#include "rl_usb.h"
 
int main (void) {
  ..
  USBD_Initialize (0);   // USB Device 0 Initialization
  ...
  USBD_Uninitialize (0); // USB Device 0 De-Initialization
  ..
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Uninitialize (void);
\details
The function \b USBD_CustomClassn_Uninitialize is called when the USB Device containing the custom class is uninitialized and
needs no invocation in the user code. If \ref USBD_CustomClassn_Initialize has been adapted to the application,
\b USBD_CustomClassn_Uninitialize should release resources and should de-initialize interfaces and peripherals.

<b>Code Example</b>
\code
#include "rl_usb.h"
 
int main (void) {
  ..
  USBD_Initialize (0);   // USB Device 0 Initialization
  ...
  USBD_Uninitialize (0); // USB Device 0 De-Initialization
  ..
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Reset (void);
\details
The function \b USBD_CustomClassn_Reset is called when a reset condition happens on the USB bus. Initialization of the
instance's local parameters and variables should be done in this function.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_EndpointStart (uint8_t ep_addr);
\details
The function \b USBD_CustomClassn_EndpointStart is called for each endpoint that is a part of an activated
interface of a Custom Class. Start data reception (\ref USBD_EndpointRead) here, if the enabled endpoint is of type
OUT.

The argument \a ep_addr determines the endpoint that is to be started.
<b>Code Example</b>
\code
void USBD_CustomClass0_EventEndpointStart (uint8_t ep_addr) {
  
  if (!(ep_addr & 0x80)) {              // If Endpoint type is OUT
    switch (ep_addr & 0x0F) {
      case 1:
        USBD_EndpointRead(0, ep_addr, class0_bulk_out_buf, 64);
        break;
      default:
        break;
    }
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_EndpointStop (uint8_t ep_addr);
\details
The function \b USBD_CustomClassn_EndpointStop is called for each endpoint that is a part of an deactivated interface
of a Custom Class.

<b>Code Example</b>
\code
void USBD_CustomClass0_EventEndpointStop (uint8_t ep_addr) {
  
  if (!(ep_addr & 0x80)) {              // If Endpoint type is OUT
    switch (ep_addr & 0x0F) {
      case 1:
        USBD_EndpointAbort(0, ep_addr);
        break;
      default:
        break;
    }
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_CustomClassn_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, uint32_t *len);
\details
The callback function \b USBD_CustomClassn_Endpoint0_SetupPacketReceived function will be called by the USB Device Core when a setup
packet has been received. Further handling by the USB Device Core is determined by the return code of this callback function.

The argument \a setup_packet specifies the setup packet that has been received.

The argument \a buf specifies the buffer for the data stage (in case the application will continue to process the setup packet)

The argument \a len specifies the length of the data for the data stage.

<b>Code Example</b>
\code
usbdRequestStatus USBD_CustomClass0_Endpoint0_SetupPacketReceived (const USB_SETUP_PACKET *setup_packet, uint8_t **buf, int32_t *len) {
  
  switch (setup_packet->bmRequestType.Type & 3) {
    case USB_REQUEST_STANDARD:
      break;
    case USB_REQUEST_CLASS:
      switch (setup_packet->bmRequestType.Recipient) {
        case USB_REQUEST_TO_DEVICE:
          break;
        case USB_REQUEST_TO_INTERFACE:
          break;
        case USB_REQUEST_TO_ENDPOINT:
          break;
        default:
          break;
      }
      break;
    case USB_REQUEST_VENDOR:
      break;
    case USB_REQUEST_RESERVED:
      break;
  }

  return usbdRequestNotProcessed;
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet);
\details
The callback function \b USBD_CustomClassn_Endpoint0_SetupPacketProcessed SetupPacketProcessed will be called by the USB Device Core
when a setup packet was processed by the USB Device Core. This callback function acts as a notification only, so it has no return
value.

<b>Code Example</b>
\code
void USBD_CustomClass0_Endpoint0_SetupPacketProcessed (const USB_SETUP_PACKET *setup_packet) {
  switch (setup_packet->bmRequestType.Type & 3) {
    case USB_REQUEST_STANDARD:
      break;
    case USB_REQUEST_CLASS:
      switch (setup_packet->bmRequestType.Recipient) {
        case USB_REQUEST_TO_DEVICE:
          break;
        case USB_REQUEST_TO_INTERFACE:
          break;
        case USB_REQUEST_TO_ENDPOINT:
          break;
        default:
          break;
      }
      break;
    case USB_REQUEST_VENDOR:
      break;
    case USB_REQUEST_RESERVED:
      break;
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_CustomClassn_Endpoint0_OutDataReceived (uint32_t len);
\details
The callback function \b USBD_CustomClassn_Endpoint0_OutDataReceived will be called by the USB Device Core when data is available
for further processing by the application (the return code of a previous \ref USBD_CustomClassn_Endpoint0_SetupPacketReceived was
usbdRequestOK).

The argument \a len determines the length of the data that is received.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbdRequestStatus USBD_CustomClassn_Endpoint0_InDataSent (uint32_t len);
\details
The callback function \b USBD_CustomClassn_Endpoint0_InDataSent will be called by the USB Device Core when data is available for
further processing by the application (the return code of a previous \ref USBD_CustomClassn_Endpoint0_SetupPacketReceived
was usbdRequestOK).

The argument \a len determines the length of the data that is sent.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint1_Event  (uint32_t event);
\details
The callback function \b USBD_CustomClassn_Endpoint1_Event is called by the USB Device Core when an event happens on endpoint 1.
This function can use the \ref USBD_EndpointRead, \ref USBD_EndpointWrite, \ref USBD_EndpointStall 
and \ref USBD_EndpointAbort functions.

The argument \a event specifies the event on the endpoint.
<b>Code Example</b>
\code
void USBD_CustomClass0_Endpoint1_Event  (uint32_t event) {
  uint32_t i;
  
  if (event & ARM_USBD_EVENT_OUT) {
    class0_bulk_len = USBD_EndpointReadGetResult (0, 0x01);
    USBD_EndpointRead(0, 0x01, class0_bulk_out_buf, 64);
    switch (class0_bulk_out_buf[0]) {
      case 0:
        for (i = 1; i < class0_bulk_len; i++) {
          class0_bulk_in_buf[i] = (class0_bulk_out_buf[i] << 4);
        }
        USBD_EndpointWrite(0, 0x81, class0_bulk_in_buf,  class0_bulk_len);
        break;
    }
  }
  if (event & ARM_USBD_EVENT_IN) {
  }
}
\endcode

\note
If USB driver uses DMA and USB buffer for incoming data (OUT transfers) is in cached (write-back policy) memory, 
please ensure that buffer is aligned correctly and that it's size is as required by cache handling.
For example Cortex-M7 cache handling requires that this buffer is aligned on 32 byte and that it's size is 
multiple of 32 bytes (cache line size).

*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint2_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint3_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint4_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint5_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint6_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint7_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint8_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint9_Event  (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint10_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint11_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint12_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint13_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint14_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBD_CustomClassn_Endpoint15_Event (uint32_t event);
\details
Refer to \ref USBD_CustomClassn_Endpoint1_Event for more information
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_EndpointRead (uint8_t device, uint8_t ep_addr, uint8_t *buf, uint32_t len);
\details
The function \b USBD_EndpointRead starts the reception of a number of bytes specified by \a len on the OUT endpoint 
\a ep_addr to the buffer provided by \a buf. The reception is finished when either the requested number of bytes have been 
received or reception is terminated by reception of a short packet. When the reception is finished, the 
\c ARM_USBD_EVENT_OUT event is sent to the USBD_CustomClassn_Endpointx_Event thread (with x specifying the endpoint number 
that was used for the read (receive) operation).

USBD_EndpointReadGetResult() can be used to retrieve number of received bytes after receive operation has finished (event was
sent).

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the OUT endpoint address for data reception.

The argument \a buf is pointing to the buffer for the data.

The argument \a len specifies the number of bytes to be read (must be multiple of endpoint maximum packet size).
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_EndpointReadGetResult (uint8_t device, uint8_t ep_addr);
\details
The function \b USBD_EndpointReadGetResult gets number of received bytes on an endpoint.

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the endpoint address that carries the data.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_EndpointWrite (uint8_t device, uint8_t ep_addr, const uint8_t *buf, uint32_t len);
\details
The function \b USBD_EndpointWrite starts the transmission of a number of bytes specified by \a len on the IN endpoint 
\a ep_addr from the buffer provided by \a buf. When the transmission is finished, the \c ARM_USBD_EVENT_IN 
event is sent to the USBD_CustomClassn_Endpointx_Event thread (with x specifying the endpoint number that was used for 
the write (transmit) operation).

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the IN endpoint address for sending the data.

The argument \a buf is pointing to the buffer containing the data.

The argument \a len specifies the number of bytes to be written.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBD_EndpointWriteGetResult (uint8_t device, uint8_t ep_addr);
\details
The function \b USBD_EndpointWriteGetResult gets number of sent bytes on an endpoint.

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the endpoint address for sending the data.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_EndpointStall (uint8_t device, uint8_t ep_addr, bool stall);
\details
The function \b USBD_EndpointStall sets or clears stall on an endpoint.

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the endpoint address.

The argument \a stall specifies set or clear operation.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBD_EndpointAbort (uint8_t device, uint8_t ep_addr);
\details
The function \b USBD_EndpointAbort aborts the transfer on an endpoint.

The argument \a device specifies the USB Device instance.

The argument \a ep_addr specifies the endpoint address.
*/


/**
@}
*/


/**
\defgroup usbd_classFunctions_conf Configuration
\ingroup usbd_classFunctions
\brief Configuration of the USB Device Custom Class.
\details
This configuration file defines:
  - The assignment of the Custom Class to the USB Device instance.
  - Up to four interfaces that
    - can have bulk, interrupt and isochronous IN and OUT endpoints. Every endpoint can be configured for full/low-speed or
    high-speed operation.
    - carry their own class, subclass, and protocol code. Also, an interface string can be defined separately.
    - have a independent Interface Descriptor.
  - Thread stack size settings for every endpoint separately. To allow parallel functionality of the four interfaces, every
    endpoint (or pair of IN/OUT endpoints on the same endpoint number) uses one thread.
  
These settings are used to create the \ref USB_Interface_Descriptor "Interface Descriptor" and \ref USB_Endpoint_Descriptor
"Endpoint Descriptor" of the related USB Device Class. It is important that the settings match the application specific
behavior in the related C source file USBD_User_CustomClass_<i>n</i>.c.

\image  html usbd_config_customclass_h.png "Custom Class Configuration File"

The USB Device Custom Class configuration file <b>USBD_Config_CustomClass_n.h</b> contains the following settings:
- <b>Assign Device Class to USB Device #</b> selects USB Device that is used for this Device Class instance.
- <b>Interface Association</b> enables usage and settings for Interface Association Descriptor (IAD).
  - <b>Class Code</b> defines the interface association <a href="https://www.usb.org/defined-class-codes" target="_blank">class code</a>.
  - <b>Subclass Code</b> defines the interface association <a href="https://www.usb.org/defined-class-codes" target="_blank">subclass code</a>.
  - <b>Protocol Code</b> defines the interface association <a href="https://www.usb.org/defined-class-codes" target="_blank">protocol code</a>.
- <b>Interface</b>
 - <b>Interface Settings</b>
  - <b>Interface Number</b> defines the value for \ref USB_Interface_Descriptor "bInterfaceNumber".
  - <b>Alternate Setting</b> defines the value for \ref USB_Interface_Descriptor "bAlternateSetting".
  - <b>Class Code</b> defines the <a href="https://www.usb.org/defined-class-codes" target="_blank">class code</a>.
  - <b>Subclass Code</b> defines the <a href="https://www.usb.org/defined-class-codes" target="_blank">subclass code</a>.
  - <b>Protocol Code</b> defines the <a href="https://www.usb.org/defined-class-codes" target="_blank">protocol code</a>.
 - <b>Endpoint Settings</b>
  - <b>Endpoint</b>: Select if the specified Endpoint exists in this interface.
  - <b>Type</b> sets the type of the endpoint.
  - <b>Number</b> sets the number of the endpoint to be used. Conflicting settings are flagged by
    compile-time error messages.
   - <b>Maximum Endpoint Packet Size</b> specifies the physical packet size used for information exchange (in bytes). This
     setting is available for full/low and high-speed endpoints.
   - <b>Additional Transactions per Microframe</b> specifies additional transactions per microframe.
     This setting is available only for high-speed interrupt or isochronous endpoints.
   - <b>Endpoint Polling Interval (in xxx)</b> specifies the frequency of requests initiated by USB Host. This setting
     is available for full/low and high-speed endpoints. In case of high-speed device and bulk endpoint it represents
     maximum NAK rate.
 - <b>String Settings</b>
  - <b>Interface String Enable</b> is used to enable/disable interface string creation.
    - <b>Interface String</b> configures the string descriptor content.
 - <b>Microsoft OS Descriptor Settings</b> are used to create the Microsoft OS Extended Compat ID Feature descriptor.
  - <b>Extended Compat ID OS Feature Descriptor Function Section</b> is used to configure function section 
    within Extended Compat ID OS Feature descriptor.
    - <b>compatibleID</b> configures the function's compatible ID.
    - <b>subCompatibleID</b> configures the function's subcompatible ID.
  - <b>Extended Properties OS Feature Descriptor</b> are settings used to create the custom property sections 
    within Microsoft Extended Properties OS Feature descriptor.
    - <b>Custom Property Section x</b> is used to configure the custom property section x 
      of Microsoft Extended Properties OS Feature descriptor.
      - <b>Data Type</b> configures the custom property section x property data format.
      - <b>Name</b> configures the custom property section x property name.
      - <b>Data</b> configures the custom property section x property data.
        - <b>Unicode String</b> configures the custom property section x property data if Data Type is selected as Unicode String.
        - <b>32-bit Integer</b> configures the custom property section x property data if Data Type is selected as 32-bit Integer.
- <b>OS Resources Settings</b>
 - <b>Endpoint x Thread Stack Size</b> is used for memory allocation in the USB component.
 - The default Endpoint x Thread priority is <b>osPriorityAboveNormal</b>.
   This priority can be changed by changing USBD_CUSTOM_CLASS<i>n</i>_EP<i>x</i>_THREAD_PRIORITY define in this configuration file.
   This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
   Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup 	usbd_data_types  Data Types
\ingroup 	usbd
\brief 		Public Data Types used by USB Device component
*/

/**
\addtogroup usbd_data_types
@{
\struct USBD_STATE
\brief USB Device State structure
\details
<b>Used in</b>
- Function: \ref USBD_GetState; 

\struct USB_SETUP_PACKET
\brief USB Setup Packet structure
\details
<b>Used in</b>
- USB Device Function: \ref USBD_CustomClassn_Endpoint0_SetupPacketReceived; \ref USBD_CustomClassn_Endpoint0_SetupPacketProcessed;

\struct CDC_LINE_CODING
\brief CDC Line Coding structure
\details
<b>Used in</b>
- USB Device Function: \ref USBD_CDCn_ACM_SetLineCoding; \ref USBD_CDCn_ACM_GetLineCoding;

\struct CDC_NCM_NTB_PARAM
\brief CDC NCM NTB Parameters structure
\details
<b>Used in</b>
- USB Device Function: \ref USBD_CDCn_NCM_GetNtbParameters;

\struct usbd_desc_t
\brief USB Device Descriptors structure
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
//   ==== USB Host Functions ====
/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh USB Host
\brief    Functions for the USB Host Component.
\details

Refer to \ref USB_Host for more information of the USB Host Component.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   usbh_coreFunctions        Core
\ingroup  usbh
\brief    Initialize and manage the USB Host Core.
\details

The USB Host Core is a hardware independent layer and contains the functions to manage USB Controller and USB Devices connected
to this controller.
It is Interface between the USB Host Controller Driver and the USB Host Classes. The most important functions of USB Host Core:
  - USBH_Initialize() which initializes the USB Host.
  - USBHn_Core_Thread is started which enables reacting to USB bus events.
  - The USB Host Controller Driver is the layer between the USB Host Controller Hardware and the USB Host Core. This layer
    handles hardware specific interfaces.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_coreFunctions_api User API
\ingroup usbh_coreFunctions
\brief User API reference of the USB Host Core.
\details
*/


/**
\addtogroup   usbh_coreFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBH_GetVersion (void)

\details
The function \b USBH_GetVersion retrieves version of the USB Host Component.

Version is encoded as follows:
 - decimal digits 9..7: major
 - decimal digits 6..4: minor
 - decimal digits 3..0: patch

\note Example: value 10020003 decimal represents version: major = 1, minor = 2, patch = 3
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Initialize (uint8_t ctrl)

\details
The function \b USBH_Initialize initializes the USB Host Stack and the USB Host Controller Hardware and prepares the USB Host Controller
to detect whether an USB device gets attached or detached from the USB bus. It starts a thread responsible for the USB Device enumeration process.
Call this function before calling any other USB Host functions. The function does not initialize any non-USB Host hardware features.

<b>Code Example</b>
\code
#include <rl_usb.h>
 
int main (void)  {
  ..
  USBH_Initialize(0);               // USB Host 0 Initialize
  ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Uninitialize (uint8_t ctrl)
\details
The function \b USBH_Uninitialize de-initializes the USB Host Stack and the USB Host Controller Hardware. It can be used if
during the application run-time the USB Host Stack needs to be disabled for whatever reason (for example for lowering power
consumption). Reinitialize the USB Host Stack only with \ref USBH_Initialize.

<b>Code Example</b>
\code
#include <rl_usb.h>
 
int main (void)  {
  ..
  USBH_Initialize(0);               // USB Host 0 Initialize
  ..
  USBH_Uninitialize(0);             // USB Host 0 De-Initialize
  ..
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Port_Suspend (uint8_t ctrl, uint8_t port)
\details
The function \b USBH_Port_Suspend suspends the USB bus, stops generating Start Of Frame or Keep-Alive signals.

The argument \a ctrl specifies the USB Host controller number.

The argument \a port specifies the USB Host root HUB port number.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Port_Resume (uint8_t ctrl, uint8_t port)
\details
The function \b USBH_Port_Resume re-activates the USB bus from suspended state, starts generating Start Of Frame or
Keep-Alive signals.

The argument \a ctrl specifies the USB Host controller number.

The argument \a port specifies the USB Host root HUB port number.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_Device_GetController (uint8_t device)
\details
The function \b USBH_Device_GetController retrieves the USB Host controller index to which the requested device is connected to.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_Device_GetPort (uint8_t device)
\details
The function \b USBH_Device_GetPort retrieves the USB Host root HUB port index to which the requested device is connected to.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Device_GetStatus (uint8_t device)
\details
The function \b USBH_Device_GetStatus checks if a device instance is connected and initialized.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBH_Device_GetSpeed (uint8_t device)
\details
The function \b USBH_Device_GetSpeed retrieves current communication speed of the connected device.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBH_Device_GetAddress (uint8_t device)
\details
The function \b USBH_Device_GetAddress retrieves current communication address of the connected device.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t USBH_Device_GetVID (uint8_t device)
\details
The function \b USBH_Device_GetVID retrieves Vendor ID of the connected device.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint16_t USBH_Device_GetPID (uint8_t device)
\details
The function \b USBH_Device_GetPID retrieves Product ID of the connected device.

The argument \a device specifies the instance of the device.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_Device_GetStringDescriptor (uint8_t device, uint8_t index, uint16_t language_id, uint8_t *descriptor_data, uint16_t descriptor_length)
\details
The function \b USBH_Device_GetStringDescriptor is used for retrieving string descriptor form the device and is implemented with standard device request \c GET_DESCRIPTOR.
This request returns the specified string descriptor if the descriptor exists. 

The argument \a device specifies the instance of the device.

The argument \a index specifies the string descriptor index.

The argument \a language_id specifies the Language ID of string descriptor.

The argument \a descriptor_data is a pointer to where descriptor data will be read and \a descriptor_length specifies the
number of bytes to return.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_Notify (uint8_t ctrl, uint8_t port, uint8_t device, USBH_NOTIFY notify)
\details
The function \b USBH_Notify is called from the USB Host Core module on any of the available notification events. For
example, when a device is connected to a USB port, this function will get called with the notification value
USBH_NOTIFY_CONNECT.

The argument \a ctrl specifies the USB Host controller number.

The argument \a port specifies the USB Host root HUB port number.

The argument \a device specifies the instance of the device.

The argument \a notify specifies the type of event that has occurred.

<b>Code Example</b>
\code
#include <Board_LED.h>
#include <rl_usb.h>
 
void USBH_Notify (uint8_t ctrl, uint8_t port, uint8_t device, USBH_NOTIFY notify) {
  switch (notify) {
    case USBH_NOTIFY_CONNECT:
      // A new device was connected on port
      LED_On(0);
      break;
    case USBH_NOTIFY_DISCONNECT:
      // A device was dis-connected from a port
      LED_Off(0);
      break;
    case USBH_NOTIFY_OVERCURRENT:
      // An overcurrent has happened on a port
      break;
    case USBH_NOTIFY_REMOTE_WAKEUP:
      // Resume signaling has started on a port
      break;
    case USBH_NOTIFY_READY:
      // Device was enumerated, initialized and is ready for communication
      break;
    case USBH_NOTIFY_UNKNOWN_DEVICE:
      // A new device was connected but USB Host does not have a driver for it
      break;
    case USBH_NOTIFY_INSUFFICIENT_POWER:
      // A new device was connected but we can not supply it with enough power
      break;
    case USBH_NOTIFY_CONFIGURATION_FAILED:
      // A new device was connected but there aren't enough of resources to use it
      break;
    case USBH_NOTIFY_INITIALIZATION_FAILED:
      // A new device was connected but initialization of it has failed
      break;
  }
}
 
int main (void)  {
  ..
  LED_Initialize();
  USBH_Initialize(0);               // USB Host 0 Initialize
  ..
  USBH_Uninitialize(0);             // USB Host 0 De-Initialize
  ..
}
\endcode
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_coreFunctions_conf Configuration
\ingroup usbh_coreFunctions
\brief Configuration of the USB Host Core.
\details
The configuration file <b>USBH_Config_<i>n</i>.h</b> contains generic settings for the USB Host. Support for certain USB
Classes is configured in the respective device class configuration files (\ref usbh_cdcacmFunctions_conf "USBH_Config_CDC.h",
\ref usbh_customFunctions_conf "USBH_Config_CustomClass.h", \ref usbh_hidFunctions_conf "USBH_Config_HID.h" and
\ref usbh_mscFunctions_conf "USBH_Config_MSC.h").


\image  html usbh_config_0_h.png "USB Host Configuration File"

The USB Host configuration file <b>USBH_Config_<i>n</i>.h</b> contains the following settings:
- <b>Connect to hardware via Driver_USBH#</b> specifies the hardware driver number to use in case that microcontroller device
  contains more than one USB Host interface. For device with single USB Host Controller it will typically be '0'.
- <b>Maximum Port Power Delivery (in mA)</b> specifies maximum current that a port can source (in mA).
  USB Devices exceeding this requirement will not be usable by the USB Host.
- <b>Maximum Pipes in System</b> specifies the maximum number of active pipes (pipe is a communication channel to an USB Device endpoint).
- <b>Memory Pool</b> specifies the size of the USB memory pool and is also used for locating the USB memory pool in a specific memory.
  - <b>Size</b> specifies the size of the USB memory pool (in bytes) that the USB Host controller will use for the USB communication data.
    This size should be at least equal to the size of the maximum expected packet + 128 bytes.
  - <b>Locate</b> specifies if the USB memory pool is located in a specific memory (via the linker script).
    This is usually necessary in case that USB Controller has some specific requirements regarding memory for USB transfers.
    For example if USB Controller can only access specific memory, or if this memory needs to be non-cacheable.
  - <b>Section Name</b> specifies the section name for the USB memory pool that is used by the linker script to position it in memory.
    Default section name is <c>.driver.usbh<instance></c>, for example for USB Controller 0 the default section name is <c>.driver.usbh0</c>.
- Use the <b>OS Resources Settings</b> to optimize the usage of OS resources.
  - The default <b>Core Thread Stack Size</b> is \a 2048 bytes.
  - The default Core Thread priority is <b>osPriorityAboveNormal</b>.
    This priority can be changed by changing USBH<i>n</i>_CORE_THREAD_PRIORITY define in this configuration file.
    This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
    Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\defgroup usbh_DevClassFunctions Device Class
\ingroup usbh
\brief Functions to support various USB Device Classes
\details

The various USB Device Classes for the USB Host are hardware independent and contain functions to support
specific USB Devices classes. The application features are implemented using these functions.

\urlout{uv4_ca_sourcefiles} help you to implement the application features.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   usbh_cdcacmFunctions        CDC (ACM): Communication Device Class (Abstract Control Model)
\ingroup  usbh_DevClassFunctions
\brief    USB Host functions to support Communication Device Class (CDC) Abstract Control Model (ACM) USB Devices. 
\details
The CDC ACM class in the USB Host Component is used for attaching communication devices to your system.

Refer to:
  - \ref CDC for an overview of the CDC class.

<b>Software Structure</b>
\n The application starts the USB Host by calling \ref USBH_Initialize. The USB Host Core will wait until an USB CDC ACM
Device is attached to the system. As soon as this happens it will enumerate the device and it will be ready to be used by the
application. The handling of the CDC class events is implemented in USBH_CDCn_IntIn_Thread.

The transmit functions \ref USBH_CDC_ACM_Send and \ref USBH_CDC_ACM_Receive will be called by the user thread directly to
communicate with the CDC USB Device.

\msc
 a [label="",                                              textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBHn_Core_Thread\n osProrityAboveNormal",      textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBH_CDCn_IntIn_Thread\n osProrityAboveNormal", textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="",                                              textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                            textbgcolour="#FFCCCF"],
 b note b [label="Handle Default Pipe Transfers",          textbgcolour="#E0E0FF"],
 c note c [label="Handle CDC Interrupt IN Pipe Events",    textbgcolour="#E0FFE0"],
 d note d [label="USB Bus",                                textbgcolour="#999999"];
 
 a box a  [label="USBH_Initialize", URL="\ref USBH_Initialize"];
 ---      [label="USBH Threads started"];
 ...;

 ---      [label="USB CDC ACM Device Connected"],
 d box d  [label="Connection pull-up activate"];
 d box d  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];
 ---      [label="USB CDC ACM Device Enumerated"];

 ...;
 d box d  [label="Interrupt IN"],
 c box c  [label="Receive modem line and error status change"],
 a box a  [label="USBH_CDC_ACM_Notify", URL="\ref USBH_CDC_ACM_Notify"];

 ...;
 a box a  [label="USBH_CDC_ACM_Send", URL="\ref USBH_CDC_ACM_Send"],
 d box d  [label="Bulk OUT"];

 ...;
 a box a  [label="USBH_CDC_ACM_Receive", URL="\ref USBH_CDC_ACM_Receive"],
 d box d  [label="Bulk INN"];

 ...;
 ---      [label="USB CDC ACM Device Disconnected"];
 a box a  [label="USBH_Uninitialize", URL="\ref USBH_Uninitialize"];
 ---      [label="USBH Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbh_create_app "create an USB Host" with support for the CDC class:
- Select <b>USB:Host:CDC</b> in the \ref RTE_Software_Component_Selection_USBH.
- Configure the number of USB CDC devices connected in the file \ref usbh_cdcacmFunctions_conf "USBH_Config_CDC.h".
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_cdcacmFunctions_api User API
\ingroup usbh_cdcacmFunctions
\brief User API reference of the Communication Device Class (Abstract Control Model).
\details
*/


/**
\addtogroup   usbh_cdcacmFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_CDC_ACM_Initialize (uint8_t instance)
\details
The function \b USBH_CDC_ACM_Initialize is called when a CDC device was connected and successfully enumerated and is 
ready for communication.

The argument \a instance specifies the CDC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_CDC_ACM_Uninitialize (uint8_t instance)
\details
The function \b USBH_CDC_ACM_Unitialize is called when a CDC device was disconnected form the USB Bus.

The argument \a instance specifies the CDC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_CDC_ACM_GetDevice (uint8_t instance)
\details
The function \b USBH_CDC_ACM_GetDevice is used to retrieve device instance that is used to handle CDC device instance.

The argument \a instance specifies the CDC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_GetStatus (uint8_t instance);
\details
The function \b USBH_CDC_ACM_GetStatus returns the status of a CDC device attached to the USB Host.

The argument \a instance specifies the instance of the CDC device to be queried.

<b>Code Example</b>
\code
void USBH_Thread (void const *arg) {
  static bool con = false;
 
  USBH_Initialize (0);                        /* Initialize USB Host 0        */
 
  while (1) {
    if ((USBH_CDC_ACM_GetStatus(0) == usbOK) ^ con) {
      if (!con) {
        con = true;
        osDelay(1000);
        //do something 
        osThreadCreate (osThread(USBH_Serial_RecevieThread), NULL);
      } else {
        con = false;
        //do something else
      }
    } else {
      osDelay(1000);
    }
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_Send (uint8_t instance, const uint8_t *data, uint32_t num);
\details
The function \b USBH_CDC_ACM_Send transmits data to an attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

The argument \a data is a pointer to the buffer containing the data that is to be sent.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a num specifies the number of bytes to be sent.

<b>Code Example</b>
\code
void USART_CDC_Send_Thread (void const *arg) {
  USART_CDC_t *ptr_usart_cdc;
  uint8_t      instance;
  usbStatus    status;
 
  instance      = *(uint8_t *)arg;
  ptr_usart_cdc = &usart_cdc[instance];
 
  // Send Data on Bulk Out Pipe in thread
  status = USBH_CDC_ACM_Send (instance, ptr_usart_cdc->send_data, ptr_usart_cdc->send_num);
  ptr_usart_cdc->send_busy = false;

  if (status == usbOK) ARM_USARTx_Sent(instance);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBH_CDC_ACM_GetTxCount (uint8_t instance);
\details
The function \b USBH_CDC_ACM_GetTxCount returns the number of data bytes sent to an attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

<b>Code Example</b>
\code
static uint32_t ARM_USARTx_GetTxCount (uint8_t instance) {
 
  if (CheckInstance (instance) == false) return 0;
 
  return (USBH_CDC_ACM_GetTxCount(instance));
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_AbortSend (uint8_t instance);
\details
The function \b USBH_CDC_ACM_AbortSend aborts the data sending to an attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_Receive (uint8_t instance, uint8_t *data, uint32_t num);
\details
The function \b USBH_CDC_ACM_Receive receives data from an attached CDC device.

The argument \a instance specifies the instance of the CDC device that is sending the data.

The argument \a data is a pointer to the buffer storing the incoming data.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a num specifies the maximum number of data bytes to be received 
(must be multiple of CDC device Bulk In endpoint maximum packet size).

<b>Code Example</b>
\code
void USART_CDC_Receive_Thread (void const *arg) {
  USART_CDC_t *ptr_usart_cdc;
  uint8_t      instance;
  usbStatus    status;
 
  instance      = *(uint8_t *)arg;
  ptr_usart_cdc = &usart_cdc[instance];
 
  // Receive Data on Bulk In Pipe in thread
  do {
    status = USBH_CDC_ACM_Receive (instance, ptr_usart_cdc->receive_data, ptr_usart_cdc->receive_num);
  } while (status == usbTimeout);
  ptr_usart_cdc->receive_busy = false;

  if (status == usbOK) ARM_USARTx_Received(instance);
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBH_CDC_ACM_GetRxCount (uint8_t instance);
\details
The function \b USBH_CDC_ACM_GetRxCount returns the number of received data bytes from an attached CDC device.

The argument \a instance specifies the instance of the sending CDC device.

<b>Code Example</b>
\code
static uint32_t ARM_USARTx_GetRxCount (uint8_t instance) {
 
  if (CheckInstance (instance) == false) return 0;
 
  return (USBH_CDC_ACM_GetRxCount(instance));
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_AbortReceive (uint8_t instance);
\details
The function \b USBH_CDC_ACM_AbortReceive aborts the data reception from an attached CDC device.

The argument \a instance specifies the instance of the CDC device that is sending the data.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_SetLineCoding (uint8_t instance, const CDC_LINE_CODING *line_coding);
\details
The function \b USBH_CDC_ACM_SetLineCoding changes the communication parameters of the attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

The argument \a line_coding is a pointer to the \ref CDC_LINE_CODING structure containing the communication parameters that
are to be used.

<b>Code Example</b>
\code
static int32_t ARM_USARTx_Control (uint8_t instance, uint32_t control, uint32_t arg) {
  USART_CDC_t       *ptr_usart_cdc;
  CDC_LINE_CODING    line_coding;
 
  if (CheckInstance (instance) == false) return ARM_DRIVER_ERROR;
 
  ptr_usart_cdc = &usart_cdc[instance];
  line_coding   = ptr_usart_cdc->line_coding;
  :
  line_coding.dwDTERate = arg;          // USART Baudrate
 
  if (USBH_CDC_ACM_SetLineCoding (instance, (const CDC_LINE_CODING *)(&line_coding))) return ARM_DRIVER_ERROR;
 
  ptr_usart_cdc->line_coding = line_coding;
 
  return ARM_DRIVER_OK;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_GetLineCoding (uint8_t instance, CDC_LINE_CODING *line_coding);
\details
The function \b USBH_CDC_ACM_GetLineCoding retrieves the communication parameters of the attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

The argument \a line_coding is a pointer to the \ref CDC_LINE_CODING to store the communication parameters.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_SetControlLineState (uint8_t instance, uint16_t state);
\details
The function \b USBH_CDC_ACM_SetControlLineState sets the states of the control lines of the attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

The argument \a state sets the control line parameters.

<b>Code Example</b>
\code
static int32_t ARM_USARTx_SetModemControl (uint8_t instance, ARM_USART_MODEM_CONTROL control) {
  USART_CDC_t *ptr_usart_cdc;
  uint16_t     ctrl_lines;
 
  if (CheckInstance (instance) == false) return ARM_DRIVER_ERROR;
 
  ptr_usart_cdc = &usart_cdc[instance];
  ctrl_lines    = ptr_usart_cdc->ctrl_lines;
 
  if (ptr_usart_cdc->flow_control_rts) {// If flow control on RTS line enabled
    if (control == ARM_USART_RTS_CLEAR) // Deactivate RTS
      ctrl_lines &= ~(1 << 1);
    if (control == ARM_USART_RTS_SET)   // Activate RTS
      ctrl_lines |=  (1 << 1);
  }
  if (control == ARM_USART_DTR_CLEAR)   // Deactivate DTR
    ctrl_lines &= ~(1 << 0);
  if (control == ARM_USART_DTR_SET)     // Activate DTR
    ctrl_lines |=  (1 << 0);
 
  if (USBH_CDC_ACM_SetControlLineState (instance, ctrl_lines) != usbOK) return ARM_DRIVER_ERROR;
 
  ptr_usart_cdc->ctrl_lines = ctrl_lines;
 
  return ARM_DRIVER_OK;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_CDC_ACM_Notify (uint8_t instance, uint16_t status);
\details
The callback function \b USBH_CDC_ACM_Notify is called when an attached CDC device signals modem line or error status changes.

The argument \a instance specifies the instance of the calling CDC device.

The argument \a status shows the modem line or error status.

<b>Code Example</b>
\code
void USBH_CDC_ACM_Notify (uint8_t instance, uint16_t status) {
  usart_cdc[instance].status = status;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CDC_ACM_SendBreak (uint8_t instance, uint16_t duration);
\details
The \b USBH_CDC_ACM_SendBreak function sends a break to the attached CDC device.

The argument \a instance specifies the instance of the targeted CDC device.

The argument \a duration specifies the duration of the break in milliseconds.

<b>Code Example</b>
\code
static int32_t ARM_USARTx_Control (uint8_t instance, uint32_t control, uint32_t arg) {
  USART_CDC_t       *ptr_usart_cdc;
  CDC_LINE_CODING    line_coding;
 
  if (CheckInstance (instance) == false) return ARM_DRIVER_ERROR;
 
  ptr_usart_cdc = &usart_cdc[instance];
  line_coding   = ptr_usart_cdc->line_coding;
 
  switch (control & ARM_USART_CONTROL_Msk) {
    :
    case ARM_USART_CONTROL_BREAK:             // Control break
      if (arg) {                              // Break enabled
        if (USBH_CDC_ACM_SendBreak (instance, 0xFFFF) != usbOK) return ARM_DRIVER_ERROR;
      } else {                                // Break disable
        if (USBH_CDC_ACM_SendBreak (instance, 0)      != usbOK) return ARM_DRIVER_ERROR;
      }
      return ARM_DRIVER_OK;
\endcode
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_cdcacmFunctions_conf Configuration
\ingroup usbh_cdcacmFunctions
\brief Configuration of the USB Host CDC Class.
\details
\image  html usbh_config_cdc_h.png "CDC Class Configuration File"

The USB Host CDC Class configuration file <b>USBH_Config_CDC.h</b> contains the following settings:
- <b>Number of concurrent CDC Devices in system</b> specifies the number of CDC devices that will be supported.
- <b>OS Resource Settings</b>
  - <b>CDC Interrupt In Pipe (modem and error status reception) handling Thread Stack Size</b> specifies the thread stack size
    for the thread that polls the interrupt endpoint of the CDC.
  - The default CDC Interrupt In Pipe handling Thread priority is <b>osPriorityAboveNormal</b>.
    This priority can be changed by changing USBH_CDC_INT_IN_THREAD_PRIORITY define in this configuration file.
    This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
    Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   usbh_hidFunctions        HID: Human Interface Device Class
\ingroup  usbh_DevClassFunctions
\brief    USB Host functions to support Human Interface Device (HID) USB Devices.
\details
The HID class in the USB Component is used for attaching input devices to your system.

Refer to:
  - \ref HID for an overview of the HID class.
  - \ref usbh_example_hid for an example project that uses a HID-compliant keyboard as an input.

<b>Software Structure</b>
\n The application starts the USB Host by calling \ref USBH_Initialize. The USB Host Core will wait until an USB HID device
is attached to the system. As soon as this happens it will enumerate the device and it will be ready to be used by the
application. The handling of the HID class events is implemented in USBH_HIDn_Thread.

The transmit functions \ref USBH_HID_Read and \ref USBH_HID_Write will be called by the user thread directly to communicate
with the HID device.

\msc
 a [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBHn_Core_Thread\n osProrityAboveNormal",       textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="USBH_HIDn_Thread\n osProrityAboveNormal",        textcolor="green",  linecolor="green",  arclinecolor="green"],
 d [label="",                                               textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                             textbgcolour="#FFCCCF"],
 b note b [label="Handle Default Pipe Transfers",           textbgcolour="#E0E0FF"],
 c note c [label="Handle HID Interrupt IN/OUT Pipe Events", textbgcolour="#E0FFE0"],
 d note d [label="USB Bus",                                 textbgcolour="#999999"];
 
 a box a  [label="USBH_Initialize", URL="\ref USBH_Initialize"];
 ---      [label="USBH Threads started"];
 ...;

 ---      [label="USB HID Device Connected"],
 d box d  [label="Connection pull-up activate"];
 d box d  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];
 ---      [label="USB HID Device Enumerated"];

 ...;
 d box d  [label="Interrupt IN"],
 c box c  [label="Receive data"],
 a box a  [label="USBH_HID_Read", URL="\ref USBH_HID_Read"];

 ...;
 a box a  [label="USBH_HID_Write", URL="\ref USBH_HID_Write"],
 c box c  [label="Send data"],
 d box d  [label="Interrupt OUT"];

 ...;
 ---      [label="USB HID Device Disconnected"];
 a box a  [label="USBH_Uninitialize", URL="\ref USBH_Uninitialize"];
 ---      [label="USBH Threads stopped"];
\endmsc

Implementation
--------------

To \ref usbh_create_app "create an USB Host" with support for the HID class:
- Select <b>USB:Host:HID</b> in the \ref RTE_Software_Component_Selection_USBH.
- Configure the number of USB HID devices connected in the file \ref usbh_hidFunctions_conf "USBH_Config_HID.h".

<b>Code Example</b>
\code
int main (void) {
  usbStatus usb_status;                 // USB status
  int       status;                     // Generic status
  int       ch;                         // Character
  uint8_t   con = 0U;                   // Connection status of keyboard
 
  SystemCoreClockUpdate();              // Update system clock
 
  status = stdout_init ();              // Initialize retargeted stdout
  if (status != 0) {
    for (;;) {}                         // Handle stdout init failure
  }
 
  usb_status = USBH_Initialize (0U);    // Initialize USB Host 0
  if (usb_status != usbOK) {
    for (;;) {}                         // Handle USB Host 0 init failure
  }
 
  for (;;) {
    usb_status= USBH_HID_GetStatus(0U); // Get HID device status
    if (usb_status == usbOK) {
      if (con == 0U) {                  // If keyboard was not connected previously
        con = 1U;                       // Keyboard got connected
        printf ("Connect!\n");
      }
    } else {
      if (con == 1U) {                  // If keyboard was connected previously
        con = 0U;                       // Keyboard got disconnected
        printf ("\nDisconnect!\n");
      }
    }
    if (con != 0U) {                    // If keyboard is active
      ch = USBH_HID_GetKeyboardKey (0U);// Get pressed key
      if (ch != -1) {                   // If valid key value
        if ((ch & 0x10000) != 0) {      // Handle non-ASCII translated keys (Keypad 0 .. 9)
                                        // Bit  16:    non-ASCII bit (0 = ASCII, 1 = not ASCII)
                                        // Bits 15..8: modifiers (SHIFT, ALT, CTRL, GUI)
                                        // Bits  7..0: ASCII or HID key Usage ID if not ASCII
          ch &= 0xFF;                   // Remove non-ASCII bit and modifiers
          if ((ch>=0x59)&&(ch<=0x61)) { // Keypad 1 .. 9 key convert to
            ch = (ch - 0x59) + '1';     // ASCII  1 .. 9
          } else if (ch == 0x62) {      // Keypad 0 key convert to
            ch = '0';                   // ASCII  0
          } else {                      // If not Keypad 0 .. 9
            ch = -1;                    // invalidate the key
          }
        }
        if ((ch > 0) && (ch < 128)) {   // Output ASCII 0 .. 127 range
          putchar(ch);
          fflush(stdout);
        }
      }
    }
    osDelay(10U);
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_hidFunctions_api User API
\ingroup usbh_hidFunctions
\brief User API reference of the Human Interface Device Class.
\details
*/


/**
\addtogroup usbh_hidFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_HID_Initialize (uint8_t instance)
\details
The function \b USBH_HID_Initialize is called when a human interface device was connected and successfully enumerated and is 
ready for communication.

The argument \a instance specifies the HID device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_HID_Uninitialize (uint8_t instance)
\details
The function \b USBH_HID_Unitialize is called when a human interface device was disconnected form the USB Bus.

The argument \a instance specifies the HID device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_HID_GetDevice (uint8_t instance)
\details
The function \b USBH_HID_GetDevice is used to retrieve device instance that is used to handle human interface device instance.

The argument \a instance specifies the HID device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_HID_GetStatus (uint8_t instance)
\details
The function \b USBH_HID_GetStatus checks whether the human interface device is connected and initialized.

The argument \a instance specifies the HID device instance.

<b>Code Example</b>
\code
#include "rl_usb.h"

int main (void) {
  usbStatus usb_status;                 // USB status
 
  usb_status = USBH_Initialize (0U);    // Initialize USB Host 0
  if (usb_status != usbOK) {
    for (;;) {}                         // Handle USB Host 0 init failure
  }
 
  while (1) {
    usb_status= USBH_HID_GetStatus(0U); // Get HID device status
    if (usb_status == usbOK) {
      //do something
    }
  }
}
\endcode
*/



/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBH_HID_Read (uint8_t instance, uint8_t *buf, int32_t len)
\details
The function \b USBH_HID_Read retrieves the data sent by an USB HID device and stores it in a buffer.

The argument \a instance specifies the HID device instance.

The argument \a buf is pointing to the location where the data will be returned (stored).
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a len specifies the number of bytes to be read
(must be multiple of HID device Interrupt In endpoint maximum packet size).

<b>Code Example</b>
\code
#include "rl_usb.h"
 
void HID_start_data_reception (void)  {
  U8 data[16];
  ..
  if (USBH_HID_Read (0, &data, 2)) {  // If data received from HID device
    ..
  }
)
\endcode
*/



/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBH_HID_Write (uint8_t instance, const uint8_t *buf, int32_t len)
\details
The function \b USBH_HID_Write writes data from a buffer to an USB HID device.

The argument \a instance specifies the HID device instance.

The argument \a buf is pointing to the location where the data will be written.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a len specifies the number of data bytes to be written.

<b>Code Example</b>
\code
#include "rl_usb.h"

int main (void) {
  usbStatus usb_status;                 // USB status
  uint8_t   out;
 
  usb_status = USBH_Initialize (0U);    // Initialize USB Host 0
  if (usb_status != usbOK) {
    for (;;) {}                         // Handle USB Host 0 init failure
  }
 
  while (1) {
    usb_status= USBH_HID_GetStatus(0U); // Get HID device status
    if (usb_status == usbOK) {
      USBH_HID_Write (0,(uint8_t *)&out,1);     // Turn on NUM LED
      :
    }
    osDelay(100);
  }
}
\endcode
*/



/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn int32_t USBH_HID_GetKeyboardKey (uint8_t instance)
\details
The function \b USBH_HID_GetKeyboardKey enables programmers to handle signals from a USB keyboard.

The argument \a instance specifies the HID device instance.

The function returns an integer value of the first pending keystroke. Characters that are directly mapped
into ASCII are the HID codes starting from 4 (representing 'a') up to to 57 (representing '/'). All other HID codes are
passed by this function using bit 16. set to '1' to notify the application about extended non-ASCII mapped HID codes.
Modifier keys are encoded in bits 8..15 with following encoding:
| Bit | Modifier Key  |
|-----|---------------|
| 8   | Left Control  |
| 9   | Left Shift    |
| 10  | Left Alt      |
| 11  | Left GUI      |
| 12  | Right Control |
| 13  | Right Shift   |
| 14  | Right Alt     |
| 15  | Right GUI     |

Consult the USB-IF's online documentation for information on 
<a href="https://usb.org/sites/default/files/hut1_4.pdf" target="_blank">HID Usage Tables</a> relevant usage page for this 
function is Keyboard/Keypad Page 0x07.

<b>Code Example</b>
\code
#include "rl_usb.h"

int main (void) {
  usbStatus usb_status;                 // USB status
  int       status;                     // Generic status
  int       ch;                         // Character
  uint8_t   con = 0U;                   // Connection status of keyboard
 
  SystemCoreClockUpdate();              // Update system clock
 
  status = stdout_init ();              // Initialize retargeted stdout
  if (status != 0) {
    for (;;) {}                         // Handle stdout init failure
  }
 
  usb_status = USBH_Initialize (0U);    // Initialize USB Host 0
  if (usb_status != usbOK) {
    for (;;) {}                         // Handle USB Host 0 init failure
  }
 
  for (;;) {
    usb_status= USBH_HID_GetStatus(0U); // Get HID device status
    if (usb_status == usbOK) {
      if (con == 0U) {                  // If keyboard was not connected previously
        con = 1U;                       // Keyboard got connected
        printf ("Connect!\n");
      }
    } else {
      if (con == 1U) {                  // If keyboard was connected previously
        con = 0U;                       // Keyboard got disconnected
        printf ("\nDisconnect!\n");
      }
    }
    if (con != 0U) {                    // If keyboard is active
      ch = USBH_HID_GetKeyboardKey (0U);// Get pressed key
      if (ch != -1) {                   // If valid key value
        if ((ch & 0x10000) != 0) {      // Handle non-ASCII translated keys (Keypad 0 .. 9)
                                        // Bit  16:    non-ASCII bit (0 = ASCII, 1 = not ASCII)
                                        // Bits 15..8: modifiers (SHIFT, ALT, CTRL, GUI)
                                        // Bits  7..0: ASCII or HID key Usage ID if not ASCII
          ch &= 0xFF;                   // Remove non-ASCII bit and modifiers
          if ((ch>=0x59)&&(ch<=0x61)) { // Keypad 1 .. 9 key convert to
            ch = (ch - 0x59) + '1';     // ASCII  1 .. 9
          } else if (ch == 0x62) {      // Keypad 0 key convert to
            ch = '0';                   // ASCII  0
          } else {                      // If not Keypad 0 .. 9
            ch = -1;                    // invalidate the key
          }
        }
        if ((ch > 0) && (ch < 128)) {   // Output ASCII 0 .. 127 range
          putchar(ch);
          fflush(stdout);
        }
      }
    }
    osDelay(10U);
  }
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn bool USBH_HID_GetMouseState (uint8_t instance, usbHID_MouseState *state)
\details
The function \b USBH_HID_GetMouseState enables programmers to handle signals from an USB mouse.

The argument \a instance specifies the HID device instance.

The argument \a state is a pointer to the mouse state structure (\ref usbHID_MouseState).

<b>Code Example</b>
\code
#include "rl_usb.h"
 
void getmouse (void)  {
  ..
  if (USBH_HID_GetMouseState (0, &MouseState)) { // If mouse move
    ..
  }
)
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_HID_ParseReportDescriptor (uint8_t instance, const uint8_t *ptr_hid_report_desc, uint32_t len)
\details
The \b USBH_HID_ParseReportDescriptor function enables programmers to parse report descriptors of an USB HID device.
This is useful if the default HID functionality needs to be changed to support special HID devices.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_HID_DataReceived (uint8_t instance, uint32_t len)
\details
The \b USBH_HID_DataReceived function enables programmers to analyze received data coming from an USB HID device.
Implementing this function in user code overrides the USB Component function that handles boot protocol device data reception. This
is useful if the default HID functionality needs to be changed to support special HID devices.
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_hidFunctions_conf Configuration
\ingroup usbh_hidFunctions
\brief Configuration of the USB Host HID Class.
\details
\image  html usbh_config_hid_h.png "HID Class Configuration File"

The USB Host HID Class configuration file <b>USBH_Config_HID.h</b> contains the following settings:
- <b>Number of concurrent HID Devices in system</b> specifies the number of HID devices that will be supported.
- <b>OS Resource Settings</b>
  - <b>HID Interrupt In Pipe handling Thread Stack Size</b> specifies the thread stack size for the thread that polls the
    interrupt endpoint of the HID.
  - The default HID Interrupt In Pipe handling Thread priority is <b>osPriorityAboveNormal</b>.
    This priority can be changed by changing USBH_HID_INT_IN_THREAD_PRIORITY define in this configuration file.
    This priority needs to be high enough so that USB Stack can react to USB events in a timely manner.
    Due to this requirement it is recommended to keep this setting at default.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_mscFunctions   MSC: Mass Storage Class
\ingroup  usbh_DevClassFunctions
\brief    USB Host functions to support Mass Storage Class (MSC) USB Devices. 
\details
The <b>Mass Storage Class (MSC)</b> in the USB Host Component provides physical access to a data storage device. The USB MSC
drive in the <b>File System</b> Component gives file I/O access to that data storage.

<b>Software Stack</b>
\n The following picture shows how the software stack is built-up for MSC device support:

\image html usbh_msc_sw_stack.png

Refer to:
  - \ref MSC for an overview of the MSC class.
  - \ref usbd_example_msc for an example project that uses the MSC class on USB Device.
  - \ref usbh_example_msc for an example project that uses the MSC class on USB Host.

<b>Software Structure</b>
\n The application starts the USB Host by calling \ref USBH_Initialize. The USB Host Core will wait until an USB MSC device
is attached to the system. As soon as this happens it will enumerate the device and it will be ready to be used by the
application.

The data functions \ref USBH_MSC_Read and \ref USBH_MSC_Write can be either called by the user thread
directly or called indirectly when the user thread is using file system routines like fread/fwrite which use the USB MSC
Device as media for data storage.

\msc
 a [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBHn_Core_Thread\n osProrityAboveNormal",   textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                                               textbgcolour="#FFCCCF"],
 b note b [label="Handle Default Pipe Transfers and Bulk IN/OUT Pipe Events", textbgcolour="#E0E0FF"],
 c note c [label="USB Bus",                                                   textbgcolour="#999999"];
 
 a box a  [label="USBH_Initialize", URL="\ref USBH_Initialize"];
 ---      [label="USBH Threads started"];
 ...;

 ---      [label="USB MSC Device Connected"],
 c box c  [label="Connection pull-up activate"];
 c box c  [label="Control Endpoint 0 transfers"],
 b box b  [label="Enumeration"];
 ---      [label="USB MSC Device Enumerated"];

 ...;
 c box c  [label="Bulk IN"],
 b box b  [label="Receive data"],
 a box a  [label="USBH_MSC_Read", URL="\ref USBH_MSC_Read"];

 ...;
 a box a  [label="USBH_MSC_Write", URL="\ref USBH_MSC_Write"],
 b box b  [label="Send data"],
 c box c  [label="Bulk OUT"];

 ...;
 ---      [label="USB MSC Device Disconnected"];
 a box a  [label="USBH_Uninitialize", URL="\ref USBH_Uninitialize"];
 ---      [label="USBH Threads stopped"];
\endmsc

Implementation
--------------

Steps to \ref usbh_create_app "create an USB Host" application with MSC support:
- In the \ref RTE_Software_Component_Selection_USBH "Manage Run-Time Environment" window select <b>USB:Host:MSC</b> for support
  of the MSC class and <b>File System:CORE</b>, <b>File System:Drive:USB</b> for using the \b File \b System Component
  with support for USB mass storage devices. For the <b>File System:Drive:USB</b> you have to set the number to the number
  of devices you need to support	simultaneously.
- Configure the number of USB MSC devices connected in the file \ref usbh_mscFunctions_conf "USBH_Config_MSC.h".
- Use the functions of the related \urlout{uv4_ca_sourcefiles} file (\b USBH_MSC.c) to access the data storage.

\anchor USBH_MSC_UCT
<b>User Code Template USBH_MSC.c</b>
\include "USBH_MSC.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_mscFunctions_api User API
\ingroup usbh_mscFunctions
\brief User API reference of the Mass Storage Class.
\details
*/


/**
\addtogroup   usbh_mscFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_MSC_Initialize (uint8_t instance)
\details
The function \b USBH_MSC_Initialize is called when a mass storage device was connected and successfully enumerated and is 
ready for communication.

The argument \a instance specifies the MSC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn void USBH_MSC_Uninitialize (uint8_t instance)
\details
The function \b USBH_MSC_Unitialize is called when a mass storage device was disconnected form the USB Bus.

The argument \a instance specifies the MSC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_MSC_GetDevice (uint8_t instance)
\details
The function \b USBH_MSC_GetDevice is used to retrieve device instance that is used to handle mass storage device instance.

The argument \a instance specifies the MSC device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_MSC_GetStatus (uint8_t instance)
\details
The function \b USBH_MSC_GetStatus checks if a mass storage device is connected and initialized.

The argument \a instance specifies the MSC device instance.

<b>Code Example</b>
\code
int32_t USBH_MSC_DriveGetMediaStatus (const char *drive_name) {
  usbStatus ustatus;
  uint8_t   drive_num;
 
  drive_num = drive_name[1] - '0';      // get drive number from drive name
 
  ustatus = USBH_MSC_GetStatus (drive_num);
  if (ustatus != usbOK) return USBH_MSC_ERROR_DRIVE;
 
  return USBH_MSC_OK;
}
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_MSC_Read (uint8_t instance, uint32_t lba, uint32_t cnt, uint8_t *buf)

\details
The function \b USBH_MSC_Read reads data from physical memory blocks of a mass storage device.

The argument \a instance specifies the MSC device instance.

The argument \a lba is the physical address of the first block to be read.

The argument \a cnt is the number of blocks to be read.

The argument \a buf is a pointer to the location where the data will be stored.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

\note
This function is typically used by the File System Component to provide file I/O access.

<b>Code Example</b>
\code
  unsigned char buf[0x10000];
  usbStatus     ustatus;
  
  ustatus = USBH_MSC_Read (0, 10, 1, buf);
  if (ustatus == usbOK)  {
    // data successfully written
  }
\endcode
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_MSC_Write (uint8_t instance, uint32_t lba, uint32_t cnt, const uint8_t *buf)
\details
The function \b USBH_MSC_Write writes data to physical memory blocks of the mass storage device.

The argument \a instance specifies the MSC device instance.

The argument \a lba is the physical address of the first block to be written.

The argument \a cnt is the number of blocks to be written.

The argument \a buf is a pointer to the location that contains the data to be written.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

\note
This function is typically used by the File System Component to provide file I/O access.

<b>Code Example</b>
\code
  unsigned char buf[0x10000];
  usbStatus     ustatus;
  
  memset (buf, 0x55, sizeof (buf));
  ustatus = USBH_MSC_Write (0, 10, 1, buf);
  if (ustatus == usbOK)  {
    // data successfully written
  }
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_MSC_ReadCapacity (uint8_t instance, uint32_t *block_count, uint32_t *block_size)
\details
The function \b USBH_MSC_ReadCapacity gets information about the capacity of a mass storage device.

The argument \a instance specifies the MSC device instance.

The argument \a block_count is a pointer to a variable that stores the total number of available blocks.

The argument \a block_size is a pointer to a variable that stores the block size (in bytes).

<b>Code Example</b>
\code
uint64_t USBH_MSC_DriveGetCapacity (const char *drive_name) {
  usbStatus ustatus;
  uint32_t  block_count;
  uint32_t  block_size;
  uint8_t   drive_num;
 
  drive_num = drive_name[1] - '0';      // get drive number from drive name
 
  ustatus = USBH_MSC_GetStatus (drive_num);
  if (ustatus != usbOK) return 0;
 
  ustatus = USBH_MSC_ReadCapacity (drive_num, &block_count, &block_size);
  if (ustatus != usbOK) return 0;
 
  return (((uint64_t)block_count) * ((uint64_t)block_size));
}
\endcode

*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_mscFunctions_conf Configuration
\ingroup usbh_mscFunctions
\brief Configuration of the USB Host MSC Class.
\details
\image  html usbh_config_msc_h.png "MSC Class Configuration File"

The USB Host MSC Class configuration file <b>USBH_Config_MSC.h</b> contains the following settings:
- <b>Number of concurrent MSC Devices in system</b> specifies the number of MSC devices that will be supported.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup   usbh_customFunctions         Custom Class
\ingroup  usbh_DevClassFunctions
\brief    USB Host functions to support Custom Class USB Devices. 
\details
The Custom Class in the USB Host Component is used for attaching USB Devices with a specific USB Class to your system. This
can either be one of the <a class=el href="https://www.usb.org/defined-class-codes" target="_blank">standard</a> classes
that are not directly supported by the USB Middleware or a
<a class=el href="https://www.usb.org/defined-class-codes" target="_blank">vendor specific</a> class.
Using these functions, you can add support for any USB Device class to the system.

Refer to:
 - \ref CustomClass for an overview of the Custom Class.
 
<b>Software Structure</b>
\n The application starts the USB Host by calling \ref USBH_Initialize. The USB Host Core will wait until an USB Custom Class
device is attached to the system. As soon as this happens the Core will configure and initialize the device and it will be
ready to be used by the application.

The transmit functions \ref USBH_PipeSend and \ref USBH_PipeReceive will be called by the user thread directly to communicate
with the Custom Class device.

As soon as the Custom Class Device is detached from the system, the callback functions \ref USBH_CustomClass_Unconfigure and
\ref USBH_CustomClass_Uninitialize signal the removal to the user application.

\msc
 a [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="red"],
 b [label="USBHn_Core_Thread\n osProrityAboveNormal",   textcolor="blue",   linecolor="blue",   arclinecolor="blue"],
 c [label="",                                           textcolor="indigo", linecolor="indigo", arclinecolor="grey"];
 
 a note a [label="Application",                         textbgcolour="#FFCCCF"],
 b note b [label="Handle Default Pipe Transfers",       textbgcolour="#E0E0FF"],
 c note c [label="USB Bus",                             textbgcolour="#999999"];
 
 a box a  [label="USBH_Initialize", URL="\ref USBH_Initialize"];
 ---      [label="USBH Threads started"];
 ...;

 ---      [label="USB Custom Class Device Connected"],
 c box c  [label="Connection pull-up activate"];
 b box b  [label="USBH_CustomClass_Configure", URL="\ref USBH_CustomClass_Configure"];
 b box b  [label="USBH_CustomClass_Initialize", URL="\ref USBH_CustomClass_Initialize"];
 ---      [label="USB Custom Class Device Enumerated"];

 ...;
 a box a  [label="USBH_PipeSend", URL="\ref USBH_PipeSend"],
 c box c  [label="Control, Interrupt or Bulk OUT"];

 ...;
 a box a  [label="USBH_PipeReceive", URL="\ref USBH_PipeReceive"],
 c box c  [label="Control, Interrupt or Bulk IN"];

 ...;
 ---      [label="USB Custom Class Device Disconnected"];
 b box b  [label="USBH_CustomClass_Uninitialize", URL="\ref USBH_CustomClass_Uninitialize"];
 b box b  [label="USBH_CustomClass_Unconfigure", URL="\ref USBH_CustomClass_Unconfigure"];
 a box a  [label="USBH_Uninitialize", URL="\ref USBH_Uninitialize"];
 ---      [label="USBH Threads stopped"];
\endmsc

Implementation
--------------

 To \ref usbh_create_app "create an USB Host" with support for the Custom class:
- Select <b>USB:Host:Custom Class</b> in the \ref RTE_Software_Component_Selection_USBH.
- Configure the number of custom class devices allowed in the system in the file
  \ref usbh_customFunctions_conf "USBH_Config_CustomClass.h".
- Add the related <b>user code template</b> file (\ref USBH_Cust_UCT "USBH_User_CustomClass.c") to your project.
- Implement the application specific behavior in \ref USBH_Cust_UCT "USBH_User_CustomClass.c".

\b User \b Code \b Templates

There are two user code templates available that show how to create support for a Custom Class device:
-# \ref USBH_Cust_UCT "USBH_User_CustomClass.c" shows in general how to use the Custom Class functions.
-# \ref USBH_PL2303_UCT "USBH_PL2303.c" is an actual implementation of the Custom Class functions to add support for Prolific's
   <a class=el href="https://www.prolific.com.tw/US/index.aspx" target="_blank">PL2303</a>
   UART to serial RS232 adapter.

\anchor USBH_Cust_UCT
<b>User Code Template USBH_User_CustomClass.c</b>
\n The following source code can be used to implement support for a Custom USB Device Class in the user application.

\include "USBH_User_CustomClass.c"

\anchor USBH_PL2303_UCT
<b>User Code Template USBH_PL2303.c</b>
\n The following source code implements support for Prolific's
<a class=el href="https://www.prolific.com.tw/US/index.aspx" target="_blank">PL2303</a>
UART to serial RS232 adapter using the Custom Class functions.

\include "USBH_PL2303.c"
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_customFunctions_api User API
\ingroup usbh_customFunctions
\brief User API reference of the Custom Class.
\details
*/


/**
\addtogroup   usbh_customFunctions_api
@{
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_CustomClass_GetDevice (uint8_t instance)
\details
The function \b USBH_CustomClass_GetDevice is used to retrieve device instance that is used to handle custom class 
device instance.

The argument \a instance specifies the custom class device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CustomClass_GetStatus (uint8_t instance)
\details
The function \b USBH_CustomClass_GetStatus checks if a custom class device is connected and initialized.

The argument \a instance specifies the custom class device instance.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint8_t USBH_CustomClass_Configure (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc)
\details
The function \b USBH_CustomClass_Configure should create all necessary pipes for the custom class. It needs to be adapted to the
specific needs of the Custom Class that is to be supported. For more information on the \c USB_DEVICE_DESCRIPTOR,
please refer to \ref USB_Device_Descriptor. For more information on the \c USB_CONFIGURATION_DESCRIPTOR,
please refer to \ref USB_Configuration_Descriptor.

The argument \a device specifies the instance of the connected device.

The argument \a ptr_dev_desc specifies the pointer to the device descriptor (\ref USB_Device_Descriptor) of the Custom Class.

The argument \a ptr_cfg_desc specifies the pointer to the configuration descriptor (\ref USB_Configuration_Descriptor) of the Custom Class.

<b>Code Example</b>
\code
uint8_t USBH_CustomClass_Configure (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc) {
  USB_INTERFACE_DESCRIPTOR *ptr_if_desc;
  USB_ENDPOINT_DESCRIPTOR  *ptr_ep_desc;
  USBH_PIPE_HANDLE          pipe_hndl;
  uint8_t                   num, i;
 
  USBH_CC_Device = device;              // Store device
  for (i = 0U; i < 8U; i++) {           // Clear all pipe handles
    USBH_CC_PipeHandle[i] = 0U;
  }
  ptr_if_desc = (USB_INTERFACE_DESCRIPTOR *)((uint32_t)ptr_cfg_desc + ptr_cfg_desc->bLength);
  num = ptr_if_desc->bNumEndpoints;     // Number of endpoints
 
  // Supported device: - Prolific PL2303 (VID = 0x067B, PID = 0x2303)
  if ((ptr_dev_desc->idVendor != 0x067BU) || (ptr_dev_desc->idProduct != 0x2303U)) {
    return 255U;
  }
 
  switch (ptr_if_desc->bInterfaceClass) {
    case CUSTOM_CLASS_IF_CLASS:                 // Interface class
      switch (ptr_if_desc->bInterfaceSubClass) {
        case CUSTOM_CLASS_IF_SUBCLASS:          // Interface subclass
          switch (ptr_if_desc->bInterfaceProtocol) {
            case CUSTOM_CLASS_IF_PROTOCOL:      // Interface protocol
              // Create Pipes
              ptr_ep_desc = (USB_ENDPOINT_DESCRIPTOR *)((uint32_t)ptr_if_desc + ptr_if_desc->bLength);
              i           = 0U;
              while (num-- != 0U) {
                pipe_hndl = USBH_PipeCreate (device, ptr_ep_desc->bEndpointAddress, ptr_ep_desc->bmAttributes & USB_ENDPOINT_TYPE_MASK, ptr_ep_desc->wMaxPacketSize & 0x7FFU, ptr_ep_desc->bInterval);
                if (pipe_hndl == 0U) {
                  // If creation of pipe has failed delete previously created pipes
                  for (i = 0U; i < 8U; i++) {
                    if (USBH_CC_PipeHandle[i] != 0U) {
                      (void)USBH_PipeDelete (USBH_CC_PipeHandle[i]);
                      USBH_CC_PipeHandle[i] = 0U;
                    }
                  }
                  return 255U;
                }
                USBH_CC_PipeHandle[i++] = pipe_hndl;
                ptr_ep_desc++;
              }
              return 0U;                // Device connected and configured
                                        // Only single instance supported
                                        // so it's instance index is 0
            default:
              break;
          }
          break;
        default:
          break;
      }
      break;
    default:
      break;
  }
 
  return 255U;                          // Device not handled
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CustomClass_Unconfigure (uint8_t instance)
\details
The function \b USBH_CustomClass_Unconfigure should release all resources that were used by the Custom Class device after it has been
de-initialized using \ref USBH_CustomClass_Uninitialize. All pipes relating to the Custom Class should be removed. It needs to be
adapted to the specific needs of the Custom Class that is to be supported.

The argument \a instance specifies device instance of the Custom Class USB Device.

<b>Code Example</b>
\code
  uint8_t i;
 
  USBH_CC_Device = 0U;
 
  for (i = 0U; i < 8U; i++) {
    if (USBH_CC_PipeHandle[i] != 0U) {
      (void)USBH_PipeDelete (USBH_CC_PipeHandle[i]);
      USBH_CC_PipeHandle[i] = 0U;
    }
  }
 
  return usbOK;
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CustomClass_Initialize (uint8_t instance)
\details
The function \b USBH_CustomClass_Initialize initializes the Custom Class device when connected to the system. It needs to be
adapted to the specific needs of the Custom Class that is to be supported.

The argument \a instance specifies device instance of the Custom Class USB Device.

<b>Code Example</b>
\code
usbStatus USBH_CustomClass_Initialize (uint8_t instance) {
  USB_SETUP_PACKET setup_packet;
  uint32_t         br;
  uint8_t          buf[8];
 
  // Custom PL2303 initialization
  setup_packet.bmRequestType.Dir      = USB_REQUEST_DEVICE_TO_HOST;
  setup_packet.bmRequestType.Type     = USB_REQUEST_VENDOR;
  setup_packet.bmRequestType.Recipient= USB_REQUEST_TO_DEVICE;
  setup_packet.bRequest               = 1U;
  setup_packet.wValue                 = 0x8484U;
  setup_packet.wIndex                 = 0U;
  setup_packet.wLength                = 1U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.bmRequestType.Dir      = USB_REQUEST_HOST_TO_DEVICE;
  setup_packet.wValue                 = 0x0404U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.bmRequestType.Dir      = USB_REQUEST_DEVICE_TO_HOST;
  setup_packet.wValue                 = 0x8484U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.wValue                 = 0x8383U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.wValue                 = 0x8484U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.bmRequestType.Dir      = USB_REQUEST_HOST_TO_DEVICE;
  setup_packet.wValue                 = 0x0404U;
  setup_packet.wIndex                 = 1U;
  setup_packet.wLength                = 0U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, NULL, 0U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.bmRequestType.Dir      = USB_REQUEST_DEVICE_TO_HOST;
  setup_packet.wValue                 = 0x8484U;
  setup_packet.wIndex                 = 0U;
  setup_packet.wLength                = 1U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.wValue                 = 0x8383U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.bmRequestType.Dir      = USB_REQUEST_HOST_TO_DEVICE;
  setup_packet.wValue                 = 0U;
  setup_packet.wIndex                 = 1U;
  setup_packet.wLength                = 0U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, NULL, 0U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.wValue                 = 1U;
  setup_packet.wIndex                 = 0U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, NULL, 0U) != usbOK) { return usbClassErrorCustom; }
 
  setup_packet.wValue                 = 2U;
  setup_packet.wIndex                 = 0x44U;
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, NULL, 0U) != usbOK) { return usbClassErrorCustom; }
 
  // Initial CDC SetLineCoding request: Set 9600 baud, 8 data bits, 1 stop bit, no parity
  setup_packet.bmRequestType.Dir      = USB_REQUEST_HOST_TO_DEVICE;
  setup_packet.bmRequestType.Type     = USB_REQUEST_CLASS;
  setup_packet.bmRequestType.Recipient= USB_REQUEST_TO_INTERFACE;
  setup_packet.bRequest               = 0x20U;
  setup_packet.wValue                 = 0U;
  setup_packet.wIndex                 = 0U;
  setup_packet.wLength                = 7U;
  br                                  = 9600U;          // Data terminal rate in bits per second = 9600 baud
  buf[0]                              = (uint8_t)( br        & 0xFFU);
  buf[1]                              = (uint8_t)((br >>  8) & 0xFFU);
  buf[2]                              = (uint8_t)((br >> 16) & 0xFFU);
  buf[3]                              = (uint8_t)((br >> 24) & 0xFFU);
  buf[4]                              = 0U;            // Number of stop bits = 1
  buf[5]                              = 0U;            // Parity bit type = None
  buf[6]                              = 8U;            // Number of data bits = 8
  if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf, 7U) != usbOK) { return usbClassErrorCustom; }
 
  return usbOK;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_CustomClass_Uninitialize (uint8_t instance)
\details
The function \b USBH_CustomClass_Uninitialize de-initializes the Custom Class device after it has been disconnected from the system.
It needs to be adapted to the specific needs of the Custom Class that is to be supported.

The argument \a instance specifies device instance of the Custom Class USB Device.

<b>Code Example</b>
\code
usbStatus USBH_CustomClass_Uninitialize (uint8_t instance) {
 
  return usbOK;
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn USBH_PIPE_HANDLE USBH_PipeCreate (uint8_t device, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_max_packet_size, uint8_t ep_interval)
\details
The function \b USBH_PipeCreate a Pipe for communication with specific Endpoint in a Device.

The argument \a device specifies the instance of the device.

The argument \a ep_addr is the address of the endpoint.

The argument \a ep_type is the type of the endpoint.

The argument \a ep_max_packet_size is the maximum packet size of the endpoint.

The argument \a ep_interval is the endpoint polling interval of the endpoint.

<b>Code Example</b>
\code
uint8_t USBH_CustomClass_Configure (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc) {
  USBH_PIPE_HANDLE pipe_hndl;
:
  pipe_hndl = USBH_PipeCreate (device, ptr_ep_desc->bEndpointAddress, ptr_ep_desc->bmAttributes & USB_ENDPOINT_TYPE_MASK, ptr_ep_desc->wMaxPacketSize & 0x7FF, ptr_ep_desc->bInterval);
:
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeRegisterCallback (USBH_PIPE_HANDLE pipe_hndl, USBH_PipeEvent_t cb_pipe_event)
\details
The function \b USBH_PipeRegisterCallback registers a callback function that will be called upon pipe event.

The argument \a pipe_hndl is a handle to pipe for registering callback.

The argument \a cb_pipe_event specifies the callback function.

\note Currently supported only for isochronous pipes.
Callback function is called from interrupt context so it may not call functions like 
USBH_PipeSend or USBH_PipeReceive directly. 
It is recommended to set a flag for a thread that can then call USBH_PipeSend or USBH_PipeReceive to start a new transfer.

<b>Code Example</b>
\code
void IsoReceived (uint32_t event, const uint8_t *buf, uint32_t len) {
  osThreadFlagsSet(thread_id_iso, 1U);
}
 
uint8_t USBH_CustomClass_Configure (uint8_t device, const USB_DEVICE_DESCRIPTOR *ptr_dev_desc, const USB_CONFIGURATION_DESCRIPTOR *ptr_cfg_desc) {
  USBH_PIPE_HANDLE pipe_hndl;
:
  pipe_hndl = USBH_PipeCreate (device, ptr_ep_desc->bEndpointAddress, ptr_ep_desc->bmAttributes & USB_ENDPOINT_TYPE_MASK, ptr_ep_desc->wMaxPacketSize & 0x7FF, ptr_ep_desc->bInterval);
  USBH_PipeRegisterCallback (pipe_hndl, IsoReceived);
:
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeUpdate (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeUpdate modifies a Pipe with changed device parameters (for example if device address has changed).

The argument \a pipe_hndl is a handle to pipe to be updated.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeDelete (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeDelete removes a Pipe.

The argument \a pipe_hndl is a handle to pipe to be updated.

<b>Code Example</b>
\code
// If creation of pipe failed delete previously created pipes
for (i = 0U; i < 8U; i++) {
  if (USBH_CC_PipeHandle[i] != 0U) {
    USBH_PipeDelete (USBH_CC_PipeHandle[i]);
    USBH_CC_PipeHandle[i] = NULL;
  }
}
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeReset (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeReset resets data toggle of a Pipe.

The argument \a pipe_hndl is a handle to pipe to be reset.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeReceive (USBH_PIPE_HANDLE pipe_hndl, uint8_t *buf, uint32_t len)
\details
The function \b USBH_PipeReceive receives data on a Pipe. Number of bytes received can be retrieved by
USBH_PipeReceiveGetResult function.

The argument \a pipe_hndl is a handle to pipe used for data reception.

The argument \a buf buffer that receives data.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a len maximum number of bytes to receive (must be multiple of device endpoint maximum packet size).

\note For isochronous transfer, with registered callback, this function is non-blocking and returns when 
transfer is queued (double-buffering).
The parameter \a data must point to memory accessible by the USB Host controller and parameter \a len must be same as 
maximum packet size or it will be downsized to a maximum packet size of the isochronous endpoint.
Only supported for full-speed transfers on the EHCI controller.

<b>Code Example</b>
\code
do {
  status = USBH_PipeReceive (USBH_CC_PipeHandle[PL2303_RECEIVE_PIPE_INDEX], usart_receive_data, usart_receive_num);
} while (status == usbTimeout);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBH_PipeReceiveGetResult (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeReceiveGetResult retrieves number of received data bytes on a Pipe.

The argument \a pipe_hndl is a handle to pipe used for data reception.

\note For non-blocking isochronous transfer, this function always returns 0.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeSend (USBH_PIPE_HANDLE pipe_hndl, const uint8_t *buf, uint32_t len)
\details
The function \b USBH_PipeSend sends data on a Pipe. Number of bytes sent can be retrieved by
USBH_PipeSendGetResult function.

The argument \a pipe_hndl is a handle to pipe used for sending data.

The argument \a buf buffer containing data bytes to send.
It is recommended that buffer is 4-byte aligned as some drivers might not support 1-byte alignment if DMA is used.

The argument \a len maximum number of bytes to send.

\note For isochronous transfer, with registered callback, this function is non-blocking and returns when 
transfer is queued (double-buffering).
The parameter \a data must point to memory accessible by the USB Host controller and parameter \a len must be same as 
maximum packet size or it will be downsized to a maximum packet size of the isochronous endpoint.
Only supported for full-speed transfers on the EHCI controller.

<b>Code Example</b>
\code
// Send Data on Bulk Out Pipe in thread
USBH_PipeSend (USBH_CC_PipeHandle[PL2303_SEND_PIPE_INDEX], usart_send_data, usart_send_num);
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn uint32_t USBH_PipeSendGetResult (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeSendGetResult retrieves number of successfully sent data bytes on a Pipe.

The argument \a pipe_hndl is a handle to pipe used for sending data.

\note For non-blocking isochronous transfer, this function always returns 0.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_PipeAbort (USBH_PIPE_HANDLE pipe_hndl)
\details
The function \b USBH_PipeAbort aborts active send/receive operation on a Pipe.

The argument \a pipe_hndl is a handle to pipe on which active transfer should be aborted.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_ControlTransfer (uint8_t device, const USB_SETUP_PACKET *setup_packet, uint8_t *data, uint32_t len)
\details
The function \b USBH_ControlTransfer does an Control Transfer on the Default Pipe.

The argument \a device is the index of the USB Device to which Control Transfer is addressed.

The argument \a setup_packet pointer to setup packet.

The argument \a data containing data bytes to send or where data should be received in data stage of Control Transfer.

The argument \a len number of bytes to send or receive in data stage of Control Transfer.

<b>Code Example</b>
\code
USB_SETUP_PACKET setup_packet;
uint8_t          buf[8];
 
// Custom PL2303 initialization
setup_packet.bmRequestType.Dir      = USB_REQUEST_DEVICE_TO_HOST;
setup_packet.bmRequestType.Type     = USB_REQUEST_VENDOR;
setup_packet.bmRequestType.Recipient= USB_REQUEST_TO_DEVICE;
setup_packet.bRequest               = 1;
setup_packet.wValue                 = U16_LE(0x8484U);
setup_packet.wIndex                 = U16_LE(0U);
setup_packet.wLength                = U16_LE(1U);
if (USBH_ControlTransfer (USBH_CC_Device, &setup_packet, buf,  1U) != usbOK) { return usbClassErrorCustom; }
:
\endcode
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_GetStatus (uint8_t device, uint8_t recipient, uint8_t index, uint8_t *ptr_stat_dat)
\details
The function \b USBH_DeviceRequest_GetStatus implements the standard device request \c GET_STATUS. This request returns the current device
configuration value.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a recipient defines the recipient of the \c GET_STATUS command.

The argument \a index denotes the interface or endpoint index to be used.

The argument \a ptr_stat_dat is a pointer to the where the data should be received.

*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_ClearFeature (uint8_t device, uint8_t recipient, uint8_t index, uint8_t feature_selector)
\details
The function \b USBH_DeviceRequest_ClearFeature implements the standard device request \c CLEAR_FEATURE. This request is used to clear or
disable a specific feature.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a recipient defines the recipient of the \c CLEAR_FEATURE command.

The argument \a index denotes the interface or endpoint index to be used.

The argument \a feature_selector indicates the feature to be cleared.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SetFeature (uint8_t device, uint8_t recipient, uint8_t index, uint8_t feature_selector)
\details
The function \b USBH_DeviceRequest_SetFeature implements the standard device request \c SET_FEATURE. This request is used to set or enable
a specific feature.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a recipient defines the recipient of the \c SET_FEATURE command.

The argument \a index denotes the interface or endpoint index to be used.

The argument \a feature_selector indicates the feature to be cleared.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SetAddress (uint8_t device, uint8_t device_address)
\details
The function \b USBH_DeviceRequest_SetAddress implements the standard device request \c SET_ADDRESS. This request sets the device address
for all future device accesses. 

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a device_address specifies the new device address.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_GetDescriptor (uint8_t device, uint8_t recipient, uint8_t descriptor_type, uint8_t descriptor_index, uint16_t language_id, uint8_t *descriptor_data, uint16_t descriptor_length)
\details
The function \b USBH_DeviceRequest_GetDescriptor implements the standard device request \c GET_DESCRIPTOR. This request returns the
specified descriptor if the descriptor exists. 

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a recipient defines the recipient of the \c GET_DESCRIPTOR command.

The argument \a descriptor_type specifies the descriptor type to be queried, whereas the argument \a descriptor_index is used
to select a specific descriptor (only for configuration and string descriptors) when several descriptors of the same type are
implemented in a device.

The argument \a language_id specifies the Language ID of string descriptors or is set to zero for other descriptors.

The argument \a descriptor_data is a pointer to where descriptor data will be read and \a descriptor_length specifies the
number of bytes to return.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SetDescriptor (uint8_t device, uint8_t recipient, uint8_t descriptor_type, uint8_t descriptor_index, uint16_t language_id, const uint8_t *descriptor_data, uint16_t descriptor_length)
\details
The function \b USBH_DeviceRequest_SetDescriptor implements the standard device request \c SET_DESCRIPTOR. This request may be used to
update existing or add new descriptors.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a recipient defines the recipient of the \c SET_DESCRIPTOR command.

The argument \a descriptor_type specifies the descriptor type to be queried, whereas the argument \a descriptor_index is used
to select a specific descriptor (only for configuration and string descriptors) when several descriptors of the same type are
implemented in a device.

The argument \a language_id specifies the Language ID for string descriptors or is set to zero for other descriptors.

The argument \a descriptor_data is a pointer to where descriptor data will be written and \a descriptor_length specifies the
number of bytes to return.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_GetConfiguration (uint8_t device, uint8_t *ptr_configuration)
\details
The function \b USBH_DeviceRequest_GetConfiguration implements the standard device request \c GET_CONFIGURATION. This request returns the
current device configuration value. 

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a ptr_configuration specifies the pointer to where the configuration will be read.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SetConfiguration (uint8_t device, uint8_t configuration)
\details
The function \b USBH_DeviceRequest_SetConfiguration implements the standard device request \c SET_CONFIGURATION. This request sets the
device configuration. 

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a configuration contains the new configuration to be set.
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\fn usbStatus USBH_DeviceRequest_GetInterface (uint8_t device, uint8_t index, uint8_t *ptr_alternate)
\details
The function \b USBH_DeviceRequest_GetInterface implements the standard device request \c GET_INTERFACE. This request returns the
selected alternate setting for the specified interface.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a index specifies the interface index.

The argument \a ptr_alternate specifies the pointer to where alternate setting data will be read. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SetInterface (uint8_t device, uint8_t index, uint8_t alternate)
\details
The function \b USBH_DeviceRequest_SetInterface implements the standard device request \c SET_INTERFACE. This request allows the
host to select an alternate setting for the specified interface.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a index specifies the interface index.

The argument \a alternate specifies the alternate setting to be set. 
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**

\fn usbStatus USBH_DeviceRequest_SynchFrame (uint8_t device, uint8_t index, uint8_t *ptr_frame_number)
\details
The function \b USBH_DeviceRequest_SynchFrame implements the standard device request \c SYNCH_FRAME. This request is used to set and then
report an endpoint's synchronization frame. When an endpoint supports isochronous transfers, the endpoint may also require
per-frame transfers to vary in size according to a specific pattern. The host and the endpoint must agree on which frame the
repeating pattern begins. The number of the frame in which the pattern began is returned to the host.

The argument \a device is the index of the USB Device to which standard device request is addressed.

The argument \a index specifies the interface index.

The argument \a ptr_frame_number is a pointer to where frame number data will be sent. 
*/

/**
@}
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup usbh_customFunctions_conf Configuration
\ingroup usbh_customFunctions
\brief Configuration of the USB Host Custom Class.
\details
\image  html usbh_config_customclass_h.png "Custom Class Configuration File"

The USB Host Custom Class configuration file <b>USBH_Config_CustomClass.h</b> contains the following settings:
- <b>Number of concurrent Custom Devices in system</b> specifies the number of Custom devices that will be supported.
*/


/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup 	usbh_data_types  Data Types
\ingroup 	usbh
\brief 		Public Data Types used by USB Host component
*/

/**
\addtogroup usbh_data_types
@{
*/

/// USB Host Notification enumerated constants
typedef enum {} USBH_NOTIFY;

/**
\struct usbHID_MouseState
\brief Mouse State structure
\details
<b>Used in</b>
- USB Host Function: \ref USBH_HID_GetMouseState;

\struct CDC_LINE_CODING
\brief CDC Line Coding structure
\details
<b>Used in</b>
- USB Host Function: \ref USBH_CDC_ACM_SetLineCoding; \ref USBH_CDC_ACM_GetLineCoding;

\struct USB_DEVICE_DESCRIPTOR
\brief USB Device Descriptor structure
\details
<b>Used in</b>
- USB Host Function: \ref USBH_CustomClass_Configure;

\struct USB_CONFIGURATION_DESCRIPTOR
\brief USB Configuration Descriptor structure
\details
<b>Used in</b>
- USB Host Function: \ref USBH_CustomClass_Configure;

\typedef typedef uint32_t USBH_PIPE_HANDLE
\brief USB Host Pipe Handle
\details
<b>Used in</b>
- Function: \ref USBH_PipeCreate; \ref USBH_PipeUpdate; \ref USBH_PipeDelete; \ref USBH_PipeReset;\ref USBH_PipeReceive; \ref USBH_PipeReceiveGetResult;
            \ref USBH_PipeSend; \ref USBH_PipeSendGetResult; \ref USBH_PipeAbort;

\typedef typedef void (*USBH_PipeEvent_t) (uint32_t event, const uint8_t *buf, uint32_t len)
\details

The argument \a event specifies the pipe event that happened (as specified by the CMSIS Driver USB Host specification).

The argument \a buf specifies the start of data buffer used for transfer.

The argument \a len specifies the number of data bytes successfully transferred (in bytes).

<b>Used in</b>
- Function: \ref USBH_PipeRegisterCallback;

\struct USB_SETUP_PACKET
\brief USB Setup Packet structure
\details
<b>Used in</b>
- USB Host Function: \ref USBH_ControlTransfer;
*/

/**
@}
*/

/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\defgroup status_error_codes_usb Status and Error Codes
\brief    Status and Error Codes returned by USB functions.
\details
The Status and Error Codes section lists all the return values that the USB Component functions will return.
*/

/**
\ingroup status_error_codes_usb
\typedef enum usbdRequestStatus
*/

/**
\ingroup status_error_codes_usb
\typedef enum usbStatus
*/
