<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>File System Component: Theory of Operation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tabs.js"></script>
<script type="text/javascript" src="footer.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="URL_keys.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<link href="extra_tabs.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="armkeil_white_h.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">File System Component
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown.call(this, "File System Component");
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">MDK Middleware for Devices with Flash File System</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
  <ul class="tablist">
    <script type="text/javascript">
      writeComponentTabs.call(this);
    </script>
  </ul>
</div>
<script type="text/javascript">
  writeSubComponentTabs.call(this);
</script>
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('operation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Theory of Operation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_src_operation"></a> The File System Component provides functions to create, save, read, and modify files. The Retarget Interface of the C/C++ compiler run-time library allows the usage of ANSI C standard file I/O functions. The File System Component is designed for Cortex-M processor-based devices and requires an CMSIS-RTOS compliant real-time operating system for thread-safe operation.</p>
<p>The File System Component consists of two different file systems, placed on top of different layers, depending on the media type:</p><ul>
<li><a class="el" href="operation.html#fat_fs">FAT File System</a> (using FAT12, FAT16, or FAT32) is used for <a class="el" href="create_app.html#mc_usage">memory card</a> devices, <a class="el" href="create_app.html#usb_usage">USB Memory sticks</a>, <a class="el" href="create_app.html#nand_usage">NAND Flash</a> devices, and <a class="el" href="create_app.html#ram_usage">RAM disks</a>. FAT is a standard file system used on many computers.</li>
<li><a class="el" href="operation.html#emb_fs">Embedded File System (EFS)</a> is optimized for <a class="el" href="create_app.html#nor_usage">NOR Flash</a> memory devices.</li>
<li><a class="el" href="operation.html#journaling_fat">Journaling for the FAT File System</a> is an extension to the <a class="el" href="operation.html#fat_fs">FAT File System</a> that helps to keep the file system consistent in an embedded system.</li>
<li>The <a class="el" href="operation.html#mc_control_layer">Memory Card Control Layer</a> is used to control SDxC/MMC/eMMC memory devices.</li>
<li>The <a class="el" href="operation.html#nand_flash_TL">NAND Flash Translation Layer</a> provides means of wear leveling, bad block management, and error correction on <a class="el" href="create_app.html#nand_usage">NAND Flash</a> devices.</li>
</ul>
<h1><a class="anchor" id="fs_usage"></a>
Using the File System</h1>
<p>The File System Component integrates with the Standard C/C++ Library and requires a CMSIS-RTOS2 compliant RTOS. It cannot be used with the Standard C/C++ Library that does not provide the (retarget) hooks for I/O file handling.</p>
<p>The following picture shows the File System's structure from a developer's perspective.</p>
<div class="image">
<img src="fs_structure.png" alt=""/>
<div class="caption">
File System Component Structure</div></div>
    <ul>
<li><b>System, File Management</b>: functions that manage the File System and provide operation to format a drive and manage files and directories.</li>
<li><b>Standard File I/O</b>: functions to perform input and output operations on files, such as read, write, and seek.</li>
<li><b>ARM Standard Run-Time Library</b>: is the ARM Compiler standard C library with functions to manage file.</li>
<li><b>FS_Config.c</b>: configuration file for general characteristics of the file system.</li>
<li><b>FS_Config_xxx_n.h</b>: configuration file for the characteristics of each drive or media (MC, NAND, NOR, RAM, or USB memory sticks).</li>
<li><b>File System Core</b>: handles low-level input and output file operations (some are re-targeted to use the ARM Standard Run-Time Library). Depending on configuration settings, it uses the appropriate file system (FAT or EFS) and implements the NAND Flash Translation Layer.</li>
<li><b>IOC - FAT Media API</b>: are I/O Control Interface Routines for the FAT file system to access physical sectors.</li>
<li><b>FAT, EFS Media</b>: the FAT file system supports Memory Cards (MC), NAND Flash, and USB memory sticks, and RAM disks. The Embedded File System (EFS) supports NOR Flash devices.</li>
<li><b>Drivers</b> The File System Core accesses the drives via CMSIS-Drivers that are typically part of the Device Family Pack. Every drive uses dedicated driver.</li>
</ul>
<p>The configuration steps and files that are needed to create applications for the different devices are explained here:</p><ul>
<li><a class="el" href="create_app.html#nor_usage">NOR Flash Drive</a></li>
<li><a class="el" href="create_app.html#ram_usage">RAM Disk Drive</a></li>
<li><a class="el" href="create_app.html#mc_usage">Memory Card Drive</a></li>
<li><a class="el" href="create_app.html#usb_usage">USB Flash Drive</a></li>
<li><a class="el" href="create_app.html#nand_usage">NAND Flash Drive</a></li>
</ul>
<h1><a class="anchor" id="drive"></a>
Drives, Memory Devices and Drivers</h1>
<p>The File System Component supports various memory and storage devices that are assigned to a <b>drive</b>.</p>
<div class="image">
<img src="fs_types.png" alt=""/>
<div class="caption">
File System Component: Media types and Drives</div></div>
    <p>All available drives are defined with the <a class="el" href="create_app.html#RTE_Component_Selection">RTE Component Selection</a>. A drive is passed as string to <a class="el" href="group__system__routines.html">System Routines</a> and may be part of a filename. The system allows you to configure a current drive that is used when no drive is specified as part of the filename.</p>
<p>The file system type is automatically chosen depending on the drive type (which correlates to a certain memory device). Some drives may use different interfaces that will be covered by appropriate CMSIS-Drivers. The following table shows the relationship between drive - memory device - and driver/interface:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Drive   </th><th class="markdownTableHeadCenter">File System   </th><th class="markdownTableHeadLeft">Drive Type   </th><th class="markdownTableHeadNone">CMSIS-Driver/Interface    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"F:" or "F0:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#emb_fs">EFS</a>   </td><td class="markdownTableBodyLeft">NOR Flash drive 0   </td><td class="markdownTableBodyNone"> <script>link_ext('Flash-API');</script> (Memory Bus or  <script>link_ext('SPI-API');</script>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"F1:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#emb_fs">EFS</a>   </td><td class="markdownTableBodyLeft">NOR Flash drive 1   </td><td class="markdownTableBodyNone"> <script>link_ext('Flash-API');</script> (Memory Bus or  <script>link_ext('SPI-API');</script>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"R:" or "R0:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">RAM drive   </td><td class="markdownTableBodyNone">N/A    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"M:" or "M0:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">Memory Card drive 0   </td><td class="markdownTableBodyNone"> <script>link_ext('MCI-API');</script> or  <script>link_ext('SPI-API');</script>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"M1:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">Memory Card drive 1   </td><td class="markdownTableBodyNone"> <script>link_ext('MCI-API');</script> or  <script>link_ext('SPI-API');</script>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"U:" or "U0:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">USB Memory Stick drive 0   </td><td class="markdownTableBodyNone"> <script>link_ext('USB-API');</script>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"U1:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">USB Memory Stick drive 1   </td><td class="markdownTableBodyNone"> <script>link_ext('USB-API');</script>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">"N:" or "N0:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">NAND Flash drive 0   </td><td class="markdownTableBodyNone"> <script>link_ext('NAND-API');</script> (Memory Bus)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">"N1:"   </td><td class="markdownTableBodyCenter"><a class="el" href="operation.html#fat_fs">FAT</a>   </td><td class="markdownTableBodyLeft">NAND Flash drive 1   </td><td class="markdownTableBodyNone"> <script>link_ext('NAND-API');</script> (Memory Bus)   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>NOR Flash is typically connected over Memory Bus or SPI. For using a NOR Flash drive, a Flash driver is required which encapsulates either the Memory Bus interface or SPI (in which case an SPI driver required in addition).</li>
<li>The Middleware Component contains example drivers for Flash devices that can be used to implement other device drivers if required. The examples are: AM29x800BB/<a href="https://www.farnell.com/datasheets/40281.pdf">M29W640FB</a> (Flash with 16-bit memory bus interface), <a href="https://www.infineon.com/dgdl/Infineon-S29GL064N_S29GL032N_64_Mbit_32_Mbit_3_V_Page_Mode_MirrorBit_Flash-DataSheet-v03_00-EN.pdf">S29GL064Nx2</a> (Flash with 32-bit memory bus interface), and <a href="https://datasheet.octopart.com/AT45DB642D-CNU-Atmel-datasheet-9652374.pdf">AT45DB642D</a> (Flash with SPI interface using an SPI driver).</li>
<li>Other drives (memory card, USB memory device, NAND Flash) require appropriate CMSIS-Driver for the microcontroller device. If no suitable CMSIS-Driver is available for your selected device, you may create the required Flash interface driver. Refer to the  <script>link_ext('CMSIS-Driver-Ref');</script> for details.</li>
<li>Currently, using NAND Flash devices with SPI interface (Serial NAND) <em>is not supported</em>.</li>
</ul>
</dd></dl>
<h2><a class="anchor" id="cur_sys_drive"></a>
Current Drive</h2>
<p>The <b>Current Drive</b> defines the drive used when the filename itself does not specify the drive or when functions that expect a drive are called with an empty ("") string.</p>
<p>If there is only one drive enabled in the system then it automatically becomes the "Current Drive". Alternatively, when there are multiple drives enabled, the one with the drive letter that is first in alphabetical order is set as the "Current Drive". The <a class="el" href="operation.html#cur_sys_drive">Current Drive</a> can be changed during run-time using the function <a class="el" href="group__utility__routines.html#ga75a680af8cbd2e2fae87d99d9ab50e11">fchdrive</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Define <code>FS_INITIAL_CDRIVE</code> can be used to define initial current drive at build time.</li>
<li>Set <code>FS_INITIAL_CDRIVE</code> to one of the following values: 0(F0), 1(F1), 2(M0), 3(M1), 4(N0), 5(N1), 6(R0), 9(R1), 7(U0), 8(U1)</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="fat_fs"></a>
FAT File System</h1>
<p>The FAT File System was initially used on PC operating systems such as MS-DOS and early versions of Microsoft Windows. Still, it is widely used on <b>USB memory sticks</b> or <b>memory cards</b> for file storage. It is simple, robust and offers good performance especially in embedded applications.</p>
<p>FAT is an acronym for <b>File Allocation Table</b>. This table provides the index of the files in the system and is statically allocated at the time of formatting the drive. It contains an entry for each cluster (a data storage area). The FAT's entries contain either the number of the next cluster in the file, or a marker indicating EOF (end of file), unused disk space, or other areas of the drive that are specially reserved. The drive's root directory contains the number of the first cluster of each file in the directory; the operating system traverses the FAT table, looking up the cluster number of each successive part of the file, until the end of the file is reached. Likewise, sub-directories are implemented as special files containing the directory entries of their respective files.</p>
<p>Since the first implementation, the maximum number of clusters of a drive has increased dramatically, and so the number of bits used to identify each cluster has grown. The versions of the FAT format are named after the number of table element bits: <b>FAT12</b>, <b>FAT16</b>, and <b>FAT32</b>. Each of these variants is is supported by the File System Component.</p>
<h2><a class="anchor" id="fat_layout"></a>
Layout</h2>
<p>The actual FAT file system is made up of four different sections: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Section   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Boot sector   </td><td class="markdownTableBodyLeft">Contains machine startup code    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">File Allocation Table   </td><td class="markdownTableBodyLeft">Contains the data region map; multiple entries might exist for redundancy purposes    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Root Directory   </td><td class="markdownTableBodyLeft">Stores information about the files and directories located in the root directory (FAT12/FAT16 only)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">File Data Region   </td><td class="markdownTableBodyLeft">Actual stored file data   </td></tr>
</table>
<h2><a class="anchor" id="fat_volume_label"></a>
Volume name</h2>
<p>Volume label for FAT12, FAT16 or FAT32 volume must be maximum 11 characters long and cannot contain the * ? / \ | , ; : + = &lt; &gt; [ ] " characters.</p>
<h2><a class="anchor" id="fat_path_handling"></a>
Path name handling</h2>
<p>Path name format used to specify either a drive, directory or file:</p>
<ul>
<li><b>[drive:][directory separator][path]</b></li>
</ul>
<p>Depending on the usage case, each specifier can be optional:</p>
<ul>
<li>drive specifier must consist of drive letter followed by optional drive number and a semicolon.</li>
<li>directory separator can be slash (/) or backslash (\)</li>
<li>path can consist of multiple directory names and a file name</li>
</ul>
<h3><a class="anchor" id="fat_abs_rel_path"></a>
Absolute and relative path</h3>
<p>The table below explains how to specify either absolute or relative path.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Path name   </th><th class="markdownTableHeadLeft">Type   </th><th class="markdownTableHeadLeft">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">\   </td><td class="markdownTableBodyLeft">Absolute   </td><td class="markdownTableBodyLeft">Root directory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">\ ..   </td><td class="markdownTableBodyLeft">Absolute   </td><td class="markdownTableBodyLeft">Root directory    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">.   </td><td class="markdownTableBodyLeft">Relative   </td><td class="markdownTableBodyLeft">Current directory    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">..   </td><td class="markdownTableBodyLeft">Relative   </td><td class="markdownTableBodyLeft">Parent directory    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">M:\file.txt   </td><td class="markdownTableBodyLeft">Absolute   </td><td class="markdownTableBodyLeft">A file in root directory of the drive M0    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">M:file.txt   </td><td class="markdownTableBodyLeft">Relative   </td><td class="markdownTableBodyLeft">A file in current directory of the drive M0    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">\file.txt   </td><td class="markdownTableBodyLeft">Absolute   </td><td class="markdownTableBodyLeft">A file in the root directory of the current drive    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">file.txt   </td><td class="markdownTableBodyLeft">Relative   </td><td class="markdownTableBodyLeft">A file in the current directory of the current drive    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">folder1\ ..   </td><td class="markdownTableBodyLeft">Relative   </td><td class="markdownTableBodyLeft">Current directory   </td></tr>
</table>
<h2><a class="anchor" id="lfn_sfn_handling"></a>
Long and Short File Name handling</h2>
<p>File System Component is provided with the long (LFN) and short (SFN or 8.3) filename support. Since there is no compulsory algorithm for creating the 8.3 name from an LFN, File System Component uses convention described below.</p>
<ul>
<li>Uppercased or lowercased name which is 8.3 valid, is stored uppercased in a single SFN entry<ul>
<li>Example: "TEXTFILE.TXT" is stored as "TEXTFILE.TXT" (SFN)</li>
<li>Example: "textfile.txt" is stored as "TEXTFILE.TXT" (SFN)</li>
</ul>
</li>
<li>Mixedcase name which is 8.3 valid, is stored mixed-case in LFN entry and SFN entry is created, which is concluded with tilde and a numeric value.<ul>
<li>Example: "TextFile.txt" is stored as "TextFile.txt" (LFN) and "TEXTFI~1.TXT" (SFN)</li>
</ul>
</li>
<li>Name which is not 8.3 valid is stored in LFN entry and SFN entry. Name writen in SFN entry is uppercased, stripped of invalid 8.3 characters which are replaced with underscore "_" and concluded with tilde and a numeric value.<ul>
<li>Example: "Tex+File.txt" is stored as "Tex+File.txt" (LFN) and "TEX_FI~1.TXT (SFN)"</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="fat_time_stamping"></a>
Time Stamping Support</h2>
<p>The File System Component fully supports time stamping for files and directories:</p>
<ul>
<li>Create time</li>
<li>Create date</li>
<li>Last access date</li>
<li>Write time</li>
<li>Write date</li>
</ul>
<p>To be able to use the time information provided by an on-chip RTC, the user application needs to implement the function <a class="el" href="group__file__time__routines.html#gafe26294de82a7597b98e3ff45ea2004e">fs_get_time()</a>. The <a class="el" href="rl__fs_8h.html#structfsTime">fsTime</a> structure must be filled with the data returned from the RTC driver. If the <a class="el" href="group__file__time__routines.html#gafe26294de82a7597b98e3ff45ea2004e">fs_get_time()</a> function is not implemented in the user application (which is the default), predefined time and date stamps are used.</p>
<h2><a class="anchor" id="journaling_fat"></a>
Journaling for the FAT File System</h2>
<p>The File System Component supports a proprietary <a href="https://en.wikipedia.org/wiki/Journaling_file_system">journaling</a> mechanism for FAT which makes file I/O functions robust against system crashes or power failures. When FAT Journaling is enabled, the file allocation table and directory entries are protected.</p>
<p><b>FAT Journaling</b> keeps track of the changes in the file system using a <b>journal</b> before committing them to the main file system. In the event of a system failure, file system does not become corrupted. Only content of files that are opened in writing mode may be lost. Other files are not affected.</p>
<p>Journaling can be enabled individually for each drive that is using the FAT File System. For information on how to enable Journaling refer to:</p>
<ul>
<li><a class="el" href="create_app.html#mc_usage">Memory Card Drive</a></li>
<li><a class="el" href="create_app.html#usb_usage">USB Flash Drive</a></li>
<li><a class="el" href="create_app.html#nand_usage">NAND Flash Drive</a></li>
</ul>
<h3><a class="anchor" id="sys_init_drv_format"></a>
System Initialization and Drive Formatting</h3>
<p>There requirements for creating a <b>journal</b> are:</p>
<ul>
<li>the drive must be formatted with two FAT tables (two consecutive tables in the FAT section of the drive)</li>
<li>the drive must have at least 64 sectors (= 32kB) of contiguous free space at the end of a partition (in the last 1% space).</li>
</ul>
<p>If journaling is enabled, mounting a drive triggers the File System to search for the journal.</p>
<p>When journal is found the journaling system is initialized and the journal content is checked for any incomplete data transactions that may be the result of a system crash. When incomplete data transactions are found the file system restores the drive to the last known valid state.</p>
<p>When no journal is found, the journal is automatically created. The required space (32kB) for journal is reserved by marking the adequate amount of clusters in the last 1% of the drive partition. This reduces the reported amount of free space on the drive accordingly.</p>
<p>No special drive formatting is required. When a drive is formatted on a different computer (running Window or Linux) free space is typical available at the end of a partition. Creation of a journal may fail on removable media when above requirements are not meet. This may happen if the drive is fragmented or there is not enough space. In this case the drive should be defragmented or some files should be deleted.</p>
<p>When using the <a class="el" href="group__utility__routines.html#gaea20173a589e298b86791f1cc661731b">fformat</a> function of the File System Component, the journal is automatically created on drives with enabled option "Use FAT Journal".</p>
<h3><a class="anchor" id="sys_fail_beh"></a>
System failure behavior</h3>
<p>When File System Component experiences a power loss or crashes before a file opened for writing is successfully closed the content of that file is lost. This results in lost data clusters which can be restored using a file system repair utility tool such as chkdsk on Windows or fsck on Linux.</p>
<h2><a class="anchor" id="fat_sys_design_limitations"></a>
FAT System Design Limitations</h2>
<p>By design, FAT carries a few limitations:</p>
<ul>
<li>Maximum file size is limited to 4,294,967,295 bytes</li>
<li>Maximum files within folder is 65,536 (i.e. a directory must not be larger than 2,097,152 bytes).</li>
<li>A root directory on FAT12 and FAT16 can hold max 512 files/folders (there is no such limitation for FAT32)</li>
<li>FAT type depends on maximum and minimum number of clusters:<ul>
<li>FAT12 maximum clusters: 4,084</li>
<li>FAT16 minimum clusters: 4,085</li>
<li>FAT16 maximum clusters: 65,524</li>
<li>FAT32 minimum clusters: 65,525</li>
</ul>
</li>
<li>Maximum volume size depends on FAT type:<ul>
<li>FAT12: 256MB (for 64kB clusters)</li>
<li>FAT16: 4GB (for 64kB clusters)</li>
<li>FAT32: 2TB (4G of 512B sectors)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="fat_imp_limitations"></a>
FAT Implementation Limitations</h2>
<p>The actual FAT implementation of the File System Component has the following limitations:</p>
<ul>
<li>Multiple partitions are not supported and will not be detected.</li>
<li>Multiple active file handles per file are allowed only for files opened in read mode.</li>
<li>Maximum path length is 260 bytes for FAT with LFN support and 80 bytes for FAT without LFN support.</li>
<li>Seeking within files is limited to the area of two gigabytes due to the <a class="el" href="group__stdio__routines.html#ga800ee8381f5cce368abe5df835aa107c">fseek</a> and <a class="el" href="group__stdio__routines.html#ga6273f71322efc95f429d9e990a8ef8ae">ftell</a> limitation set by ANSI C Standard library.</li>
<li>UTF-16 and UTF-8 character encoding is not supported.</li>
</ul>
<h1><a class="anchor" id="mc_control_layer"></a>
Memory Card Control Layer</h1>
<p>The <b>Memory Card (MC) Control Layer</b> is used when connecting to external memory cards or eMMC devices. It supports data transfer via MCI or SPI, but the data rates are much better using MCI.</p>
<h2><a class="anchor" id="mci_list_of_devices"></a>
List of Supported Devices</h2>
<p>In general, the following devices are supported by the File System Component:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Memory Card   </th><th class="markdownTableHeadNone">Specification    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SD">Standard Capacity SD Memory Card (SDSC)</a>   </td><td class="markdownTableBodyNone">Up to and including 2 GB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SDHC">High Capacity SD Memory Card (SDHC)</a>   </td><td class="markdownTableBodyNone">More than 2GB and up to and including 32GB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SDXC">Extended Capacity SD Memory Card (SDXC)</a>   </td><td class="markdownTableBodyNone">More than 32GB and up to and including 2TB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/MultiMediaCard">MultiMediaCard (MMC)</a>   </td><td class="markdownTableBodyNone">Up to specification version 4.2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/MultiMediaCard#eMMC">Embedded MultiMediaCard (eMMC)</a>   </td><td class="markdownTableBodyNone">From specification 4.3   </td></tr>
</table>
<h2><a class="anchor" id="mci_list_of_mci_capabilities"></a>
List of Supported MCI Driver Capabilities</h2>
<p>MC Control Layer uses  <script>link_ext('MCI-API');</script> when memory device is connected via MCI. Depending on the  <script>link_ext('ARM-MCI-Capabilities');</script>, File System Component can take advantage of certain features. The following table briefly describes how enabled capabilities affect the functionality of the MC Control Layer:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Capability   </th><th class="markdownTableHeadNone">Functionality    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">cd_state   </td><td class="markdownTableBodyNone">Enables device presence detection by pooling the Card Detect (CD) switch state    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">cd_event   </td><td class="markdownTableBodyNone">Enables device presence detection using MCI driver events    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">wp_state   </td><td class="markdownTableBodyNone">Enables write protection detection by pooling Write Protect (WP) switch state    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">vdd   </td><td class="markdownTableBodyNone">Power consumption can be controlled by turning VDD (VCC) power supply on or off    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">vccq   </td><td class="markdownTableBodyNone">Power consumption can be controlled by turning VCCQ power supply on or off    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">data_width_4   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using 4-bit data bus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">data_width_8   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using 8-bit data bus    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">high_speed   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using MCI bus frequencies up to 52MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">rst_n   </td><td class="markdownTableBodyNone">eMMC device can be reset from software using RST_n pin   </td></tr>
</table>
<h2><a class="anchor" id="mci_device_specifics"></a>
Device Specific Features</h2>
<h3><a class="anchor" id="autotoc_md4"></a>
Power Supply Voltage Control</h3>
<p>With appropriately designed hardware and support from the corresponding MCI driver, MC Control Layer can control memory device power supply voltage:</p>
<ul>
<li>VDD (VCC) and VCCQ power supply is turned <b>on</b> when device is <a class="el" href="group__system__routines.html#gade92b7c5b374fb1485f2f9faa7259f27">mounted</a></li>
<li>VDD (VCC) and VCCQ power supply is turned <b>off</b> when device is <a class="el" href="group__system__routines.html#gad1975930d66a5b2fd05ca3502955785b">unmounted</a>,</li>
<li>VCC power supply is turned <b>on/off</b> when eMMC device is <b>switched to/from Sleep state</b></li>
</ul>
<h3><a class="anchor" id="autotoc_md5"></a>
Data Bus Width</h3>
<p>Depending on the memory device type, appropriate data bus width will be selected:</p>
<ul>
<li>1-bit data bus width is selected by default, since it must be supported by all devices and MCI drivers.</li>
<li>4-bit or 8-bit data bus width selection depends on both, device and MCI driver capabilities. In order to switch either to 4 or 8-bit data bus, both, device and MCI driver must support it.</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
High Speed Mode</h3>
<p>The MC Control Layer is able to automatically switch to <a href="https://www.sdcard.org/developers/sd-standard-overview/bus-speed-default-speed-high-speed-uhs-sd-express/">high speed mode</a> for SD cards supporting SD specification version 1.10 or higher (3.3V signaling, bus clock frequency up to 50MHz) and MMC/eMMC devices supporting MMCA specification version 4.2 or higher (3.3V signaling, bus clock frequency up to 52MHz). In order to do so, the high speed mode needs to be supported by the corresponding  <script>link_ext('MCI-API');</script>.</p>
<dl class="section note"><dt>Note</dt><dd>Improper PCB design can cause reliability problems when in high speed mode.</dd></dl>
<h3><a class="anchor" id="autotoc_md7"></a>
Password protection</h3>
<p>The password protection feature enables the host to lock a card while providing a password, which later will be used for unlocking the card. The password is stored to device internal non-volatile registers and can consist of up to 16 bytes, where each byte can be arbitrary 8-bit value.</p>
<p>Password can be managed by using the function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a>, with control code <a class="el" href="rl__fs_8h.html#a46f72ffa53d0379ea0bf5e51373d1a37a1c907bf83317635be0bdb40a3231da23">fsDevCtrlCodeLockUnlock</a> and structure <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> as control code argument. When executing management operation, members of the <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> structure must be set as follows:</p>
<p><b>Setting the password:</b></p>
<ul>
<li>assign password buffer to member <code>.password</code></li>
<li>define password length by setting member <code>.length</code></li>
<li>define set password operation by setting member <code>.flags</code> to <a class="el" href="rl__fs_8h.html#a4dcee13db9af51353d3509331d6ded8f">FS_DEVICE_SET_PASSWORD</a></li>
</ul>
<p>When operation executes successfully, new password is stored into device registers.</p>
<p><b>Reset the password:</b></p>
<ul>
<li>assign password buffer to member <code>.password</code></li>
<li>define password length by setting member <code>.length</code></li>
<li>define clear password operation by setting member <code>.flags</code> to <a class="el" href="rl__fs_8h.html#aefaaef5e8f9772c0f36704f5168fe312">FS_DEVICE_CLR_PASSWORD</a></li>
</ul>
<p>When operation executes successfully, password is cleared from device registers.</p>
<p><b>Lock the card:</b></p>
<ul>
<li>assign password buffer to member <code>.password</code></li>
<li>define password length by setting member <code>.length</code></li>
<li>define lock operation by setting member <code>.flags</code> to <a class="el" href="rl__fs_8h.html#a615e2a30a6833ad0ad79e7186cbbad1b">FS_DEVICE_LOCK_UNLOCK</a></li>
</ul>
<p>When operation executes successfully, data access protection is activated. All read/write accesses are rejected.</p>
<p><b>Unlock the card:</b></p>
<ul>
<li>assign password buffer to member <code>.password</code></li>
<li>define password length by setting member <code>.length</code></li>
<li>define unlock operation by setting member <code>.flags</code> to 0 (zero)</li>
</ul>
<p>When operation executes successfully, data access protection is deactivated. All read/write accesses are allowed.</p>
<p><b>Forcing erase:</b></p>
<ul>
<li>members <code>.password</code> and <code>.length</code> are ignored</li>
<li>define force erase operation by setting member <code>.flags</code> to <a class="el" href="rl__fs_8h.html#a94e215f84b9683736f1c6d7a574d8875">FS_DEVICE_ERASE</a></li>
</ul>
<p>When operation executes successfully, all the card data content is erased along with the current password.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to set password and lock the card in a single step:</dd></dl>
<ul>
<li>define set password and lock the card operation by setting member <code>.flags</code> to (<a class="el" href="rl__fs_8h.html#a4dcee13db9af51353d3509331d6ded8f">FS_DEVICE_SET_PASSWORD</a> | <a class="el" href="rl__fs_8h.html#a615e2a30a6833ad0ad79e7186cbbad1b">FS_DEVICE_LOCK_UNLOCK</a>)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>SD and MMCA specification also allows to replace the password in a single step. This is not supported by the FileSystem library, since it is known that various devices have issues with the interpretation of this operation. Therefore, when changing the password, old one must be first cleared and then new password can be set.</li>
<li>Is is also recommended to unlock the device before resetting the password.</li>
</ul>
</dd></dl>
<p>To successfully <a class="el" href="group__system__routines.html#gade92b7c5b374fb1485f2f9faa7259f27">mount</a> locked memory card and gain read/write data access, password management information must be provided from the user application:</p>
<ul>
<li><a class="el" href="group__media__support__routines.html#gace19ffe245efca9f6ee93e744041b2f1">fs_mc_lock_unlock</a> function is used to return pointer to <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> structure containing password information</li>
</ul>
<p>User application should only implement callback function <a class="el" href="group__media__support__routines.html#gace19ffe245efca9f6ee93e744041b2f1">fs_mc_lock_unlock</a> when support for memory card password management is required. This function will be called only when mounting a memory card with active password protection.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Health Status (S.M.A.R.T)</h3>
<p>Many industrial grade eMMC and SD memory devices support health status monitoring system known as S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology). Health Status monitor data is used to anticipate and detect imminent memory failures.</p>
<p>eMMC and SD memory devices use common command (CMD56) to access vendor specific information about memory health status. In order to retrieve relevant information, function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a> can be used together with control code <a class="el" href="rl__fs_8h.html#a46f72ffa53d0379ea0bf5e51373d1a37ab0fd8541b0842669d009df84fc5c2aba">fsDevCtrlCodeHealthStatus</a> and structure <a class="el" href="rl__fs_8h.html#structfsHealthStatus">fsHealthStatus</a> as control code argument.</p>
<p>Health status access command behavior is vendor specific but in general the following rules apply:</p>
<ul>
<li>Variable <a class="el" href="rl__fs_8h.html#ae9675ffc01a72697b5e4923e042c0d78">fsHealthStatus::arg</a> is used to control data direction and to provide vendor specific control info:<ul>
<li>Bit [0] controls direction: read mode requires setting this bit to 1, write mode requires setting this bit to 0</li>
<li>Bits [1-31] are vendor specific and shall be set according to device datasheet</li>
</ul>
</li>
<li>Variables <a class="el" href="rl__fs_8h.html#a07d14bd491f5711125a12b0c68179fc3">fsHealthStatus::buf</a> and <a class="el" href="rl__fs_8h.html#a1a9fc03f0faaf38a587a34b34f47d19d">fsHealthStatus::buf_sz</a> specify data buffer where health status information will be stored. Data buffer address shall be 4-byte aligned and buffer size shall be equal to or greater than 512 bytes.</li>
</ul>
<p>When function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a> is called, general command (CMD56) is executed and variable <a class="el" href="rl__fs_8h.html#ae9675ffc01a72697b5e4923e042c0d78">fsHealthStatus::arg</a> is used as command argument. The transfered data gets copied into or from the buffer specified by <a class="el" href="rl__fs_8h.html#a07d14bd491f5711125a12b0c68179fc3">fsHealthStatus::buf</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Health Status is usually not available on non-industrial memory devices.</dd></dl>
<h2><a class="anchor" id="mci_power_save"></a>
Power Saving Features</h2>
<p>File System Component tends to reduce overall power consumption as much as possible, therefore the MC Control Layer will automatically:</p>
<ul>
<li><b>switch</b> the memory device between <b>Transfer</b> state and <b>Standby</b> state. This way the memory device spends <b>most of the time in Standby state</b> without noticeable effect on the data transfer performance.</li>
<li><b>stop bus clock</b> when there is <b>no communication</b> on the bus</li>
</ul>
<p>eMMC devices (MMCA specification version 4.3 and higher) support CMD5 (<b>Sleep</b> state). To switch between Sleep state and Standby state, use the function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a>. While in the Sleep state, VCC power supply may be switched off to further minimize the power consumption.</p>
<h2><a class="anchor" id="mc_spi_mode_support"></a>
SPI Mode Support</h2>
<p>SD memory cards (up to SD specification version 4.10) and MMC devices (up to MMCA specification version 4.2) also support Serial Peripheral Interface (SPI) bus mode as alternative way of communication. When SPI mode is used, MC Control Layer will use  <script>link_ext('SPI-API');</script> to use the underlying hardware.</p>
<p>The advantage of using the memory card in SPI mode is in simplified hardware requirements, but at the cost of performance loss and limited command set. Since SPI consists of only SCLK, MOSI, MISO and nSS communication lines, File System Component provides following callback routines for interfacing Card Detect (CD) and Write Protect (WP) switches:</p>
<ul>
<li><a class="el" href="group__media__support__routines.html#ga1d28d3fc259cffa14fd830514b9ae158">fs_mc_read_cd</a> is used to read the state of the <b>Card Detect</b> pin</li>
<li><a class="el" href="group__media__support__routines.html#ga0c0ec29d7858cf8240d4b75b3444df37">fs_mc_read_wp</a> is used to read the state of the <b>Write Protect</b> pin</li>
</ul>
<p>Callback functions <a class="el" href="group__media__support__routines.html#ga1d28d3fc259cffa14fd830514b9ae158">fs_mc_read_cd</a> and <a class="el" href="group__media__support__routines.html#ga0c0ec29d7858cf8240d4b75b3444df37">fs_mc_read_wp</a> are optional. If they are not implemented by user application, File System Component will assume that memory device in SPI mode is always present and without write protection.</p>
<p>Since software controlled Slave Select line is not always available an alternative way is provided in such case:</p>
<ul>
<li><a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> is used to control the <b>Slave Select</b> signal</li>
</ul>
<p>User application should only implement callback function <a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> when SPI driver does not provide software controlled Slave Select line.</p>
<dl class="section note"><dt>Note</dt><dd>Do not implement <a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> when using "SPI Master to Multi-Slave Driver Wrapper". In this case Slave Select line is controlled by Multi-Slave driver function <a href="https://arm-software.github.io/CMSIS-Driver/latest/driver_SPI.html">SPI_Control_SlaveSelect</a>.</dd></dl>
<h3><a class="anchor" id="mc_spi_bus_freq_setting"></a>
SPI bus frequency setting</h3>
<p>Reliable communication at high frequencies is a common problem when using SPI bus, since maximum bus frequency can be limited by PCB design. To overcome this problem, FileSystem component implements simple bus frequency adaptation algorithm in order to determine the maximum bus frequency at which it is still possible to communicate with the memory card.</p>
<p>FileSystem component will always attempt to set the highest bus frequency supported by the memory card (usually 25MHz) but if after that the memory card is not accessible anymore I will lower the bus frequency. The adaptation is performed only during memory card initialization procedure.</p>
<h1><a class="anchor" id="nand_flash_TL"></a>
NAND Flash Translation Layer</h1>
<p><b>Features</b></p>
<ul>
<li>NAND types: SLC, MLC, TLC.</li>
<li>Up to 65536 blocks.</li>
<li>Up to 256 pages in block.</li>
<li><a class="el" href="operation.html#wear_leveling">Wear Leveling</a>.</li>
<li><a class="el" href="operation.html#bad_block_management">Bad Block Management</a>.</li>
<li><a class="el" href="operation.html#slc_ecc">Error Correction Codes (ECC)</a> in software (Hamming) or on-chip (EZ NAND).</li>
<li>Power fail safe.</li>
</ul>
<p><b>NAND Flash Overview</b></p>
<p>NAND Flash memory is used in USB drives, secure digital (SD) cards, memory sticks, CompactFlash cards and multimedia cards (MMC). It is a non-volatile memory with 60 percent smaller memory cells comparing to NOR memory cells thus offers high data density at a lower cost. It is organized into a series of blocks, which are the smallest erasable entities in a NAND Flash device. The smallest entity that can be programmed is a byte. Due to a limited number of times NAND Flash blocks can be reliably programmed and erased (nominally, each NAND block will survive 100000 program/erase cycles) it is critical to implement a <b>NAND Flash Translation Layer (NFTL)</b> to maximize the lifespan of the device. This layer comprises of wear leveling algorithms, bad block management and error control algorithms and thus maximizes the lifespan of a device by redirecting new writes to different physical blocks. It only applies to NAND Flash devices directly attached to the microcontroller.</p>
<dl class="section note"><dt>Note</dt><dd>External storage devices such as memory cards or USB sticks carry an integrated NAND Flash controller that is taking care of the NAND Flash in the device.</dd></dl>
<p><b>NAND Flash Architecture</b></p>
<p>A NAND Flash array is organized in blocks with multiple pages per block. Each page consist of user data area and spare data area. The spare data area is physically the same as user data area and is typically used for error correction information (ECC), wear leveling and other software system functions. The user data area is available to the user for data storage. The size of the user data area depends on the page size and is typically of one or multiple sector size.</p>
<h2><a class="anchor" id="wear_leveling"></a>
Wear Leveling</h2>
<p>Due to its architecture, data can be written to an address on a NAND flash memory only a finite number of times. NAND flash memory wears out if data is written too often to the same address, so wear leveling is used to help prolong the life of the NAND flash device. It ensures that data erasures and writes are distributed evenly across the NAND Flash storage medium, so that NAND memory blocks don't fail prematurely due to a high number of erase cycles.</p>
<p>Dynamic wear leveling addresses the issue of repeated writes to the same logical blocks by redirecting new writes to different physical blocks. Dynamic wear leveling works on data blocks that are being written to dynamically.</p>
<p>Static wear leveling addresses the issue of static data that is kept unchanged for a long time in content and location. Some static data can stay in the same data block until the NAND flash memory is broken. To evenly distribute write and erase cycles across NAND memory blocks, an algorithm is implemented to move the static data from one location to the other in the Flash.</p>
<p>The File System Component implements wear leveling for all kinds of NAND Flash devices (SLC, MLC, TLC).</p>
<h2><a class="anchor" id="bad_block_management"></a>
Bad Block Management</h2>
<p>It is normal for a NAND flash memory to contain bad or invalid blocks of memory. Invalid blocks are blocks that contain one or more invalid bits so that the reliability can no longer be guaranteed. Blocks can become invalid during erasing and programming at run-time or during the manufacturing process. Bad blocks generated during manufacturing process are marked bad by the manufacturer. Bad blocks detected at run-time are marked as bad by monitoring the status register in the NAND flash chip during an erase and program operation. A block that is marked as bad is skipped and no longer used.</p>
<p>The File System Component implements bad block management for all kinds of NAND Flash devices (SLC, MLC, TLC):</p>
<ul>
<li>Skip factory marked bad blocks</li>
<li>Mark block as bad as soon as an erase operation fails on the block</li>
<li>Replace/mode data from blocks marked as bad to good blocks</li>
</ul>
<h2><a class="anchor" id="slc_ecc"></a>
Error Correction Codes (ECC)</h2>
<p>Error detection and correction codes are used in flash memory to protect data from corruption. All types of error correction codes add redundant information to the data being stored to the flash memory. The redundant information is calculated before the data is written, added to the spare area of the page and then stored in flash memory. When the data is read, the redundant information is recalculated and compared to those stored in the flash.</p>
<p>Error correction codes (ECC) used in the NAND flash memory are block codes. This means that the redundant data bits are calculated for a fixed size block of used data. NTFL is implementing a <a href="https://en.wikipedia.org/wiki/Hamming_code">Hamming</a> ECC algorithm which is able to correct 1-bit and detect 2-bit errors for a fixed size of one sector or 512 bytes for SLC NAND Flashes. The redundant information is calculated in a way that a balance of correction power and efficiency is achieved.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you are using a NAND Flash device that requires higher than 1-bit correctability per 512 byte codeword, you need to <b>disable the Software ECC</b> in the <code>FS_Config_NAND_n.h</code> file, otherwise the File System will not function correctly. Hardware driver or on-chip ECC calculation must be provided in such case.</dd></dl>
<p>On-Chip ECC is supported on EZ NAND compliant devices. Various ECC layouts are supported by using flexible ECC codeword configuration.</p>
<div class="image">
<img src="fs_nand_ecc_config_0.png" alt=""/>
<div class="caption">
ECC Configuration (Contiguous Layout)</div></div>
    <p>ECC algorithms typically operate on smaller sections of the NAND physical page size. This section can be described as ECC virtual page, with its main and spare part. Typically main part consists of 512 bytes while spare part can be of different sizes (16, 28, 32, etc. bytes).</p>
<p>Amount of protected data is defined by codeword size, which is typically 512 bytes in main area and of various sizes in spare. Spare codeword may also not be aligned to start of spare area, but is located in spare with some offset. Spare codewords may also follow each other in arbitrary order, therefore codeword gap defines the gap between each codeword. It is similar with generated ECC data - its size, offset from start of spare and gap between each other may be arbitrary.</p>
<h1><a class="anchor" id="emb_fs"></a>
Embedded File System (EFS)</h1>
<p>The <b>Embedded File System (EFS)</b> is a proprietary file system used on NOR flash devices. Basic features are:</p>
<ul>
<li><a class="el" href="operation.html#efs_mem_org">Memory Organization</a> of the flash device is optimized for maximum performance.</li>
<li><a class="el" href="operation.html#efs_alloc_info">Allocation Information</a> is reduced to a minimum, allowing small data overhead.</li>
<li><a class="el" href="operation.html#efs_file_content">File Names &amp; Content</a> are stored in fragments of variable size which provide optimal file access times.</li>
</ul>
<h2><a class="anchor" id="efs_mem_org"></a>
Memory Organization</h2>
<p>A NOR flash device memory array is physically divided into <b>sectors</b> or <b>blocks</b>. The File System Component designates them as <b>blocks</b>. Typically, a block's size is 64 kB which is also the smallest erasable unit. Blocks can be further divided, down to memory cells. The memory cell size depends on the device architecture and is 8- (byte), 16- (half word) or 32-bit wide (word). The memory cell architecture also defines smallest programmable unit, which must be maximum 32-bit for use with the Embedded File System.</p>
<p>Embedded File System organizes each block into three regions:</p>
<ul>
<li><a class="el" href="operation.html#efs_alloc_info">Allocation Information</a>, located on top of the block, grows in descending order and contains file allocation records.</li>
<li><b>Free Space</b></li>
<li><a class="el" href="operation.html#efs_file_content">File Names &amp; Content</a>, located on bottom of the block, grows in ascending order and contains file names and data.</li>
</ul>
<div class="image">
<img src="fs_memoryorg.png" alt=""/>
<div class="caption">
Flash Memory Organization</div></div>
    <h2><a class="anchor" id="efs_alloc_info"></a>
Allocation Information</h2>
<p>Allocation information region is located on top of a block and describes the block's content. It consists of block signature and file allocation information records, which are written in descending order. Each file has at least one record associated with it. Multiple records belong to files with content and to fragmented files. A file is fragmented when it is modified or its content size exceeds a single block size and must be stored across several blocks. Several small files are stored into a single block.</p>
<div class="image">
<img src="fs_allocinfo.png" alt=""/>
<div class="caption">
Flash Block Allocation</div></div>
    <h3><a class="anchor" id="autotoc_md9"></a>
Block Signature</h3>
<p>Each block contains a signature, consisting of 4 bytes and determines if block is:</p>
<ul>
<li><b>empty</b> i.e. erased</li>
<li><b>used</b> but more data can be written into it</li>
<li><b>used</b> temporarily during defragmentation</li>
<li><b>full</b> and cannot be written anymore (only erased)</li>
</ul>
<h3><a class="anchor" id="autotoc_md10"></a>
Allocation Information Record</h3>
<p>The file allocation information record consists of 8 bytes and has the following components:</p>
<ul>
<li><b>end</b> is the end address of the file fragment.</li>
<li><b>fileID</b> is the file identification number and is associated with the file name.</li>
<li><b>index</b> is the file fragment ordering number, which starts at 0 for each file.</li>
</ul>
<div class="fragment"><div class="line">struct falloc {</div>
<div class="line">  uint32_t end;</div>
<div class="line">  uint16_t fileID;</div>
<div class="line">  uint16_t index;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The file allocation information is written when:</p>
<ul>
<li>The file is opened for writing.</li>
<li>The file is closed.</li>
<li>The file is flushed and file fragment is not yet defined by the allocation information record.</li>
<li>The block is full and there is no more free space.</li>
</ul>
<h2><a class="anchor" id="efs_file_content"></a>
File Names &amp; Content</h2>
<p>The file names &amp; content region is located at the bottom of a block and is fully defined through the file allocation information records. It consists of file names and file content, which can both be fragmented. The first file fragment always starts at the beginning of a block (at offset 0) and is written in ascending order.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
File Names</h3>
<p>In the Embedded File System, a file name consists of maximum 31 characters. Directories are not supported, therefore any file name which contains a directory separator character, such as slash (/) or backslash(\), is rejected as invalid. Other characters are allowed.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
File Content</h3>
<p>Since file fragments are of variable size, <b>create big file fragments</b> in order to reduce the total number of file fragments and make the best use of a block. Writing or appending small amounts of data to a file is not optimal, since such an approach creates a large number of allocation information records. They consume free space and the required processing time results in a slow file access time.</p>
<p>When the file content is modified, the old file content is invalidated and a new file fragment is allocated. a block is erased when all the data stored within has been invalidated.</p>
<h2><a class="anchor" id="efs_limits"></a>
Limitations</h2>
<p>The following restrictions are applicable to the EFS:</p>
<ul>
<li>Maximum file name length is limited to 31 characters.</li>
<li>Minimum block size should be 512 bytes or more.</li>
<li>Directories or folders are not supported.</li>
<li>Multiple active file handles per file are allowed only for files opened in read mode.</li>
<li>Seeking (<a class="el" href="group__stdio__routines.html#ga800ee8381f5cce368abe5df835aa107c">fseek</a>) within files works only for files opened in read mode.</li>
<li>File update modes (r+, w+, a+) (<a class="el" href="group__stdio__routines.html#ga76a21223ed39a2692fdfc854aab93b2c">fopen</a>) are not supported.</li>
<li>Timestamp information is not supported for a file.</li>
<li>Drive partitions are not supported.</li>
<li>The EFS is not compatible with the FAT file system and cannot be used with a USB mass storage device. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
