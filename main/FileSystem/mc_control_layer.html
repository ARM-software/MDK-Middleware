<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>File System Component: Memory Card Control Layer</title>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tabs.js"></script>
<script type="text/javascript" src="footer.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="URL_keys.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<link href="extra_tabs.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="armkeil_white_h.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">File System Component
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown.call(this, "File System Component");
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">MDK Middleware for Devices with Flash File System</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
  <ul class="tablist">
    <script type="text/javascript">
      writeComponentTabs.call(this);
    </script>
  </ul>
</div>
<script type="text/javascript">
  writeSubComponentTabs.call(this);
</script>
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('mc_control_layer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Memory Card Control Layer </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <b> Memory Card (MC) Control Layer </b> is used when connecting to external memory cards or eMMC devices. It supports data transfer via MCI or SPI, but the data rates are much better using MCI.</p>
<h1><a class="anchor" id="mci_list_of_devices"></a>
List of Supported Devices</h1>
<p>In general, the following devices are supported by the File System Component: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Memory Card   </th><th class="markdownTableHeadNone">Specification    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SD" target="_blank">Standard Capacity SD Memory Card (SDSC)</a>   </td><td class="markdownTableBodyNone">Up to and including 2 GB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SDHC" target="_blank">High Capacity SD Memory Card (SDHC)</a>   </td><td class="markdownTableBodyNone">More than 2GB and up to and including 32GB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/Secure_Digital#SDXC" target="_blank">Extended Capacity SD Memory Card (SDXC)</a>   </td><td class="markdownTableBodyNone">More than 32GB and up to and including 2TB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/MultiMediaCard" target="_blank">MultiMediaCard (MMC)</a>   </td><td class="markdownTableBodyNone">Up to specification version 4.2    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://en.wikipedia.org/wiki/MultiMediaCard#eMMC" target="_blank">Embedded MultiMediaCard (eMMC)</a>   </td><td class="markdownTableBodyNone">From specification 4.3   </td></tr>
</table>
<h1><a class="anchor" id="mci_list_of_mci_capabilities"></a>
List of Supported MCI Driver Capabilities</h1>
<p>MC Control Layer uses  <script>link_ext('MCI-API');</script> when memory device is connected via MCI. Depending on the  <script>link_ext('ARM-MCI-Capabilities');</script>, File System Component can take advantage of certain features. The following table briefly describes how enabled capabilities affect the functionality of the MC Control Layer:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Capability   </th><th class="markdownTableHeadNone">Functionality    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">cd_state   </td><td class="markdownTableBodyNone">Enables device presence detection by pooling the Card Detect (CD) switch state    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">cd_event   </td><td class="markdownTableBodyNone">Enables device presence detection using MCI driver events    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">wp_state   </td><td class="markdownTableBodyNone">Enables write protection detection by pooling Write Protect (WP) switch state    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">vdd   </td><td class="markdownTableBodyNone">Power consumption can be controlled by turning VDD (VCC) power supply on or off    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">vccq   </td><td class="markdownTableBodyNone">Power consumption can be controlled by turning VCCQ power supply on or off    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">data_width_4   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using 4-bit data bus    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">data_width_8   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using 8-bit data bus    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">high_speed   </td><td class="markdownTableBodyNone">Data transfer rate can be increased by using MCI bus frequencies up to 52MHz    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">rst_n   </td><td class="markdownTableBodyNone">eMMC device can be reset from software using RST_n pin   </td></tr>
</table>
<h1><a class="anchor" id="mci_device_specifics"></a>
Device Specific Features</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Power Supply Voltage Control</h2>
<p>With appropriately designed hardware and support from the corresponding MCI driver, MC Control Layer can control memory device power supply voltage:</p><ul>
<li>VDD (VCC) and VCCQ power supply is turned <b>on</b> when device is <a class="el" href="group__system__routines.html#gade92b7c5b374fb1485f2f9faa7259f27">mounted</a></li>
<li>VDD (VCC) and VCCQ power supply is turned <b>off</b> when device is <a class="el" href="group__system__routines.html#gad1975930d66a5b2fd05ca3502955785b">unmounted</a>,</li>
<li>VCC power supply is turned <b>on/off</b> when eMMC device is <b>switched to/from Sleep state</b></li>
</ul>
<h2><a class="anchor" id="autotoc_md7"></a>
Data Bus Width</h2>
<p>Depending on the memory device type, appropriate data bus width will be selected:</p><ul>
<li>1-bit data bus width is selected by default, since it must be supported by all devices and MCI drivers.</li>
<li>4-bit or 8-bit data bus width selection depends on both, device and MCI driver capabilities. In order to switch either to 4 or 8-bit data bus, both, device and MCI driver must support it.</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
High Speed Mode</h2>
<p>The MC Control Layer is able to automatically switch to <a href="https://www.sdcard.org/developers/sd-standard-overview/bus-speed-default-speed-high-speed-uhs-sd-express/" target="_blank">high speed mode</a> for SD cards supporting SD specification version 1.10 or higher (3.3V signaling, bus clock frequency up to 50MHz) and MMC/eMMC devices supporting MMCA specification version 4.2 or higher (3.3V signaling, bus clock frequency up to 52MHz). In order to do so, the high speed mode needs to be supported by the corresponding  <script>link_ext('MCI-API');</script>.</p>
<dl class="section note"><dt>Note</dt><dd>Improper PCB design can cause reliability problems when in high speed mode.</dd></dl>
<h2><a class="anchor" id="autotoc_md9"></a>
Password protection</h2>
<p>The password protection feature enables the host to lock a card while providing a password, which later will be used for unlocking the card. The password is stored to device internal non-volatile registers and can consist of up to 16 bytes, where each byte can be arbitrary 8-bit value.</p>
<p>Password can be managed by using the function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a>, with control code <a class="el" href="rl__fs_8h.html#a46f72ffa53d0379ea0bf5e51373d1a37a1c907bf83317635be0bdb40a3231da23">fsDevCtrlCodeLockUnlock</a> and structure <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> as control code argument. When executing management operation, members of the <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> structure must be set as follows:</p>
<p><b> Setting the password: </b></p><ul>
<li>assign password buffer to member .password</li>
<li>define password length by setting member .length</li>
<li>define set password operation by setting member .flags to <a class="el" href="rl__fs_8h.html#a4dcee13db9af51353d3509331d6ded8f">FS_DEVICE_SET_PASSWORD</a></li>
</ul>
<p>When operation executes successfully, new password is stored into device registers.</p>
<p><b> Reset the password: </b></p><ul>
<li>assign password buffer to member .password</li>
<li>define password length by setting member .length</li>
<li>define clear password operation by setting member .flags to <a class="el" href="rl__fs_8h.html#aefaaef5e8f9772c0f36704f5168fe312">FS_DEVICE_CLR_PASSWORD</a></li>
</ul>
<p>When operation executes successfully, password is cleared from device registers.</p>
<p><b> Lock the card: </b></p><ul>
<li>assign password buffer to member .password</li>
<li>define password length by setting member .length</li>
<li>define lock operation by setting member .flags to <a class="el" href="rl__fs_8h.html#a615e2a30a6833ad0ad79e7186cbbad1b">FS_DEVICE_LOCK_UNLOCK</a></li>
</ul>
<p>When operation executes successfully, data access protection is activated. All read/write accesses are rejected.</p>
<p><b> Unlock the card: </b></p><ul>
<li>assign password buffer to member .password</li>
<li>define password length by setting member .length</li>
<li>define unlock operation by setting member .flags to 0 (zero)</li>
</ul>
<p>When operation executes successfully, data access protection is deactivated. All read/write accesses are allowed.</p>
<p><b> Forcing erase: </b></p><ul>
<li>members .password and .length are ignored</li>
<li>define force erase operation by setting member .flags to <a class="el" href="rl__fs_8h.html#a94e215f84b9683736f1c6d7a574d8875">FS_DEVICE_ERASE</a></li>
</ul>
<p>When operation executes successfully, all the card data content is erased along with the current password.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to set password and lock the card in a single step:<ul>
<li>define set password and lock the card operation by setting member .flags to (<a class="el" href="rl__fs_8h.html#a4dcee13db9af51353d3509331d6ded8f">FS_DEVICE_SET_PASSWORD</a> | <a class="el" href="rl__fs_8h.html#a615e2a30a6833ad0ad79e7186cbbad1b">FS_DEVICE_LOCK_UNLOCK</a>)</li>
</ul>
</dd>
<dd>
SD and MMCA specification also allows to replace the password in a single step. This is not supported by the FileSystem library, since it is known that various devices have issues with the interpretation of this operation. Therefore, when changing the password, old one must be first cleared and then new password can be set.</dd>
<dd>
Is is also recommended to unlock the device before resetting the password.</dd></dl>
<p>To successfully <a class="el" href="group__system__routines.html#gade92b7c5b374fb1485f2f9faa7259f27">mount</a> locked memory card and gain read/write data access, password management information must be provided from the user application:</p><ul>
<li><a class="el" href="group__media__support__routines.html#gace19ffe245efca9f6ee93e744041b2f1">fs_mc_lock_unlock</a> function is used to return pointer to <a class="el" href="rl__fs_8h.html#structfsLockUnlock">fsLockUnlock</a> structure containing password information</li>
</ul>
<p>User application should only implement callback function <a class="el" href="group__media__support__routines.html#gace19ffe245efca9f6ee93e744041b2f1">fs_mc_lock_unlock</a> when support for memory card password management is required. This function will be called only when mounting a memory card with active password protection.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Health Status (S.M.A.R.T)</h2>
<p>Many industrial grade eMMC and SD memory devices support health status monitoring system known as S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology). Health Status monitor data is used to anticipate and detect imminent memory failures.</p>
<p>eMMC and SD memory devices use common command (CMD56) to access vendor specific information about memory health status. In order to retrieve relevant information, function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a> can be used together with control code <a class="el" href="rl__fs_8h.html#a46f72ffa53d0379ea0bf5e51373d1a37ab0fd8541b0842669d009df84fc5c2aba">fsDevCtrlCodeHealthStatus</a> and structure <a class="el" href="rl__fs_8h.html#structfsHealthStatus">fsHealthStatus</a> as control code argument.</p>
<p>Health status access command behavior is vendor specific but in general the following rules apply:</p><ul>
<li>Variable <a class="el" href="rl__fs_8h.html#ae9675ffc01a72697b5e4923e042c0d78">fsHealthStatus::arg</a> is used to control data direction and to provide vendor specific control info:<ul>
<li>Bit [0] controls direction: read mode requires setting this bit to 1, write mode requires setting this bit to 0</li>
<li>Bits [1-31] are vendor specific and shall be set according to device datasheet</li>
</ul>
</li>
<li>Variables <a class="el" href="rl__fs_8h.html#a07d14bd491f5711125a12b0c68179fc3">fsHealthStatus::buf</a> and <a class="el" href="rl__fs_8h.html#a1a9fc03f0faaf38a587a34b34f47d19d">fsHealthStatus::buf_sz</a> specify data buffer where health status information will be stored. Data buffer address shall be 4-byte aligned and buffer size shall be equal to or greater than 512 bytes.</li>
</ul>
<p>When function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a> is called, general command (CMD56) is executed and variable <a class="el" href="rl__fs_8h.html#ae9675ffc01a72697b5e4923e042c0d78">fsHealthStatus::arg</a> is used as command argument. The transfered data gets copied into or from the buffer specified by <a class="el" href="rl__fs_8h.html#a07d14bd491f5711125a12b0c68179fc3">fsHealthStatus::buf</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Health Status is usually not available on non-industrial memory devices.</dd></dl>
<h1><a class="anchor" id="mci_power_save"></a>
Power Saving Features</h1>
<p>File System Component tends to reduce overall power consumption as much as possible, therefore the MC Control Layer will automatically:</p><ul>
<li><b>switch</b> the memory device between <b>Transfer</b> state and <b>Standby</b> state. This way the memory device spends <b>most of the time in Standby state</b> without noticeable effect on the data transfer performance.</li>
<li><b>stop bus clock</b> when there is <b>no communication</b> on the bus</li>
</ul>
<p>eMMC devices (MMCA specification version 4.3 and higher) support CMD5 (<b>Sleep</b> state). To switch between Sleep state and Standby state, use the function <a class="el" href="group__ioc__interface__routines.html#ga3036c7dbc536ec052c41056245df407e">fs_ioc_device_ctrl</a>. While in the Sleep state, VCC power supply may be switched off to further minimize the power consumption.</p>
<h1><a class="anchor" id="mc_spi_mode_support"></a>
SPI Mode Support</h1>
<p>SD memory cards (up to SD specification version 4.10) and MMC devices (up to MMCA specification version 4.2) also support Serial Peripheral Interface (SPI) bus mode as alternative way of communication. When SPI mode is used, MC Control Layer will use  <script>link_ext('SPI-API');</script> to use the underlying hardware.</p>
<p>The advantage of using the memory card in SPI mode is in simplified hardware requirements, but at the cost of performance loss and limited command set. Since SPI consists of only SCLK, MOSI, MISO and nSS communication lines, File System Component provides following callback routines for interfacing Card Detect (CD) and Write Protect (WP) switches:</p><ul>
<li><a class="el" href="group__media__support__routines.html#ga1d28d3fc259cffa14fd830514b9ae158">fs_mc_read_cd</a> is used to read the state of the <b>Card</b> <b>Detect</b> pin</li>
<li><a class="el" href="group__media__support__routines.html#ga0c0ec29d7858cf8240d4b75b3444df37">fs_mc_read_wp</a> is used to read the state of the <b>Write</b> <b>Protect</b> pin</li>
</ul>
<p>Callback functions <a class="el" href="group__media__support__routines.html#ga1d28d3fc259cffa14fd830514b9ae158">fs_mc_read_cd</a> and <a class="el" href="group__media__support__routines.html#ga0c0ec29d7858cf8240d4b75b3444df37">fs_mc_read_wp</a> are optional. If they are not implemented by user application, File System Component will assume that memory device in SPI mode is always present and without write protection.</p>
<p>Since software controlled Slave Select line is not always available an alternative way is provided in such case:</p><ul>
<li><a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> is used to control the <b>Slave</b> <b>Select</b> signal</li>
</ul>
<p>User application should only implement callback function <a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> when SPI driver does not provide software controlled Slave Select line.</p>
<dl class="section note"><dt>Note</dt><dd>Do not implement <a class="el" href="group__media__support__routines.html#gac03f8075d61e08db4dafc5ab740d172f">fs_mc_spi_control_ss</a> when using "SPI Master to Multi-Slave Driver Wrapper". In this case Slave Select line is controlled by Multi-Slave driver function <a href="https://arm-software.github.io/CMSIS-Driver/latest/driver_SPI.html" target="_blank">SPI_Control_SlaveSelect</a>.</dd></dl>
<p><a class="anchor" id="mc_spi_bus_freq_setting"></a></p>
<h2><a class="anchor" id="autotoc_md11"></a>
SPI bus frequency setting</h2>
<p>Reliable communication at high frequencies is a common problem when using SPI bus, since maximum bus frequency can be limited by PCB design. To overcome this problem, FileSystem component implements simple bus frequency adaptation algorithm in order to determine the maximum bus frequency at which it is still possible to communicate with the memory card.</p>
<p>FileSystem component will always attempt to set the highest bus frequency supported by the memory card (usually 25MHz) but if after that the memory card is not accessible anymore I will lower the bus frequency. The adaptation is performed only during memory card initialization procedure. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
