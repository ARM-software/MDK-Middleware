<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USB Component: USB Concepts</title>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tabs.js"></script>
<script type="text/javascript" src="footer.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="URL_keys.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<link href="extra_tabs.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="armkeil_white_h.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">USB Component
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown.call(this, "USB Component");
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">MDK Middleware for USB Device and Host Communication</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
  <ul class="tablist">
    <script type="text/javascript">
      writeComponentTabs.call(this);
    </script>
  </ul>
</div>
<script type="text/javascript">
  writeSubComponentTabs.call(this);
</script>
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('USB_Concepts.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">USB Concepts</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_src_2usb__concepts"></a></p>
<p>The <b>Universal Serial Bus</b> (USB) is a serial interface designed to be plug-and-play making it easy to connect peripherals to a host. The following pages are intended to help the designer to get a better understanding about the USB protocol in general. They are divided into different pages as follows:</p>
<ul>
<li><a class="el" href="#USB_Network">USB Network</a> shows the topology of the USB network.</li>
<li><a class="el" href="#USB_Transfer_Rates">USB Transfer Rates</a> gives a quick glance at the theoretical maximum data rates that are supported by USB.</li>
<li><a class="el" href="#USB_Endpoints">Endpoints</a> shows how data is exchanged on the USB bus.</li>
<li><a class="el" href="#USB_Protocol">USB Protocol</a> page gives an overview over the protocol and the basic communication model.</li>
<li><a class="el" href="#USB_Descriptors">USB Descriptors</a> explains the data structure that is used in USB devices to report their attributes to a host. Most of these descriptors can be matched to configuration settings in MDK.</li>
</ul>
<h1><a class="anchor" id="USB_Transfer_Rates"></a>
USB Transfer Rates</h1>
<p>USB uses two wires to supply power and two wires to transfer signals. The following data transfer rates are supported:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Performance   </th><th class="markdownTableHeadNone">Attributes   </th><th class="markdownTableHeadNone">Applications    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Low-Speed: 1.5 Mbits/s   </td><td class="markdownTableBodyNone">Lower cost <br  />
 Hot-pluggable <br  />
 Multiple peripherals   </td><td class="markdownTableBodyNone">interactive devices: <br  />
 mouse, keyboards, game peripherals    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Full-Speed: 12 Mbits/s   </td><td class="markdownTableBodyNone">Low cost <br  />
 Hot-pluggable <br  />
 Multiple peripherals <br  />
 Guaranteed latency <br  />
 Guaranteed bandwidth   </td><td class="markdownTableBodyNone">phone, audio, compressed video, printers, scanners    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">High-Speed: 480 Mbits/s   </td><td class="markdownTableBodyNone">Guaranteed latency <br  />
 High bandwidth   </td><td class="markdownTableBodyNone">video, mass storage   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>SuperSpeed is not covered in this document.</dd></dl>
<h1><a class="anchor" id="USB_Network"></a>
USB Network</h1>
<p>The <b>physical USB network</b> is implemented as a tiered star network with one host (master) and several devices (slaves).</p>
<p>The USB Host provides one attachment port. If more peripherals are required, connect a hub to the root port to provide additional connection ports. The USB network can support up to 127 external nodes. Due to timing constraints for signal propagation, the maximum number of tiers allowed is seven:</p>
<ul>
<li>One tier for the host (bus master).</li>
<li>Six tiers for hubs and devices.</li>
</ul>
<div class="image">
<img src="tiernetwork.png" alt=""/>
<div class="caption">
Tier Network</div></div>
    <p>USB devices are divided into device classes:</p>
<ul>
<li><b>Hubs</b> provide additional attachment points and simplify USB connectivity from the user perspective. Each hub converts a single attachment point into multiple attachment points referred to as ports.</li>
<li><b>Functions</b> provide capabilities to the system for transmitting or receiving data and control information. Each function contains configuration information describing the device capabilities and resource requirements.</li>
<li><b>Compound Devices</b> are physical packages that implement multiple functions and include an embedded hub. A compound device appears to the host as a hub with one or more non-removable USB devices.</li>
<li><b>Composite Devices</b> support more than one class and thus, provide more than one function to the host.</li>
</ul>
<p>Examples of functions:</p>
<ul>
<li>A human interface device such as a mouse, keyboard, tablet, or game controller.</li>
<li>An imaging device such as a scanner, printer, or camera.</li>
<li>A mass storage device such as a CD-ROM drive, floppy drive, or DVD drive.</li>
</ul>
<p>The <b>logical USB network</b> appears as a star network to the developer with the host at the center. Hubs do not introduce any programming complexity and are transparent as far as the programmer is concerned. An USB device will work the same way whether connected directly to a root-hub or whether connected via intermediate hubs. All USB devices are available as addressable nodes in this master/slave network. Only the host can initiate a data transfer in the network.</p>
<div class="image">
<img src="starnetwork.png" alt=""/>
<div class="caption">
Star Network</div></div>
    <dl class="section note"><dt>Note</dt><dd><ul>
<li>Only one host exists in any USB system.</li>
<li>Only functions can be enabled in tier seven.</li>
<li>Compound devices occupy two tiers.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="USB_Communication"></a>
USB Communication</h1>
<p>USB is a polled bus, where the USB Host initiates all data exchanges. The data travels to or from <a class="el" href="#USB_Endpoints">Endpoints</a> in an USB Device. The <b>client</b> in the USB Host stores data in buffers, but does not have endpoints. The USB Host and the peripheral USB Device have distinct layers, as shown in the picture below. The connections between the layers are <b>logical</b> Host-Device interfaces between each horizontal layer. Between the logical connections data is transferred using <a class="el" href="#USB_Pipes">Pipes</a>.</p>
<div class="image">
<img src="usb_endpoints.png" alt=""/>
<div class="caption">
Logical Connections Between USB Host Clients and USB Device Endpoints</div></div>
    <h2><a class="anchor" id="USB_Pipes"></a>
Pipes</h2>
<p>Basically, two types of <b>pipes</b> exist:</p><ul>
<li><b>Message pipes</b> have a defined USB format and are host controlled. Message pipes allow data to flow in both directions and support <a class="el" href="#USB_Control_Transfers">Control Transfers</a> only.</li>
<li><b>Stream pipes</b> have no defined USB format and can either be controlled by the host or by the device. The data stream has a predefined direction, either <b>IN</b> or <b>OUT</b>. Stream pipes support <a class="el" href="#USB_Interrupt_Transfers">Interrupt Transfers</a>, <a class="el" href="#USB_Isochronous_Transfers">Isochronous Transfers</a>, and <a class="el" href="#USB_Bulk_Transfers">Bulk Transfers</a>.</li>
</ul>
<p>Most pipes come into existence when an USB Device has been connected to the USB Bus and configured by the USB Host. A pipe originates from a <b>data buffer</b> within the host <b>client</b> and terminates inside the USB Device at an <a class="el" href="#USB_Endpoints">Endpoint</a>.</p>
<h2><a class="anchor" id="USB_Transfers"></a>
Transfers</h2>
<p><b>Transfers</b> (data flow types) can consist of one or more transactions. A pipe supports only one of the following transfer types:</p><ul>
<li><a class="el" href="#USB_Control_Transfers">Control Transfers</a> are typically used to setup an USB device. They always use IN/OUT Endpoint 0.</li>
<li><a class="el" href="#USB_Interrupt_Transfers">Interrupt Transfers</a> can be used where data is sent regularly, for example for status updates.</li>
<li><a class="el" href="#USB_Isochronous_Transfers">Isochronous Transfers</a> transmit real-time data such as audio and video. They have a guaranteed, fixed bandwidth, but no error detection.</li>
<li><a class="el" href="#USB_Bulk_Transfers">Bulk Transfers</a> can be used to send data where timing is not important, for example to a printer.</li>
</ul>
<h3><a class="anchor" id="USB_Control_Transfers"></a>
Control Transfers</h3>
<p><b>Control Transfers</b> are bi-directional transfers reserved for the host to send and request configuration information to and from the device using the IN and OUT Endpoint 0.</p>
<p>Each Control Transfer consists of 2 to several transactions. The maximum packet size for the control endpoint data is:</p>
<ul>
<li>8 bytes for low-speed</li>
<li>8, 16, 32, or 64 bytes for full-speed</li>
<li>64 bytes for high-speed</li>
</ul>
<p>In general, the application software does not use this type of transfer.</p>
<p>Control Transfers have three stages:</p>
<ol type="1">
<li>The <b>SETUP</b> stage carries 8 bytes called the Setup packet, defining the request, and specifying how many data should be transferred in the DATA stage. <img src="ctrlTransferSetup.png" alt="" class="inline" title="Control SETUP Transaction Format"/>    </li>
</ol>
<p><br  />
</p><ol type="1">
<li>The <b>DATA</b> stage is optional. If present, it always starts with a transaction containing a DATA1 packet. Then, the transaction type alternates between DATA0 and DATA1 until all required data have been transferred.</li>
<li>The <b>STATUS</b> stage is a transaction containing a zero-length DATA1 packet. If the DATA stage was IN, then the STATUS stage is OUT, and vice-versa.</li>
</ol>
<div class="image">
<img src="ctrlTransferRedWriteSeq.png" alt=""/>
<div class="caption">
Control Read and Write Sequences</div></div>
    <h3><a class="anchor" id="USB_Interrupt_Transfers"></a>
Interrupt Transfers</h3>
<p><b>Interrupt Transfers</b> have a limited latency to or from a device. In USB, an Interrupt Transfer, or Interrupt Pipe, has a defined polling rate between:</p>
<ul>
<li>1ms and 255ms for full and low-speed</li>
<li>125&mu;s to 4096ms for high-speed endpoints.</li>
</ul>
<p>The maximum packet size for the interrupt endpoint data is:</p>
<ul>
<li>64 or less bytes for full-speed</li>
<li>1024 or less bytes for high-speed</li>
</ul>
<p>The developer can define how often the host can request a data transfer from the device.</p>
<p>For example, for a mouse, a data transfer rate at every 10 ms can be guaranteed. However, defining the polling rate does not guarantee that data will be transferred every 10 ms, but rather that the transaction will occur somewhere within the tenth frame. For this reason, a certain amount of timing jitter is inherent in an USB transaction.</p>
<p>Typically, Interrupt Transfer data consists of event notifications, characters, or coordinates from a pointing device.</p>
<div class="image">
<img src="interruptTransfer.png" alt=""/>
<div class="caption">
Interrupt Transfer Format</div></div>
    <h3><a class="anchor" id="USB_Isochronous_Transfers"></a>
Isochronous Transfers</h3>
<p><b>Isochronous Transfers</b> are used for transmitting real-time information such as audio and video data, and must be sent at a constant rate. USB isochronous data streams are allocated a dedicated portion of USB bandwidth to ensure that data can be delivered at the desired rate. An Isochronous pipe sends a new data packet in every frame, regardless of the success or failure of the last packet.</p>
<p>The maximum packet size for the isochronous endpoint data is:</p>
<ul>
<li>1023 or less bytes for full-speed</li>
<li>1024 or less bytes for high-speed</li>
</ul>
<p>Isochronous Transfers have no error detection. Any error in electrical transmission is not corrected.</p>
<p>Isochronous Transfers are also subject to timing jitters as described for <a class="el" href="#USB_Interrupt_Transfers">Interrupt Transfers</a>.</p>
<div class="image">
<img src="isochronousTransfer.png" alt=""/>
<div class="caption">
Isochronous Transfer Format</div></div>
    <h3><a class="anchor" id="USB_Bulk_Transfers"></a>
Bulk Transfers</h3>
<p><b>Bulk Transfers</b> are used for data which are not of the type Control, Interrupt, or Isochronous. Reliable exchange of data is ensured at the hardware level using error detection.</p>
<p>Data are transferred in the same manner as in <a class="el" href="#USB_Interrupt_Transfers">Interrupt Transfers</a>, but have no defined polling rate. Bulk Transfers take up all the bandwidth that is available after the other transfers have finished. If the bus is very busy, then a Bulk Transfer may be delayed.</p>
<p>The maximum packet size for the bulk endpoint data is:</p>
<ul>
<li>8, 16, 32 or 64 bytes for full-speed</li>
<li>512 bytes for high-speed</li>
</ul>
<p>For low-speed and full-speed endpoints the following is valid: If the bus is idle, multiple Bulk Transfers can take place in a single 1ms frame (Interrupt and Isochronous Transfers are limited to a maximum of one packet per frame).</p>
<p>For example, Bulk Transfers send data to a printer. As long as the data is printed in a reasonable time frame, the exact transfer rate is not important.</p>
<div class="image">
<img src="bulkTransfer.png" alt=""/>
<div class="caption">
Bulk Transfer Read and Writes</div></div>
    <h2><a class="anchor" id="USB_Endpoints"></a>
Endpoints</h2>
<p><b>Endpoints</b> can be described as data sources or sinks and exists in USB Devices only. The data stored at an endpoint may either be received from or waiting for being sent to the USB Host. An endpoint can be configured to support four <a class="el" href="#USB_Transfers">transfer types</a> defined in the USB specification (<a class="el" href="#USB_Control_Transfers">Control Transfers</a>, <a class="el" href="#USB_Interrupt_Transfers">Interrupt Transfers</a>, <a class="el" href="#USB_Isochronous_Transfers">Isochronous Transfers</a>, and <a class="el" href="#USB_Bulk_Transfers">Bulk Transfers</a>). Within the limits of the hardware, endpoints can be configured using the USB Middleware (e.g. limit an endpoint to a certain transfer type).</p>
<p>An endpoint acts as a kind of buffer. A USB Host's client may send data to Endpoint 1 for example. Coming from the USB Host, the data will be sent to the <b>OUT Endpoint 1</b>. The program on the microcontroller will then read the data as soon as it is ready to do so. Returning data has to be written to the <b>IN Endpoint 1</b>, as the program cannot access the USB bus freely (the USB bus being controlled by the USB Host). The data in IN Endpoint 1 stays there until the host sends an IN packet to Endpoint 1 requesting the data.</p>
<p>These rules apply to all microcontroller devices:</p>
<ul>
<li>A device can have up to <b>16 OUT</b> and <b>16 IN</b> endpoints.</li>
<li>Each endpoint can have only <b>one transfer direction</b>.</li>
<li><b>Endpoint 0</b> is used for control transfers only and can not be assigned to any other function.</li>
<li><b>OUT</b> always refers to the direction pointing from the host to the device.</li>
<li><b>IN</b> always refers to the direction pointing towards the host.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The total number of endpoints and the capability of each endpoint is defined by the underlying hardware. Please consult the hardware reference manual of your microcontroller.</dd></dl>
<h1><a class="anchor" id="USB_Protocol"></a>
USB Protocol</h1>
<p>USB is a polled bus, where the host initiates all data exchanges.</p>
<h2><a class="anchor" id="USB_Transactions"></a>
Transactions</h2>
<p>Data is transferred in so called <b>transactions</b>. Normally, they consist of three packets:</p><ol type="1">
<li>The <b>token packet</b> is the header defining the transaction type and direction, the device address, and the endpoint.</li>
<li>Data is transferred in a <b>data packet</b>.</li>
<li>The final status of the transaction is acknowledges in the <b>handshake packet</b>.</li>
</ol>
<div class="image">
<img src="pipemodel.png" alt=""/>
<div class="caption">
Pipe Model</div></div>
    <p>In a transaction, data is transferred either from the USB Host to an USB Device or vice-versa. The transfer direction is specified in the token packet that is sent from the USB Host. Then, the source sends a data packet or indicates it has no data to transfer. In general, the destination responds with a handshake packet indicating whether the transfer was successful.</p>
<div class="image">
<img src="packetmodel.png" alt=""/>
<div class="caption">
Packet Model</div></div>
    <h2><a class="anchor" id="USB_Packets"></a>
Packets</h2>
<p><b>Packets</b> could be thought of as the smallest element of data transmission. Each packet transmits an integral number of bytes at the current transmission rate. Packets start with a synchronization pattern, followed by the data bytes of the packet, and concluded with an End-of-Packet (EOP) signal. All USB packet patterns are transmitted <em>least significant bit first</em>. Before and after the packet, the bus is in <em>idle</em> state.</p>
<div class="image">
<img src="startofframe.png" alt=""/>
<div class="caption">
Start-of-Frame (SOF) Packet</div></div>
    <p>A special packet is the <b>Start-of-Frame</b> packet (SOF) that splits the USB bus into time segments. Each pipe is allocated a slot in each frame. The Start-of-Frame packet is sent every 1ms on full speed links. At high speed, the 1ms frame is divided into 8 microframes of 125&mu;s each. A Start-of-Frame packet is sent at the beginning of each microframe using the same frame number. The frame number increments every 1ms.</p>
<h1><a class="anchor" id="USB_Descriptors"></a>
USB Descriptors</h1>
<p>USB devices report their attributes using <b>descriptors</b>, which are data structures with a defined format. Each descriptor begins with a byte-wide field containing the total number of bytes in the descriptor followed by a byte-wide field identifying the descriptor type.</p>
<p>When an USB device is attached to the USB bus, the host uses a process known as <b>bus enumeration</b> to identify and configure the device. The USB Host sends setup requests as soon as the device has joined the USB network. The device will be instructed to select a configuration and an interface to match the needs of the application running on the USB Host. Once a configuration and an interface have been selected, the device must service the active endpoints to exchange data with the USB Host.</p>
<p>This is not a complete list of all the possible descriptors an USB host can request. The usual number of descriptors are:</p>
<ul>
<li>One <a class="el" href="#USB_Device_Descriptor">Device Descriptor</a></li>
<li>One <a class="el" href="#USB_Configuration_Descriptor">Configuration Descriptor</a></li>
<li>One <a class="el" href="#USB_Interface_Descriptor">Interface Descriptor</a></li>
<li>One or more <a class="el" href="#USB_Endpoint_Descriptor">Endpoint_Descriptors</a></li>
</ul>
<p><a class="el" href="#USB_String_Descriptor">String Descriptors</a> describe the above mentioned descriptors in human readable format.</p>
<div class="image">
<img src="deviceconfig.png" alt=""/>
<div class="caption">
Device Configuration</div></div>
    <p>Alternative information that is needed when the device can operate in different speed modes can be defined in a <a class="el" href="#USB_Device_Qualifier_Descriptor">Device Qualifier Descriptor</a>.</p>
<p>Complex devices have multiple interfaces. Each interface can have a number of endpoints representing a functional unit. For example, a voice-over-IP phone might have:</p>
<ul>
<li>One audio class interface with 2 isochronous endpoints for transferring audio data in each direction.</li>
<li>One HID interface with a single IN interrupt endpoint for a built-in keypad.</li>
</ul>
<p>Provisions have been made in the USB component to give the user the option to <a class="el" href="usbd_create_app.html#Overriding_Descriptors">override the USB descriptors</a> if necessary. This can be the case when the device class needs to be changed at run-time or other reports need to be created.</p>
<h2><a class="anchor" id="USB_Device_Descriptor"></a>
Device Descriptor</h2>
<p>The <b>Device Descriptor</b> (<a class="el" href="group__usbh__data__types.html#structUSB__DEVICE__DESCRIPTOR" title="USB Device Descriptor structure.">USB_DEVICE_DESCRIPTOR</a>) is the root of the descriptor tree and contains basic device information. The unique numbers, <em><b>idVendor</b></em> and <em><b>idProduct</b></em>, identify the connected device. The Windows operating system uses these numbers to determine which device driver must be loaded.</p>
<p><em><b>idVendor</b></em> is the number assigned to each company producing USB-based devices. The <a href="https://www.usb.org/">USB Implementers Forum</a> is responsible for administering the assignment of Vendor IDs.</p>
<p>The <em><b>idProduct</b></em> is another 16-bit field containing a number assigned by the manufacturer to identify a specific product.</p>
<table class="cmtable" summary="Device Descriptor">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>Device Descriptor Type = 1.  </td></tr>
<tr>
<td>2 </td><td>bcdUSB </td><td>uint16_t </td><td>2 </td><td>BCD </td><td><p class="starttd">USB Specification Release Number in Binary-Coded Decimal (i.e., 2.10 is 210h).</p>
<p class="endtd">This field identifies the release of the USB Specification with which the device and its descriptors are compliant.  </p>
</td></tr>
<tr>
<td>4 </td><td>bDeviceClass </td><td>uint8_t </td><td>1 </td><td>Class </td><td><p class="starttd">Class code (assigned by the USB-IF).</p>
<p class="endtd">If this field is</p><ul>
<li>reset to zero, each interface within a configuration specifies its own class information and the various interfaces operate independently.</li>
<li>set to a value between 1 and FEh, the device supports different class specifications on different interfaces and the interfaces may not operate independently. This value identifies the class definition used for the aggregate interfaces.</li>
<li>set to FFh, the device class is vendor specific.</li>
</ul>
</td></tr>
<tr>
<td>5 </td><td>bDeviceSubClass </td><td>uint8_t </td><td>1 </td><td>SubClass </td><td><p class="starttd">Subclass code (assigned by the USB-IF).</p>
<p class="intertd">These codes are qualified by the value of the <em>bDeviceClass</em> field.</p>
<p class="endtd">If <em>bDeviceClass</em> is</p><ul>
<li>reset to zero, this field must also be reset to zero.</li>
<li>not set to FFh, all values are reserved for assignment by the USB-IF.</li>
</ul>
</td></tr>
<tr>
<td>6 </td><td>bDeviceProtocol </td><td>uint8_t </td><td>1 </td><td>Protocol </td><td><p class="starttd">Protocol code (assigned by the USB-IF).</p>
<p class="intertd">These codes are qualified by the value of the <em>bDeviceClass</em> and <em>bDeviceSubClass</em> fields. If a device supports class-specific protocols on a device basis as opposed to an interface basis, this code identifies the protocols that the device uses as defined by the specification of the device class.</p>
<p class="endtd">If this field is</p><ul>
<li>reset to zero, the device does not use class specific protocols on a device basis. However, it may use class specific protocols on an interface basis.</li>
<li>set to FFh, the device uses a vendor specific protocol on a device basis.</li>
</ul>
</td></tr>
<tr>
<td>7 </td><td>bMaxPacketSize0 </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Maximum packet size for Endpoint zero (only 8, 16, 32, or 64 are valid).  </td></tr>
<tr>
<td>8 </td><td>idVendor </td><td>uint16_t </td><td>2 </td><td>ID </td><td>Vendor ID (assigned by the USB-IF).  </td></tr>
<tr>
<td>10 </td><td>idProduct </td><td>uint16_t </td><td>2 </td><td>ID </td><td>Product ID (assigned by the manufacturer).  </td></tr>
<tr>
<td>12 </td><td>bcdDevice </td><td>uint16_t </td><td>2 </td><td>BCD </td><td>Device release number in binary-coded decimal.  </td></tr>
<tr>
<td>14 </td><td>iManufacturer </td><td>uint8_t </td><td>1 </td><td>Index </td><td>Index of string descriptor describing manufacturer.  </td></tr>
<tr>
<td>15 </td><td>iProduct </td><td>uint8_t </td><td>1 </td><td>Index </td><td>Index of string descriptor describing product.  </td></tr>
<tr>
<td>16 </td><td>iSerialNumber </td><td>uint8_t </td><td>1 </td><td>Index </td><td>Index of string descriptor describing the device's serial number.  </td></tr>
<tr>
<td>17 </td><td>bNumConfigurations </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Number of possible configurations.  </td></tr>
</table>
<h2><a class="anchor" id="USB_Configuration_Descriptor"></a>
Configuration Descriptor</h2>
<p>The <b>Configuration Descriptor</b> (<a class="el" href="group__usbh__data__types.html#structUSB__CONFIGURATION__DESCRIPTOR" title="USB Configuration Descriptor structure.">USB_CONFIGURATION_DESCRIPTOR</a>) contains information about the device power requirements and the number of interfaces it can support. A device can have multiple configurations. The host can select the configuration that best matches the requirements of the application software.</p>
<table class="cmtable" summary="Configuration Descriptor">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>Configuration Descriptor Type = 2.  </td></tr>
<tr>
<td>2 </td><td>wTotalLength </td><td>uint16_t </td><td>2 </td><td>Number </td><td>Total length of data returned for this configuration. Includes the combined length of all descriptors (configuration, interface, endpoint, and class or vendor specific) returned for this configuration.  </td></tr>
<tr>
<td>4 </td><td>bNumInterfaces </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Number of interfaces supported by this configuration.  </td></tr>
<tr>
<td>5 </td><td>bConfigurationValue </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Value to select this configuration with <em>SetConfiguration()</em>.  </td></tr>
<tr>
<td>6 </td><td>iConfiguration </td><td>uint8_t </td><td>1 </td><td>Index </td><td>Index of string descriptor describing this configuration.  </td></tr>
<tr>
<td>7 </td><td>bmAttributes </td><td>uint8_t </td><td>1 </td><td>Bitmap </td><td><p class="starttd">Configuration characteristics</p><ul>
<li>D7: Reserved (must be set to <b>one</b> for historical reasons)</li>
<li>D6: Self-powered</li>
<li>D5: Remote Wakeup</li>
<li>D4...0: Reserved (reset to zero)</li>
</ul>
<p class="endtd">A device configuration that uses power from the bus and a local source reports a non-zero value in <em>bMaxPower</em> to indicate the amount of bus power required and sets D6. The actual power source at run-time can be determined using the GetStatus(DEVICE) request. If a device configuration supports remote wakeup, D5 is set to 1.  </p>
</td></tr>
<tr>
<td>8 </td><td>bMaxPower </td><td>uint8_t </td><td>1 </td><td>mA </td><td>Maximum power consumption of the USB device from the bus in this specific configuration when the device is fully operational. Expressed in 2mA units (i.e., 50 = 100mA).  </td></tr>
</table>
<h2><a class="anchor" id="USB_Interface_Descriptor"></a>
Interface Descriptor</h2>
<p>The <b>Interface Descriptor</b> (USB_INTERFACE_DESCRIPTOR) defines the collection of endpoints. This interface supports a group of pipes that are suitable for a particular task. Each configuration can have multiple interfaces. The interface can be selected dynamically by the USB Host. The <b>Interface Descriptor</b> can associate its collection of pipes with a device class, which in turn has an associated class device driver within the host operating system. Typically, the device class is a functional type such as a printer class or mass storage class.</p>
<p>An interface descriptor never includes Endpoint 0 in the numbering of endpoints. If an interface uses only Endpoint 0, then the field <em>bNumEndpoints</em> must be set to zero.</p>
<p>If no class type has been selected for the device, then none of the standard USB drivers is loaded, and the developer has to provide its own device driver.</p>
<table class="cmtable" summary="Interface Descriptor">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>Interface Descriptor Type = 4.  </td></tr>
<tr>
<td>2 </td><td>bInterfaceNumber </td><td>uint8_t </td><td>1 </td><td>Number </td><td><p class="starttd">The number of this interface.</p>
<p class="endtd">Zero-based value identifying the index in the array of concurrent interfaces supported by this configuration.  </p>
</td></tr>
<tr>
<td>3 </td><td>bAlternateSetting </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Value used to select an alternate setting for the interface identified in the prior field. Allows an interface to change the settings on the fly.  </td></tr>
<tr>
<td>4 </td><td>bNumEndpoints </td><td>uint8_t </td><td>1 </td><td>Number </td><td><p class="starttd">Number of endpoints used by this interface (excluding endpoint zero).</p>
<ul>
<li>If this value is zero, this interface uses the Default Control Pipe only.</li>
</ul>
</td></tr>
<tr>
<td>5 </td><td>bInterfaceClass </td><td>uint8_t </td><td>1 </td><td>Class </td><td><p class="starttd">Class code (assigned by the USB-IF).</p>
<ul>
<li>A value of zero is reserved for future standardization.</li>
<li>If this field is set to FFh, the interface class is vendor specific.</li>
<li>All other values are reserved for assignment by the USB-IF.</li>
</ul>
</td></tr>
<tr>
<td>6 </td><td>bInterfaceSubClass </td><td>uint8_t </td><td>1 </td><td>SubClass </td><td><p class="starttd">Subclass code (assigned by the USB-IF).</p>
<p class="endtd">If <em>bInterfaceClass</em></p><ul>
<li>is reset to zero, this field must also be reset to zero.</li>
<li>is not set to FFh, all values are reserved for assignment by the USB-IF.</li>
</ul>
</td></tr>
<tr>
<td>7 </td><td>bInterfaceProtocol </td><td>uint8_t </td><td>1 </td><td>Protocol </td><td><p class="starttd">Protocol code (assigned by the USB).</p>
<p class="endtd">If an interface supports class-specific requests, this code identifies the protocols that the device uses as defined in the device class.<br  />
 If this field</p><ul>
<li>is reset to zero, the device does not use a class-specific protocol on this interface.</li>
<li>is set to FFh, the device uses a vendor specific protocol for this interface.</li>
</ul>
</td></tr>
<tr>
<td>8 </td><td>iInterface </td><td>uint8_t </td><td>1 </td><td>Index </td><td>Index of string descriptor describing this interface.  </td></tr>
</table>
<p>For example, two devices with different interfaces are needed.</p>
<p>The first interface, <em>Interface0</em>, has the field <em>bInterfaceNumber</em> set to 0. The next interface, <em>Interface1</em>, has the field <em>bInterfaceNumber</em> set to 1 and the field <em>bAlternativeSetting</em> also set to 0 (default). It is possible to define an alternative setting for this device, by leaving the field <em>bInterfaceNumber</em> set to 1 and with the field <em>bAlternativeSetting</em> set to 1 instead of 0.</p>
<p>The first two interface descriptors with <em>bAlternativeSettings</em> equal to 0 are used. However, the host can send a <em>SetInterface()</em> request to enable the alternative setting.</p>
<div class="image">
<img src="alt_interface.png" alt=""/>
<div class="caption">
Alternative Interface</div></div>
    <h2><a class="anchor" id="USB_Endpoint_Descriptor"></a>
Endpoint Descriptor</h2>
<p>The <b>Endpoint Descriptor</b> (USB_ENDPOINT_DESCRIPTOR) specifies the transfer type, direction, polling interval, and maximum packet size for each endpoint. Endpoint 0 (zero), the default endpoint, is always assumed to be a control endpoint and never has a descriptor.</p>
<table class="cmtable" summary="Endpoint Descriptor">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>Endpoint Descriptor Type = 5.  </td></tr>
<tr>
<td>2 </td><td>bEndpointAddress </td><td>uint8_t </td><td>1 </td><td>Endpoint </td><td>The address of the endpoint on the USB device described by this descriptor. The address is encoded as follows:<ul>
<li>Bit 3...0: The endpoint number</li>
<li>Bit 6...4: Reserved, reset to zero</li>
<li>Bit 7: Direction, ignored for control endpoints.<ul>
<li>0 = OUT endpoint</li>
<li>1 = IN endpoint</li>
</ul>
</li>
</ul>
</td></tr>
<tr>
<td>3 </td><td>bmAttributes </td><td>uint8_t </td><td>1 </td><td>Bitmap </td><td><p class="starttd">The endpoint attribute when configured through <em>bConfigurationValue</em>.</p><ul>
<li>Bits 1..0: Transfer Type<ul>
<li>00 = Control</li>
<li>01 = Isochronous</li>
<li>10 = Bulk</li>
<li>11 = Interrupt</li>
</ul>
</li>
</ul>
<p class="intertd">For non-isochronous endpoints, bits 5..2 must be set to zero. For isochronous endpoints, they are defined as:</p><ul>
<li>Bits 3..2: Synchronization Type<ul>
<li>00 = No Synchronization</li>
<li>01 = Asynchronous</li>
<li>10 = Adaptive</li>
<li>11 = Synchronous</li>
</ul>
</li>
<li>Bits 5..4: Usage Type<ul>
<li>00 = Data</li>
<li>01 = Feedback</li>
<li>10 = Implicit feedback</li>
<li>11 = Reserved</li>
</ul>
</li>
</ul>
<p class="endtd">All other bits are reserved and must be reset to zero.  </p>
</td></tr>
<tr>
<td>4 </td><td>wMaxPacketSize </td><td>uint16_t </td><td>2 </td><td>Number </td><td><p class="starttd">Is the maximum packet size of this endpoint. For isochronous endpoints, this value is used to reserve the time on the bus, required for the per-(micro)frame data payloads.</p>
<ul>
<li>Bits 10..0 = max. packet size (in bytes).</li>
</ul>
<p class="endtd">For high-speed isochronous and interrupt endpoints:</p><ul>
<li>Bits 12..11 = number of additional transaction opportunities per micro-frame:<ul>
<li>00 = None (1 transaction per micro-frame)</li>
<li>01 = 1 additional (2 per micro-frame)</li>
<li>10 = 2 additional (3 per micro-frame)</li>
<li>11 = Reserved</li>
</ul>
</li>
<li>Bits 15..13 are reserved and must be set to zero.</li>
</ul>
</td></tr>
<tr>
<td>6 </td><td>bInterval </td><td>uint8_t </td><td>1 </td><td>Number </td><td><p class="starttd">Interval for polling endpoint for data transfers. Expressed in frames or micro-frames depending on the operating speed (1ms, or 125&mu;s units).</p>
<ul>
<li>For full-/high-speed isochronous endpoints, this value must be in the range from 1 to 16. The bInterval value is used as the exponent for a 2<sup>bInterval-1</sup> value; For example, a <em>bInterval</em> of 4 means a period of 8 (2<sup>4-1</sup>).</li>
<li>For full-/low-speed interrupt endpoints, the value of this field may be from 1 to 255.</li>
<li>For high-speed interrupt endpoints, the <em>bInterval</em> value is used as the exponent for a 2<sup>bInterval-1</sup> value; For Example, a <em>bInterval</em> of 4 means a period of 8 (2<sup>4-1</sup>). This value must be from 1 to 16.</li>
<li>For high-speed bulk/control OUT endpoints, the <em>bInterval</em> must specify the maximum NAK rate of the endpoint. A value of 0 indicates the endpoint never NAKs. Other values indicate at most 1 NAK each <em>bInterval</em> number of microframes. This value must be in the range from 0 to 255. </li>
</ul>
</td></tr>
</table>
<h2><a class="anchor" id="USB_Device_Qualifier_Descriptor"></a>
Device Qualifier Descriptor</h2>
<p>A high-speed capable device that has different device information for full-speed and high-speed must have a <b>Device Qualifier Descriptor</b> (USB_DEVICE_QUALIFIER_DESCRIPTOR). For example, if the device is currently operating at full-speed, the <b>Device Qualifier</b> returns information about how it would operate at high-speed and vice-versa.</p>
<p>The fields for the vendor, product, device, manufacturer, and serial number are not included. This information is constant for a device regardless of the supported speeds.</p>
<p>If a full-speed only device receives a <em>GetDescriptor()</em> request for a <em>device_qualifier</em>, it must respond with a request error. Then, the host must not make a request for an <em>other_speed_configuration descriptor</em>.</p>
<table class="cmtable" summary="Device Qualifier Descriptor">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>Device Qualifier Descriptor Type = 6.  </td></tr>
<tr>
<td>2 </td><td>bcdUSB </td><td>uint16_t </td><td>2 </td><td>BCD </td><td>USB Specification Release Number in Binary-Coded Decimal (i.e., 2.10 is 210h). This field identifies the release of the USB Specification with which the device and its descriptors are compliant. At least V2.00 is required to use this descriptor.  </td></tr>
<tr>
<td>4 </td><td>bDeviceClass </td><td>uint8_t </td><td>1 </td><td>Class </td><td><p class="starttd">Class code (assigned by the USB-IF).</p>
<p class="intertd">If this field is</p><ul>
<li>reset to zero, each interface within a configuration specifies its own class information and the various interfaces operate independently.</li>
<li>set to a value between 1 and FEh, the device supports different class specifications on different interfaces and the interfaces may not operate independently. This value identifies the class definition used for the aggregate interfaces.</li>
</ul>
<p class="endtd">If this field is set to FFh, the device class is vendor specific.  </p>
</td></tr>
<tr>
<td>5 </td><td>bDeviceSubClass </td><td>uint8_t </td><td>1 </td><td>SubClass </td><td><p class="starttd">Subclass code (assigned by the USB-IF).</p>
<p class="endtd">These codes are qualified by the value of the <em>bDeviceClass</em> field. If <em>bDeviceClass</em> is</p><ul>
<li>reset to zero, this field must also be reset to zero.</li>
<li>not set to FFh, all values are reserved for assignment by the USB-IF.</li>
</ul>
</td></tr>
<tr>
<td>6 </td><td>bDeviceProtocol </td><td>uint8_t </td><td>1 </td><td>Protocol </td><td><p class="starttd">Protocol code (assigned by the USB-IF). These codes are qualified by the values of the <em>bDeviceClass</em> and <em>bDeviceSubClass</em> fields. If a device supports class-specific protocols on a device basis as opposed to an interface basis, this code identifies the protocols that the device uses as defined by the specification of the device class.</p>
<p class="endtd">If this field is</p><ul>
<li>reset to zero, the device does not use class-specific protocols on a device basis. However, it may use class-specific protocols on an interface basis.</li>
<li>set to FFh, the device uses a vendor specific protocol on a device basis.</li>
</ul>
</td></tr>
<tr>
<td>7 </td><td>bMaxPacketSize0 </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Maximum packet size for other speed.  </td></tr>
<tr>
<td>8 </td><td>bNumConfigurations </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Number of other-speed configurations.  </td></tr>
<tr>
<td>9 </td><td>bReserved </td><td>uint8_t </td><td>1 </td><td>Zero </td><td>Reserved for future use, must be zero.  </td></tr>
</table>
<h2><a class="anchor" id="USB_String_Descriptor"></a>
String Descriptors</h2>
<p><b>String descriptors</b> (USB_STRING_DESCRIPTOR) are optional and add human readable information to the other descriptors. If a device does not support string descriptors, all references to string descriptors within device, configuration, and interface descriptors must be set to zero.</p>
<p>String descriptors are encoded in <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> so that multiple languages can be supported with a single product. When requesting a string descriptor, the requester specifies the desired language using a 16-bit language ID (LANGID) defined by the USB-IF. String index zero is used for all languages and returns a string descriptor that contains an array of two-byte LANGID codes supported by the device.</p>
<p>The array of LANGID codes is not NULL-terminated. The size of the array (in byte) is computed by subtracting two from the value of the first byte to the descriptor.</p>
<table class="cmtable" summary="String Descriptor Zero">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>N + 2 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>String Descriptor Type  </td></tr>
<tr>
<td>2 </td><td>wLANGID[0] </td><td>uint8_t </td><td>2 </td><td>Number </td><td>LANGID code zero (for example 0x0407 German (Standard)).  </td></tr>
<tr>
<td>... </td><td>... </td><td>... </td><td>... </td><td>... </td><td>...  </td></tr>
<tr>
<td>N </td><td>wLANGID[x] </td><td>uint8_t </td><td>2 </td><td>Number </td><td>LANGID code zero x (for example 0x0409 English (United States)).  </td></tr>
</table>
<p>The UNICODE string descriptor is not NULL-terminated. The string length is computed by subtracting two from the value of the first byte of the descriptor.</p>
<table class="cmtable" summary="String Descriptor Zero">
<tr>
<th>Offset </th><th>Field </th><th>Type </th><th>Size </th><th>Value </th><th>Description  </th></tr>
<tr>
<td>0 </td><td>bLength </td><td>uint8_t </td><td>1 </td><td>Number </td><td>Size of this descriptor in bytes.  </td></tr>
<tr>
<td>1 </td><td>bDescriptorType </td><td>uint8_t </td><td>1 </td><td>Constant </td><td>String Descriptor Type  </td></tr>
<tr>
<td>2 </td><td>bString </td><td>uint8_t </td><td>N </td><td>Number </td><td>UNICODE encoded string.  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
