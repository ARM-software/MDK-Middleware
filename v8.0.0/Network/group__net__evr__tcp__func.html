<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Network Component: NetTCP: TCP Socket</title>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tabs.js"></script>
<script type="text/javascript" src="footer.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="URL_keys.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<link href="extra_tabs.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="armkeil_white_h.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">Network Component
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown.call(this, "Network Component");
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">MDK Middleware for IPv4 and IPv6 Networking</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
  <ul class="tablist">
    <script type="text/javascript">
      writeComponentTabs.call(this);
    </script>
  </ul>
</div>
<script type="text/javascript">
  writeSubComponentTabs.call(this);
</script>
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__net__evr__tcp__func.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">NetTCP: TCP Socket<div class="ingroups"><a class="el" href="group__net__evr.html">Debug Events</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Events generated by the Network - TCP Socket functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga783511f4efa2adbc3a5fbf40ea13b4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga783511f4efa2adbc3a5fbf40ea13b4d8">EvrNetTCP_InitSockets</a> (uint32_t num_sockets, uint16_t max_segsize)</td></tr>
<tr class="memdesc:ga783511f4efa2adbc3a5fbf40ea13b4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP socket initialize (Op)  <br /></td></tr>
<tr class="separator:ga783511f4efa2adbc3a5fbf40ea13b4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee597d82d09b36096ffb2c548ca6405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga3ee597d82d09b36096ffb2c548ca6405">EvrNetTCP_GetSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t num_socks)</td></tr>
<tr class="memdesc:ga3ee597d82d09b36096ffb2c548ca6405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP allocate a free socket (Op)  <br /></td></tr>
<tr class="separator:ga3ee597d82d09b36096ffb2c548ca6405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb20b14be980ef029de246c7c4ee5d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gabb20b14be980ef029de246c7c4ee5d0c">EvrNetTCP_GetSocketInvalidParameter</a> (void)</td></tr>
<tr class="memdesc:gabb20b14be980ef029de246c7c4ee5d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP get socket failed, invalid parameter (Error)  <br /></td></tr>
<tr class="separator:gabb20b14be980ef029de246c7c4ee5d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b46b4a2e8a72ef1e0b30b401b3fa3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac4b46b4a2e8a72ef1e0b30b401b3fa3b">EvrNetTCP_NoSocketAvailable</a> (uint32_t num_socks)</td></tr>
<tr class="memdesc:gac4b46b4a2e8a72ef1e0b30b401b3fa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP get socket failed, no free socket available (Error)  <br /></td></tr>
<tr class="separator:gac4b46b4a2e8a72ef1e0b30b401b3fa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4950e24a7e460e6c99a742d495460703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4950e24a7e460e6c99a742d495460703">EvrNetTCP_ReleaseSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga4950e24a7e460e6c99a742d495460703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP release socket (Op)  <br /></td></tr>
<tr class="separator:ga4950e24a7e460e6c99a742d495460703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eaa1a76c4d644ff5b04414378e789e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga0eaa1a76c4d644ff5b04414378e789e1">EvrNetTCP_ReleaseSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga0eaa1a76c4d644ff5b04414378e789e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP release failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga0eaa1a76c4d644ff5b04414378e789e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga243ed0529ebc3a56b6007d3028577955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga243ed0529ebc3a56b6007d3028577955">EvrNetTCP_ReleaseSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga243ed0529ebc3a56b6007d3028577955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP release failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:ga243ed0529ebc3a56b6007d3028577955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d60bb0ce4651304d10c6ddf47082b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga8d60bb0ce4651304d10c6ddf47082b25">EvrNetTCP_ListenSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t port)</td></tr>
<tr class="memdesc:ga8d60bb0ce4651304d10c6ddf47082b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP listen socket request (Op)  <br /></td></tr>
<tr class="separator:ga8d60bb0ce4651304d10c6ddf47082b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558df663217df72693592eba4c46171f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga558df663217df72693592eba4c46171f">EvrNetTCP_ListenSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga558df663217df72693592eba4c46171f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP listen failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga558df663217df72693592eba4c46171f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b74afb4717fb3c27c4723265fa415fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga9b74afb4717fb3c27c4723265fa415fd">EvrNetTCP_ListenPortUndefined</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga9b74afb4717fb3c27c4723265fa415fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP listen failed, listening port undefined (Error)  <br /></td></tr>
<tr class="separator:ga9b74afb4717fb3c27c4723265fa415fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd8a3f2e654b4f3c0b34db236b73879"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4dd8a3f2e654b4f3c0b34db236b73879">EvrNetTCP_ListenSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga4dd8a3f2e654b4f3c0b34db236b73879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP listen failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:ga4dd8a3f2e654b4f3c0b34db236b73879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2079445e2640aca678e7b5756a16510"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae2079445e2640aca678e7b5756a16510">EvrNetTCP_ConnectSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t local_port)</td></tr>
<tr class="memdesc:gae2079445e2640aca678e7b5756a16510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect socket request (Op)  <br /></td></tr>
<tr class="separator:gae2079445e2640aca678e7b5756a16510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b62fd65c3366aacc01c282eec066204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga2b62fd65c3366aacc01c282eec066204">EvrNetTCP_ConnectSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga2b62fd65c3366aacc01c282eec066204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga2b62fd65c3366aacc01c282eec066204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a4a4d4a2b207f715b8a2c1e3c3f455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga35a4a4d4a2b207f715b8a2c1e3c3f455">EvrNetTCP_ConnectAddressUnspecified</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga35a4a4d4a2b207f715b8a2c1e3c3f455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect failed, address unspecified (Error)  <br /></td></tr>
<tr class="separator:ga35a4a4d4a2b207f715b8a2c1e3c3f455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47821d7e7012b2b4baebd5bb97580682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga47821d7e7012b2b4baebd5bb97580682">EvrNetTCP_ConnectPortUndefined</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga47821d7e7012b2b4baebd5bb97580682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect failed, port undefined (Error)  <br /></td></tr>
<tr class="separator:ga47821d7e7012b2b4baebd5bb97580682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf45da68d3e7aefcdbe2f28ee6e43b6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaf45da68d3e7aefcdbe2f28ee6e43b6cc">EvrNetTCP_ShowNetAddress</a> (const void *net_addr)</td></tr>
<tr class="memdesc:gaf45da68d3e7aefcdbe2f28ee6e43b6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display net address (Op)  <br /></td></tr>
<tr class="separator:gaf45da68d3e7aefcdbe2f28ee6e43b6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb8843a7601f06b0d11dc4a0be2f9ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4eb8843a7601f06b0d11dc4a0be2f9ff">EvrNetTCP_ConnectLocalPortInvalid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t local_port)</td></tr>
<tr class="memdesc:ga4eb8843a7601f06b0d11dc4a0be2f9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect failed, local port invalid (Error)  <br /></td></tr>
<tr class="separator:ga4eb8843a7601f06b0d11dc4a0be2f9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb86a7dddfbbac6b28da0f43b9c20872"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gadb86a7dddfbbac6b28da0f43b9c20872">EvrNetTCP_AssignLocalPort</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t local_port)</td></tr>
<tr class="memdesc:gadb86a7dddfbbac6b28da0f43b9c20872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP local port assigned in socket connect request (Op)  <br /></td></tr>
<tr class="separator:gadb86a7dddfbbac6b28da0f43b9c20872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93176daeb1710d024f0e83c6ee586d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga93176daeb1710d024f0e83c6ee586d12">EvrNetTCP_ConnectSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga93176daeb1710d024f0e83c6ee586d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP connect failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:ga93176daeb1710d024f0e83c6ee586d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d20729d13eceb06fc331b3f02ef8d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaf5d20729d13eceb06fc331b3f02ef8d4">EvrNetTCP_ShowRttVariables</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int16_t sa, int16_t sv)</td></tr>
<tr class="memdesc:gaf5d20729d13eceb06fc331b3f02ef8d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display RTT (round trip time) estimation variables (Detail)  <br /></td></tr>
<tr class="separator:gaf5d20729d13eceb06fc331b3f02ef8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9420dfe55e28577157932864a3a37632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga9420dfe55e28577157932864a3a37632">EvrNetTCP_GetBufferFailed</a> (uint16_t mem_size)</td></tr>
<tr class="memdesc:ga9420dfe55e28577157932864a3a37632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP get buffer failed, out of memory (Error)  <br /></td></tr>
<tr class="separator:ga9420dfe55e28577157932864a3a37632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad135ca1b002f8a1b7546e1b6338b554a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad135ca1b002f8a1b7546e1b6338b554a">EvrNetTCP_SendFrame</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t length)</td></tr>
<tr class="memdesc:gad135ca1b002f8a1b7546e1b6338b554a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send frame (Op)  <br /></td></tr>
<tr class="separator:gad135ca1b002f8a1b7546e1b6338b554a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457e530d907d711dd08745e591478c54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga457e530d907d711dd08745e591478c54">EvrNetTCP_SendBufferInvalid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga457e530d907d711dd08745e591478c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, invalid buffer (Error)  <br /></td></tr>
<tr class="separator:ga457e530d907d711dd08745e591478c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d8a2d62b8efe1975126cd2fadf6506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga84d8a2d62b8efe1975126cd2fadf6506">EvrNetTCP_SendSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga84d8a2d62b8efe1975126cd2fadf6506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, socket handle not valid (Error)  <br /></td></tr>
<tr class="separator:ga84d8a2d62b8efe1975126cd2fadf6506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa0eb4a3daac242ac86ea2b723281ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gabaa0eb4a3daac242ac86ea2b723281ef">EvrNetTCP_SendSocketNotConnected</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gabaa0eb4a3daac242ac86ea2b723281ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, socket not connected (Error)  <br /></td></tr>
<tr class="separator:gabaa0eb4a3daac242ac86ea2b723281ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3a43fa79b486e32e466e1878c3861f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4c3a43fa79b486e32e466e1878c3861f">EvrNetTCP_SendSocketClosing</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga4c3a43fa79b486e32e466e1878c3861f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, socket closing (Error)  <br /></td></tr>
<tr class="separator:ga4c3a43fa79b486e32e466e1878c3861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96f40823aed258059e7f380c86b423e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga96f40823aed258059e7f380c86b423e8">EvrNetTCP_SendReenteredCall</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga96f40823aed258059e7f380c86b423e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, called from a callback function (Error)  <br /></td></tr>
<tr class="separator:ga96f40823aed258059e7f380c86b423e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b21676e68abaf97d8970f9f6b5562d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae7b21676e68abaf97d8970f9f6b5562d">EvrNetTCP_SendDataUnacked</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gae7b21676e68abaf97d8970f9f6b5562d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, unacked data pending (Error)  <br /></td></tr>
<tr class="separator:gae7b21676e68abaf97d8970f9f6b5562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123a83e759a8a9d32dfaa351218738d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga123a83e759a8a9d32dfaa351218738d8">EvrNetTCP_SendMssExceeded</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga123a83e759a8a9d32dfaa351218738d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send failed, Maximum Segment Size exceeded (Error)  <br /></td></tr>
<tr class="separator:ga123a83e759a8a9d32dfaa351218738d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cceb4554b1e724e1dca5d2561520d43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga9cceb4554b1e724e1dca5d2561520d43">EvrNetTCP_SendZeroLengthFrame</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga9cceb4554b1e724e1dca5d2561520d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send 0-length frame, frame dumped (Op)  <br /></td></tr>
<tr class="separator:ga9cceb4554b1e724e1dca5d2561520d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44537256d395c7bfb4102d730067df9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga44537256d395c7bfb4102d730067df9b">EvrNetTCP_CloseSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga44537256d395c7bfb4102d730067df9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP close socket (Op)  <br /></td></tr>
<tr class="separator:ga44537256d395c7bfb4102d730067df9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658c15ba5fea6044d21aca02c1530126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga658c15ba5fea6044d21aca02c1530126">EvrNetTCP_CloseSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga658c15ba5fea6044d21aca02c1530126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP close socket failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga658c15ba5fea6044d21aca02c1530126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2068e56d1fb57d556cb30dbc58249d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4d2068e56d1fb57d556cb30dbc58249d">EvrNetTCP_CloseDataUnacked</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t unack_length)</td></tr>
<tr class="memdesc:ga4d2068e56d1fb57d556cb30dbc58249d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP close pended, unacked data exist (Op)  <br /></td></tr>
<tr class="separator:ga4d2068e56d1fb57d556cb30dbc58249d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4223945740b58e1382ac3cc41edfbaa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4223945740b58e1382ac3cc41edfbaa3">EvrNetTCP_CloseSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga4223945740b58e1382ac3cc41edfbaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP close failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:ga4223945740b58e1382ac3cc41edfbaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga312a5678b5ae1d036d809fac65c34ee9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga312a5678b5ae1d036d809fac65c34ee9">EvrNetTCP_AbortSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga312a5678b5ae1d036d809fac65c34ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP abort socket (Op)  <br /></td></tr>
<tr class="separator:ga312a5678b5ae1d036d809fac65c34ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0f5ed4d43717728bb096dc7810e4f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5f0f5ed4d43717728bb096dc7810e4f8">EvrNetTCP_AbortSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga5f0f5ed4d43717728bb096dc7810e4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP abort failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga5f0f5ed4d43717728bb096dc7810e4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga170c2dc402cb2265c905c4a127335c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga170c2dc402cb2265c905c4a127335c7a">EvrNetTCP_AbortSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga170c2dc402cb2265c905c4a127335c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP abort failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:ga170c2dc402cb2265c905c4a127335c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f0db538ca6777b7ef9d76a288cf7a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga93f0db538ca6777b7ef9d76a288cf7a8">EvrNetTCP_SendReadySocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga93f0db538ca6777b7ef9d76a288cf7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send ready failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga93f0db538ca6777b7ef9d76a288cf7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f03feef835e0694374d94a5e687c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad7f03feef835e0694374d94a5e687c46">EvrNetTCP_SendReadyReenteredCall</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gad7f03feef835e0694374d94a5e687c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send ready failed, called from a callback function (Error)  <br /></td></tr>
<tr class="separator:gad7f03feef835e0694374d94a5e687c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71d12870266f7dbebf936a9ccbe2b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gab71d12870266f7dbebf936a9ccbe2b6c">EvrNetTCP_ResetWindowSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gab71d12870266f7dbebf936a9ccbe2b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP reset window failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:gab71d12870266f7dbebf936a9ccbe2b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f15f12246d3283f2dcc3040cbba2a08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga7f15f12246d3283f2dcc3040cbba2a08">EvrNetTCP_ResetWindowNotConnected</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga7f15f12246d3283f2dcc3040cbba2a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP reset window failed, invalid socket state (Error)  <br /></td></tr>
<tr class="separator:ga7f15f12246d3283f2dcc3040cbba2a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2adad45a2417f72055dc94f3b169d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaea2adad45a2417f72055dc94f3b169d1">EvrNetTCP_ResetWindowNoFlowControl</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gaea2adad45a2417f72055dc94f3b169d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP reset window failed, flow-control not enabled (Error)  <br /></td></tr>
<tr class="separator:gaea2adad45a2417f72055dc94f3b169d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a44caeefb9a272c1fe49bca823e7043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5a44caeefb9a272c1fe49bca823e7043">EvrNetTCP_ResetWindowUpdate</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t window_size)</td></tr>
<tr class="memdesc:ga5a44caeefb9a272c1fe49bca823e7043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP reset window update (Error)  <br /></td></tr>
<tr class="separator:ga5a44caeefb9a272c1fe49bca823e7043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753b2d11bb803db1a9bf4f27b3d457d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga753b2d11bb803db1a9bf4f27b3d457d5">EvrNetTCP_SetOptionSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t option, uint32_t val)</td></tr>
<tr class="memdesc:ga753b2d11bb803db1a9bf4f27b3d457d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option (Op)  <br /></td></tr>
<tr class="separator:ga753b2d11bb803db1a9bf4f27b3d457d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d73b5d799778015fa330500bd5bdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga80d73b5d799778015fa330500bd5bdcd">EvrNetTCP_SetOptionSocketNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga80d73b5d799778015fa330500bd5bdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option failed, not valid socket (Error)  <br /></td></tr>
<tr class="separator:ga80d73b5d799778015fa330500bd5bdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbe697016f06fd021ab10d21e6b8e4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gabbe697016f06fd021ab10d21e6b8e4c4">EvrNetTCP_SetOptionSocketWrongState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:gabbe697016f06fd021ab10d21e6b8e4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option failed, wrong socket state (Error)  <br /></td></tr>
<tr class="separator:gabbe697016f06fd021ab10d21e6b8e4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8f0bf59cf521e3bc07ee540b57e3c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaec8f0bf59cf521e3bc07ee540b57e3c1">EvrNetTCP_SetOptionTos</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint8_t ip4_tos)</td></tr>
<tr class="memdesc:gaec8f0bf59cf521e3bc07ee540b57e3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option Type Of Service for IPv4 (Detail)  <br /></td></tr>
<tr class="separator:gaec8f0bf59cf521e3bc07ee540b57e3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9960e0b3c5e88954e55efc03fb18960d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga9960e0b3c5e88954e55efc03fb18960d">EvrNetTCP_SetOptionTclass</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint8_t ip6_tclass)</td></tr>
<tr class="memdesc:ga9960e0b3c5e88954e55efc03fb18960d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option Traffic Class for IPv6 (Detail)  <br /></td></tr>
<tr class="separator:ga9960e0b3c5e88954e55efc03fb18960d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5db93183863758c46ab59ce0c2f3aa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5db93183863758c46ab59ce0c2f3aa24">EvrNetTCP_SetOptionTimeout</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t timeout)</td></tr>
<tr class="memdesc:ga5db93183863758c46ab59ce0c2f3aa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket option connection timeout (Detail)  <br /></td></tr>
<tr class="separator:ga5db93183863758c46ab59ce0c2f3aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6884ad095ecc56f1a676c51ad49b5584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga6884ad095ecc56f1a676c51ad49b5584">EvrNetTCP_SetOptionKeepAlive</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t enable)</td></tr>
<tr class="memdesc:ga6884ad095ecc56f1a676c51ad49b5584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket keep-alive option (Detail)  <br /></td></tr>
<tr class="separator:ga6884ad095ecc56f1a676c51ad49b5584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb736e03519df4ff454aa002f05cc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5fb736e03519df4ff454aa002f05cc0d">EvrNetTCP_SetOptionFlowControl</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t enable)</td></tr>
<tr class="memdesc:ga5fb736e03519df4ff454aa002f05cc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket flow-control option (Detail)  <br /></td></tr>
<tr class="separator:ga5fb736e03519df4ff454aa002f05cc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ca87cbe117998c1a7088f1d8877e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga07ca87cbe117998c1a7088f1d8877e4d">EvrNetTCP_SetOptionDelayedAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t enable)</td></tr>
<tr class="memdesc:ga07ca87cbe117998c1a7088f1d8877e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP set socket delayed-acknowledge option (Detail)  <br /></td></tr>
<tr class="separator:ga07ca87cbe117998c1a7088f1d8877e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2831613b19062dbc90ea2719cd0dfd6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga2831613b19062dbc90ea2719cd0dfd6f">EvrNetTCP_SetOptionWrongOption</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t tcp_option)</td></tr>
<tr class="memdesc:ga2831613b19062dbc90ea2719cd0dfd6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP wrong set socket option (Error)  <br /></td></tr>
<tr class="separator:ga2831613b19062dbc90ea2719cd0dfd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6819f627f2ba4946734ffa4c611e73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac6819f627f2ba4946734ffa4c611e73f">EvrNetTCP_SetOptionWrongValue</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t opt_value)</td></tr>
<tr class="memdesc:gac6819f627f2ba4946734ffa4c611e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP wrong value for set socket option (Error)  <br /></td></tr>
<tr class="separator:gac6819f627f2ba4946734ffa4c611e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec61df4f44d9e2d894208f338da0c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga7ec61df4f44d9e2d894208f338da0c71">EvrNetTCP_SendDelayedAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga7ec61df4f44d9e2d894208f338da0c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send delayed-acknowledge (Op)  <br /></td></tr>
<tr class="separator:ga7ec61df4f44d9e2d894208f338da0c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79689cb4e6b63e0e7d4b6f0881720d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga79689cb4e6b63e0e7d4b6f0881720d3a">EvrNetTCP_SendKeepAliveProbe</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga79689cb4e6b63e0e7d4b6f0881720d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send keep-alive probe (Op)  <br /></td></tr>
<tr class="separator:ga79689cb4e6b63e0e7d4b6f0881720d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecb4a3fe334834b68574749b52b1b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaeecb4a3fe334834b68574749b52b1b5a">EvrNetTCP_KeepAliveTimeoutClosing</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gaeecb4a3fe334834b68574749b52b1b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP keep-alive timeout no response, close socket (Op)  <br /></td></tr>
<tr class="separator:gaeecb4a3fe334834b68574749b52b1b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00890f95dbe54f46c52fc404bb351ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga00890f95dbe54f46c52fc404bb351ce1">EvrNetTCP_CallbackEventAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga00890f95dbe54f46c52fc404bb351ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP acknowledge callback notification to the user (Op)  <br /></td></tr>
<tr class="separator:ga00890f95dbe54f46c52fc404bb351ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a48ef7d2e645b8c39a116d2864d569f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga2a48ef7d2e645b8c39a116d2864d569f">EvrNetTCP_ResendOnTimeout</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t length)</td></tr>
<tr class="memdesc:ga2a48ef7d2e645b8c39a116d2864d569f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP resend data on timeout (Op)  <br /></td></tr>
<tr class="separator:ga2a48ef7d2e645b8c39a116d2864d569f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c32a997ea7f3e7192968ec27fde95f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5c32a997ea7f3e7192968ec27fde95f0">EvrNetTCP_ShowCongestionVariables</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t cwnd, uint16_t ssth)</td></tr>
<tr class="memdesc:ga5c32a997ea7f3e7192968ec27fde95f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display congestion avoidance/control variables (Detail)  <br /></td></tr>
<tr class="separator:ga5c32a997ea7f3e7192968ec27fde95f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d289bee07ca5feab94b9ac4b8c0375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga78d289bee07ca5feab94b9ac4b8c0375">EvrNetTCP_TimeoutInState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga78d289bee07ca5feab94b9ac4b8c0375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP timeout expired in current state (Op)  <br /></td></tr>
<tr class="separator:ga78d289bee07ca5feab94b9ac4b8c0375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355097aeea01dc7c83dfd854b5d3f916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga355097aeea01dc7c83dfd854b5d3f916">EvrNetTCP_TwaitTimeoutClosing</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga355097aeea01dc7c83dfd854b5d3f916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP timeout in TIME_WAIT state, closing socket (Op)  <br /></td></tr>
<tr class="separator:ga355097aeea01dc7c83dfd854b5d3f916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b8f483a11305746d9a68f036cd75853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga9b8f483a11305746d9a68f036cd75853">EvrNetTCP_ClosingTimeout</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga9b8f483a11305746d9a68f036cd75853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP timeout in CLOSING, FIN_WAIT_1 or LAST_ACK state (Op)  <br /></td></tr>
<tr class="separator:ga9b8f483a11305746d9a68f036cd75853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc6c1f97b79d796fb805a5bca2bd6681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gabc6c1f97b79d796fb805a5bca2bd6681">EvrNetTCP_NoRetriesLeft</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gabc6c1f97b79d796fb805a5bca2bd6681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP no retries left (Error)  <br /></td></tr>
<tr class="separator:gabc6c1f97b79d796fb805a5bca2bd6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da961c14765cf273bc8e80b58d2579f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga8da961c14765cf273bc8e80b58d2579f">EvrNetTCP_ReceiveFrame</a> (uint32_t length, uint8_t ip_version)</td></tr>
<tr class="memdesc:ga8da961c14765cf273bc8e80b58d2579f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP receive frame (Op)  <br /></td></tr>
<tr class="separator:ga8da961c14765cf273bc8e80b58d2579f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b590b093b753c81d9cf996851a5406b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4b590b093b753c81d9cf996851a5406b">EvrNetTCP_FrameTooShort</a> (uint32_t length, uint32_t min_length)</td></tr>
<tr class="memdesc:ga4b590b093b753c81d9cf996851a5406b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP receive frame too short (Error)  <br /></td></tr>
<tr class="separator:ga4b590b093b753c81d9cf996851a5406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22ff3772bd2345490783bf2de1f2d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad22ff3772bd2345490783bf2de1f2d65">EvrNetTCP_FrameNotMapped</a> (uint32_t length)</td></tr>
<tr class="memdesc:gad22ff3772bd2345490783bf2de1f2d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP received frame not mapped, no active socket found (Op)  <br /></td></tr>
<tr class="separator:gad22ff3772bd2345490783bf2de1f2d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e90189bb31c1b0027899493ab0060f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga81e90189bb31c1b0027899493ab0060f">EvrNetTCP_MapFrameToSocket</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga81e90189bb31c1b0027899493ab0060f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP received frame mapped to a socket (Op)  <br /></td></tr>
<tr class="separator:ga81e90189bb31c1b0027899493ab0060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c5bf060730b2c43f44c691de1ad1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga85c5bf060730b2c43f44c691de1ad1bd">EvrNetTCP_ChecksumFailed</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga85c5bf060730b2c43f44c691de1ad1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame checksum check failed (Error)  <br /></td></tr>
<tr class="separator:ga85c5bf060730b2c43f44c691de1ad1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c00ed778bbd5dd910339c966950da4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga1c00ed778bbd5dd910339c966950da4d">EvrNetTCP_ShowFrameHeader</a> (const void *tcp_header)</td></tr>
<tr class="memdesc:ga1c00ed778bbd5dd910339c966950da4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display send/receive frame header (Detail)  <br /></td></tr>
<tr class="separator:ga1c00ed778bbd5dd910339c966950da4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4c8d4f803cfeb08405ca18282508346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae4c8d4f803cfeb08405ca18282508346">EvrNetTCP_RstInWindow</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gae4c8d4f803cfeb08405ca18282508346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP RST-flag received within current receive window (Op)  <br /></td></tr>
<tr class="separator:gae4c8d4f803cfeb08405ca18282508346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d27f20645ef1821a2b5aa2ca5b6b8bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga7d27f20645ef1821a2b5aa2ca5b6b8bc">EvrNetTCP_RstNotValid</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga7d27f20645ef1821a2b5aa2ca5b6b8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP RST-flag received outside current receive window (Op)  <br /></td></tr>
<tr class="separator:ga7d27f20645ef1821a2b5aa2ca5b6b8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b72a6664cffe5ba528f695494a3269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac9b72a6664cffe5ba528f695494a3269">EvrNetTCP_RepeatedSynAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gac9b72a6664cffe5ba528f695494a3269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP repeated SYN+ACK-flags received (Op)  <br /></td></tr>
<tr class="separator:gac9b72a6664cffe5ba528f695494a3269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aebdd3f123474fc80e6fc297f98317d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4aebdd3f123474fc80e6fc297f98317d">EvrNetTCP_AckNotSet</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga4aebdd3f123474fc80e6fc297f98317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP ACK-flag not set in received frame (Op)  <br /></td></tr>
<tr class="separator:ga4aebdd3f123474fc80e6fc297f98317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93d8ea699c093dd05560f3d9c7d4d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gab93d8ea699c093dd05560f3d9c7d4d3a">EvrNetTCP_ShowSendWindow</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t send_window)</td></tr>
<tr class="memdesc:gab93d8ea699c093dd05560f3d9c7d4d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display current sending window size (Op)  <br /></td></tr>
<tr class="separator:gab93d8ea699c093dd05560f3d9c7d4d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6dccc852068ff817af42ed39a79c80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad6dccc852068ff817af42ed39a79c80a">EvrNetTCP_KeepAliveSegment</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gad6dccc852068ff817af42ed39a79c80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP keep-alive frame received (Op)  <br /></td></tr>
<tr class="separator:gad6dccc852068ff817af42ed39a79c80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad489876037d877a1310ffb74a8c6a005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad489876037d877a1310ffb74a8c6a005">EvrNetTCP_RetransmittedSegment</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gad489876037d877a1310ffb74a8c6a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP retransmitted frame received (Op)  <br /></td></tr>
<tr class="separator:gad489876037d877a1310ffb74a8c6a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a2b32f4cec602226316936d6bcccc92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga1a2b32f4cec602226316936d6bcccc92">EvrNetTCP_OutOfRangeSegment</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga1a2b32f4cec602226316936d6bcccc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP out of range segment received (Error)  <br /></td></tr>
<tr class="separator:ga1a2b32f4cec602226316936d6bcccc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588cfd224ef168a0c68aa9f3246ae4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga588cfd224ef168a0c68aa9f3246ae4a6">EvrNetTCP_ZeroWindowProbe</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga588cfd224ef168a0c68aa9f3246ae4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP zero-window probe received (Op)  <br /></td></tr>
<tr class="separator:ga588cfd224ef168a0c68aa9f3246ae4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9a540744193c2e0d4dd30d8d4e94ef6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac9a540744193c2e0d4dd30d8d4e94ef6">EvrNetTCP_RemotePeerClosing</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gac9a540744193c2e0d4dd30d8d4e94ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP FIN-flag received, remote peer wants to close (Op)  <br /></td></tr>
<tr class="separator:gac9a540744193c2e0d4dd30d8d4e94ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656706dcb11ca4730978ec5d4620d032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga656706dcb11ca4730978ec5d4620d032">EvrNetTCP_ShowReceiveWindow</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t rec_window)</td></tr>
<tr class="memdesc:ga656706dcb11ca4730978ec5d4620d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP display current receiving window size (Op)  <br /></td></tr>
<tr class="separator:ga656706dcb11ca4730978ec5d4620d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf224fd45840661ddd007dbc4641b2f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaf224fd45840661ddd007dbc4641b2f58">EvrNetTCP_InvalidAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gaf224fd45840661ddd007dbc4641b2f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP ACK-flag set received, invalid in state LISTEN (Error)  <br /></td></tr>
<tr class="separator:gaf224fd45840661ddd007dbc4641b2f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1094d6ad120107a5b5a6504f03f53b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga1094d6ad120107a5b5a6504f03f53b1a">EvrNetTCP_SynNotSet</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga1094d6ad120107a5b5a6504f03f53b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP SYN-flag not set in received frame (Error)  <br /></td></tr>
<tr class="separator:ga1094d6ad120107a5b5a6504f03f53b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eadf3f87b677a3710235db7800836c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga6eadf3f87b677a3710235db7800836c2">EvrNetTCP_UserConnectionReject</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga6eadf3f87b677a3710235db7800836c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP user rejected inbound connection (Op)  <br /></td></tr>
<tr class="separator:ga6eadf3f87b677a3710235db7800836c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18de9978c7fc0c2547978ec3316b0f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga18de9978c7fc0c2547978ec3316b0f67">EvrNetTCP_NextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga18de9978c7fc0c2547978ec3316b0f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP transition to next state (Op)  <br /></td></tr>
<tr class="separator:ga18de9978c7fc0c2547978ec3316b0f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa32a0d8e2aa7043fe1cc2f3f47579e71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaa32a0d8e2aa7043fe1cc2f3f47579e71">EvrNetTCP_WrongSynAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gaa32a0d8e2aa7043fe1cc2f3f47579e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP SYN+ACK-flags set but wrong ack number (Error)  <br /></td></tr>
<tr class="separator:gaa32a0d8e2aa7043fe1cc2f3f47579e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dbbae2a0f004ce7dd313900fc9b7a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga6dbbae2a0f004ce7dd313900fc9b7a45">EvrNetTCP_WrongAckNumber</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga6dbbae2a0f004ce7dd313900fc9b7a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP ACK-flag set but wrong ack number (Error)  <br /></td></tr>
<tr class="separator:ga6dbbae2a0f004ce7dd313900fc9b7a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697dd3899ab0043d087f194636729078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga697dd3899ab0043d087f194636729078">EvrNetTCP_WrongSeqNumber</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga697dd3899ab0043d087f194636729078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP ACK-flag set but wrong seq number (Error)  <br /></td></tr>
<tr class="separator:ga697dd3899ab0043d087f194636729078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac510c586418182e8d732018f46f404cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac510c586418182e8d732018f46f404cc">EvrNetTCP_RepeatedSyn</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gac510c586418182e8d732018f46f404cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP repeated SYN-flag set frame received (Op)  <br /></td></tr>
<tr class="separator:gac510c586418182e8d732018f46f404cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7d001944559af9902ecaba49fccfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5e7d001944559af9902ecaba49fccfd7">EvrNetTCP_FrameUnrecognised</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga5e7d001944559af9902ecaba49fccfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP unrecognised frame received (Error)  <br /></td></tr>
<tr class="separator:ga5e7d001944559af9902ecaba49fccfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74b0b1bfb7ccf47887df686aa352d46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae74b0b1bfb7ccf47887df686aa352d46">EvrNetTCP_SimultOpenNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:gae74b0b1bfb7ccf47887df686aa352d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP SYN-flag set received in simultaneous open (Op)  <br /></td></tr>
<tr class="separator:gae74b0b1bfb7ccf47887df686aa352d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf616347d36b5851002de6217a000467d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaf616347d36b5851002de6217a000467d">EvrNetTCP_WrongFinAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gaf616347d36b5851002de6217a000467d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame with FIN+ACK-flags set but wrong ack number (Error)  <br /></td></tr>
<tr class="separator:gaf616347d36b5851002de6217a000467d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7dbfed1651fb5f30c80e1ac8d7114da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaa7dbfed1651fb5f30c80e1ac8d7114da">EvrNetTCP_FinAckNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:gaa7dbfed1651fb5f30c80e1ac8d7114da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame with FIN+ACK-flags received (Op)  <br /></td></tr>
<tr class="separator:gaa7dbfed1651fb5f30c80e1ac8d7114da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99894ec10c8dd97076a529bfe5fb78b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga99894ec10c8dd97076a529bfe5fb78b7">EvrNetTCP_SimultCloseNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga99894ec10c8dd97076a529bfe5fb78b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame with FIN-flag received in simultaneous close (Op)  <br /></td></tr>
<tr class="separator:ga99894ec10c8dd97076a529bfe5fb78b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga035bbbf7050cf78824af30520e113976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga035bbbf7050cf78824af30520e113976">EvrNetTCP_AckNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:ga035bbbf7050cf78824af30520e113976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame with ACK-flag received (Op)  <br /></td></tr>
<tr class="separator:ga035bbbf7050cf78824af30520e113976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae86727b491d11adddd771b44c006a088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae86727b491d11adddd771b44c006a088">EvrNetTCP_FinNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:gae86727b491d11adddd771b44c006a088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP frame with FIN-flag received (Op)  <br /></td></tr>
<tr class="separator:gae86727b491d11adddd771b44c006a088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d89655e312a9e044a1e664c3537baea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga5d89655e312a9e044a1e664c3537baea">EvrNetTCP_PshAckInHalfClosed</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga5d89655e312a9e044a1e664c3537baea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP PSH+ACK-flags received in half closed state FIN_WAIT_2 (Op)  <br /></td></tr>
<tr class="separator:ga5d89655e312a9e044a1e664c3537baea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18ad833c3ae03fee6fb23e6a12bb07a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga18ad833c3ae03fee6fb23e6a12bb07a0">EvrNetTCP_RepeatedFin</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga18ad833c3ae03fee6fb23e6a12bb07a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP repeated FIN-flag received (Op)  <br /></td></tr>
<tr class="separator:ga18ad833c3ae03fee6fb23e6a12bb07a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e0c5804c652492a23a9816538a3289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaa6e0c5804c652492a23a9816538a3289">EvrNetTCP_LastAckNextState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, int32_t state)</td></tr>
<tr class="memdesc:gaa6e0c5804c652492a23a9816538a3289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP last ACK-flag received (Op)  <br /></td></tr>
<tr class="separator:gaa6e0c5804c652492a23a9816538a3289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b5d1e25be1916c6df2cb3519fad032"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gad9b5d1e25be1916c6df2cb3519fad032">EvrNetTCP_RstReceived</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:gad9b5d1e25be1916c6df2cb3519fad032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP RST-flag received (Error)  <br /></td></tr>
<tr class="separator:gad9b5d1e25be1916c6df2cb3519fad032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3fa97fba29b8715c48b0daa4e4b888"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga4e3fa97fba29b8715c48b0daa4e4b888">EvrNetTCP_InvalidState</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga4e3fa97fba29b8715c48b0daa4e4b888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP socket in invalid state (Error)  <br /></td></tr>
<tr class="separator:ga4e3fa97fba29b8715c48b0daa4e4b888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8081b2a0f691faa47f88303dd3d72413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga8081b2a0f691faa47f88303dd3d72413">EvrNetTCP_SendData</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint16_t length)</td></tr>
<tr class="memdesc:ga8081b2a0f691faa47f88303dd3d72413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send data frame (Op)  <br /></td></tr>
<tr class="separator:ga8081b2a0f691faa47f88303dd3d72413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935140d8a00f81f39aff0db5daeec863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga935140d8a00f81f39aff0db5daeec863">EvrNetTCP_SendControl</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>)</td></tr>
<tr class="memdesc:ga935140d8a00f81f39aff0db5daeec863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send control frame (Op)  <br /></td></tr>
<tr class="separator:ga935140d8a00f81f39aff0db5daeec863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ef37c8d20f224429cfc6d516e65ccb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga6ef37c8d20f224429cfc6d516e65ccb6">EvrNetTCP_SendReset</a> (void)</td></tr>
<tr class="memdesc:ga6ef37c8d20f224429cfc6d516e65ccb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP send reset to remote host for unmapped frame (Op)  <br /></td></tr>
<tr class="separator:ga6ef37c8d20f224429cfc6d516e65ccb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa01289acd546e6fc9146e9cacc980abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaa01289acd546e6fc9146e9cacc980abd">EvrNetTCP_ParseHeaderOptions</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t opt_length)</td></tr>
<tr class="memdesc:gaa01289acd546e6fc9146e9cacc980abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP parse header options (Op)  <br /></td></tr>
<tr class="separator:gaa01289acd546e6fc9146e9cacc980abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50f135d3c53ef9ff839233b431c83286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga50f135d3c53ef9ff839233b431c83286">EvrNetTCP_OptionMss</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t mss)</td></tr>
<tr class="memdesc:ga50f135d3c53ef9ff839233b431c83286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP header option MSS (maximum segment size) (Op)  <br /></td></tr>
<tr class="separator:ga50f135d3c53ef9ff839233b431c83286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c939540dd11d6b36f4de4c5a961aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga21c939540dd11d6b36f4de4c5a961aa4">EvrNetTCP_DuplicateAck</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t dup_acks)</td></tr>
<tr class="memdesc:ga21c939540dd11d6b36f4de4c5a961aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP duplicate acknowledge processing (Op)  <br /></td></tr>
<tr class="separator:ga21c939540dd11d6b36f4de4c5a961aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae088d28206cb82f0aed180fc453cb79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gae088d28206cb82f0aed180fc453cb79a">EvrNetTCP_FastRetransmit</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t data_length)</td></tr>
<tr class="memdesc:gae088d28206cb82f0aed180fc453cb79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP fast retransmit, received 3 duplicate acks (Op)  <br /></td></tr>
<tr class="separator:gae088d28206cb82f0aed180fc453cb79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06ebf76631b20b0d6452115e8f161735"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga06ebf76631b20b0d6452115e8f161735">EvrNetTCP_DataAcked</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t ack_length)</td></tr>
<tr class="memdesc:ga06ebf76631b20b0d6452115e8f161735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP data acknowledge processing (Op)  <br /></td></tr>
<tr class="separator:ga06ebf76631b20b0d6452115e8f161735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ea9458a5b777b7865a8aca34b04ceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga90ea9458a5b777b7865a8aca34b04ceb">EvrNetTCP_ResendData</a> (int32_t <a class="el" href="group__using__network__sockets__bsd__func.html#gac01ac0611ef0f7d743e0eb464e7786a9">socket</a>, uint32_t length, uint32_t tout)</td></tr>
<tr class="memdesc:ga90ea9458a5b777b7865a8aca34b04ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP resend data from transmit queue (Op)  <br /></td></tr>
<tr class="separator:ga90ea9458a5b777b7865a8aca34b04ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dfd12e03806cdd4a0a2489d6e90cee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga0dfd12e03806cdd4a0a2489d6e90cee0">EvrNetTCP_MapSocketWrongFlagsSet</a> (void)</td></tr>
<tr class="memdesc:ga0dfd12e03806cdd4a0a2489d6e90cee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP map socket failed, wrong TCP flags set (Error)  <br /></td></tr>
<tr class="separator:ga0dfd12e03806cdd4a0a2489d6e90cee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3dd497f04005147ecf908568061b2a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gaa3dd497f04005147ecf908568061b2a2">EvrNetTCP_MapSocketSynNotSet</a> (void)</td></tr>
<tr class="memdesc:gaa3dd497f04005147ecf908568061b2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP map socket failed, SYN-flag not set (Error)  <br /></td></tr>
<tr class="separator:gaa3dd497f04005147ecf908568061b2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f8a6deada5aacfea6d5aa376a06ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#gac7f8a6deada5aacfea6d5aa376a06ba5">EvrNetTCP_MapSocketNoListenSocket</a> (void)</td></tr>
<tr class="memdesc:gac7f8a6deada5aacfea6d5aa376a06ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP map socket failed, no listening sockets found (Error)  <br /></td></tr>
<tr class="separator:gac7f8a6deada5aacfea6d5aa376a06ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b483ddac06b0814fe46de1984a7d02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__evr__tcp__func.html#ga8b483ddac06b0814fe46de1984a7d02b">EvrNetTCP_UninitSockets</a> (void)</td></tr>
<tr class="memdesc:ga8b483ddac06b0814fe46de1984a7d02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event on TCP de-initialize available sockets (Op)  <br /></td></tr>
<tr class="separator:ga8b483ddac06b0814fe46de1984a7d02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Events generated by the Network - TCP Socket functions. </p>
<p>The TCP socket functions generate events that make it easier to troubleshoot errors, and allow the user to understand the way TCP sockets work. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga312a5678b5ae1d036d809fac65c34ee9" name="ga312a5678b5ae1d036d809fac65c34ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga312a5678b5ae1d036d809fac65c34ee9">&#9670;&#160;</a></span>EvrNetTCP_AbortSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AbortSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP abort socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AbortSocket</b> is created when the TCP socket is interrupted for communication, that is, closed instantly. This happens when the function <a class="el" href="group__tcp__user__api.html#ga621b26f6da519678dd6a660fce012668">netTCP_Abort</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for aborting. </li>
</ul>

</div>
</div>
<a id="ga5f0f5ed4d43717728bb096dc7810e4f8" name="ga5f0f5ed4d43717728bb096dc7810e4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0f5ed4d43717728bb096dc7810e4f8">&#9670;&#160;</a></span>EvrNetTCP_AbortSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AbortSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP abort failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AbortSocketNotValid</b> is created, when the internal function <em>tcp_abort</em> can not abort the TCP socket because the provided socket handle is invalid. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga621b26f6da519678dd6a660fce012668">netTCP_Abort</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for aborting. </li>
</ul>

</div>
</div>
<a id="ga170c2dc402cb2265c905c4a127335c7a" name="ga170c2dc402cb2265c905c4a127335c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga170c2dc402cb2265c905c4a127335c7a">&#9670;&#160;</a></span>EvrNetTCP_AbortSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AbortSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP abort failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AbortSocketWrongState</b> is created, when the internal function <em>tcp_abort</em> can not abort the TCP socket because the the socket is not created. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga621b26f6da519678dd6a660fce012668">netTCP_Abort</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for aborting.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga035bbbf7050cf78824af30520e113976" name="ga035bbbf7050cf78824af30520e113976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga035bbbf7050cf78824af30520e113976">&#9670;&#160;</a></span>EvrNetTCP_AckNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AckNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame with ACK-flag received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AckNextState</b> is created when the socket receives the TCP frame with the ACK flag set while closing. The socket state changes to the next state.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="ga4aebdd3f123474fc80e6fc297f98317d" name="ga4aebdd3f123474fc80e6fc297f98317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aebdd3f123474fc80e6fc297f98317d">&#9670;&#160;</a></span>EvrNetTCP_AckNotSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AckNotSet </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP ACK-flag not set in received frame (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AckNotSet</b> is created when the connected socket receives the TCP frame with the ACK flag not set. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gadb86a7dddfbbac6b28da0f43b9c20872" name="gadb86a7dddfbbac6b28da0f43b9c20872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb86a7dddfbbac6b28da0f43b9c20872">&#9670;&#160;</a></span>EvrNetTCP_AssignLocalPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_AssignLocalPort </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>local_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP local port assigned in socket connect request (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">local_port</td><td>assigned local port number</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>AssignLocalPort</b> is created, when the internal function <em>tcp_connect</em> attempts to connect, but the local port is not defined, which means that it has a value of 0. The socket then automatically allocates a free local port and uses it to connect. This happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>loc_port:</b> assigned local port number. </li>
</ul>

</div>
</div>
<a id="ga00890f95dbe54f46c52fc404bb351ce1" name="ga00890f95dbe54f46c52fc404bb351ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00890f95dbe54f46c52fc404bb351ce1">&#9670;&#160;</a></span>EvrNetTCP_CallbackEventAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_CallbackEventAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP acknowledge callback notification to the user (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>CallbackEventAck</b> is created, when the network library sends an acknowledge notification to the user application. The notification shall be sent if certain conditions are met. This means that the TCP sending window allows you to send more data and there is enough free memory to store new transmit packets.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga85c5bf060730b2c43f44c691de1ad1bd" name="ga85c5bf060730b2c43f44c691de1ad1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c5bf060730b2c43f44c691de1ad1bd">&#9670;&#160;</a></span>EvrNetTCP_ChecksumFailed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ChecksumFailed </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame checksum check failed (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ChecksumFailed</b> is created when the network library has checked the checksum on the received TCP frame and the verification failed. The TCP frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga4d2068e56d1fb57d556cb30dbc58249d" name="ga4d2068e56d1fb57d556cb30dbc58249d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2068e56d1fb57d556cb30dbc58249d">&#9670;&#160;</a></span>EvrNetTCP_CloseDataUnacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_CloseDataUnacked </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>unack_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP close pended, unacked data exist (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">unack_length</td><td>length of unacked data</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>CloseDataUnacked</b> is created, when the internal function <em>tcp_close</em> can not close the TCP socket because some transmitted data is still pending confirmation. This usually happens when the <a class="el" href="group__tcp__user__api.html#gad3b70b023f209cd7687f15f553219185">netTCP_Close</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for closing.</li>
<li><b>len:</b> length of the unacknowledged data. </li>
</ul>

</div>
</div>
<a id="ga44537256d395c7bfb4102d730067df9b" name="ga44537256d395c7bfb4102d730067df9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44537256d395c7bfb4102d730067df9b">&#9670;&#160;</a></span>EvrNetTCP_CloseSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_CloseSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP close socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>CloseSocket</b> is created when the TCP socket is closed for communication, that is, when the function <a class="el" href="group__tcp__user__api.html#gad3b70b023f209cd7687f15f553219185">netTCP_Close</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for closing. </li>
</ul>

</div>
</div>
<a id="ga658c15ba5fea6044d21aca02c1530126" name="ga658c15ba5fea6044d21aca02c1530126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658c15ba5fea6044d21aca02c1530126">&#9670;&#160;</a></span>EvrNetTCP_CloseSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_CloseSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP close socket failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>CloseSocketNotValid</b> is created, when the internal function <em>tcp_close</em> can not close the TCP socket because the provided socket handle is invalid. This usually happens when the <a class="el" href="group__tcp__user__api.html#gad3b70b023f209cd7687f15f553219185">netTCP_Close</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for closing. </li>
</ul>

</div>
</div>
<a id="ga4223945740b58e1382ac3cc41edfbaa3" name="ga4223945740b58e1382ac3cc41edfbaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4223945740b58e1382ac3cc41edfbaa3">&#9670;&#160;</a></span>EvrNetTCP_CloseSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_CloseSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP close failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>CloseSocketWrongState</b> is created, when the internal function <em>tcp_close</em> can not close the TCP socket because the the socket is not created. This usually happens when the <a class="el" href="group__tcp__user__api.html#gad3b70b023f209cd7687f15f553219185">netTCP_Close</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for closing.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga9b8f483a11305746d9a68f036cd75853" name="ga9b8f483a11305746d9a68f036cd75853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b8f483a11305746d9a68f036cd75853">&#9670;&#160;</a></span>EvrNetTCP_ClosingTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ClosingTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP timeout in CLOSING, FIN_WAIT_1 or LAST_ACK state (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ClosingTimeout</b> is created, when the retry timer expires and the socket is closing. If retries are available, the socket sends the control packet again.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga35a4a4d4a2b207f715b8a2c1e3c3f455" name="ga35a4a4d4a2b207f715b8a2c1e3c3f455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a4a4d4a2b207f715b8a2c1e3c3f455">&#9670;&#160;</a></span>EvrNetTCP_ConnectAddressUnspecified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectAddressUnspecified </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect failed, address unspecified (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectAddressUnspecified</b> is created, when the internal function <em>tcp_connect</em> can not start connection because the provided destination IP address is unspecified. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga4eb8843a7601f06b0d11dc4a0be2f9ff" name="ga4eb8843a7601f06b0d11dc4a0be2f9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb8843a7601f06b0d11dc4a0be2f9ff">&#9670;&#160;</a></span>EvrNetTCP_ConnectLocalPortInvalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectLocalPortInvalid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>local_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect failed, local port invalid (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">local_port</td><td>local port number</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectLocalPortInvalid</b> is created, when the internal function <em>tcp_connect</em> can not start connection because the local port number is invalid, meaning that it has a value of 0 or equal to the listening local port. This happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed for the listening socket.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>loc_port:</b> local port number. </li>
</ul>

</div>
</div>
<a id="ga47821d7e7012b2b4baebd5bb97580682" name="ga47821d7e7012b2b4baebd5bb97580682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47821d7e7012b2b4baebd5bb97580682">&#9670;&#160;</a></span>EvrNetTCP_ConnectPortUndefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectPortUndefined </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect failed, port undefined (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectPortUndefined</b> is created, when the internal function <em>tcp_connect</em> can not start connection because the provided remote port number is undefined, which means that it has a value of 0. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gae2079445e2640aca678e7b5756a16510" name="gae2079445e2640aca678e7b5756a16510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2079445e2640aca678e7b5756a16510">&#9670;&#160;</a></span>EvrNetTCP_ConnectSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>local_port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect socket request (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">local_port</td><td>local port number</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectSocket</b> is created, when a socket starts a connection to a remote server, that is, when the function <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>loc_port:</b> assigned local TCP port. </li>
</ul>

</div>
</div>
<a id="ga2b62fd65c3366aacc01c282eec066204" name="ga2b62fd65c3366aacc01c282eec066204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b62fd65c3366aacc01c282eec066204">&#9670;&#160;</a></span>EvrNetTCP_ConnectSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectSocketNotValid</b> is created, when the internal function <em>tcp_connect</em> can not start connection because the provided socket handle is not valid. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga93176daeb1710d024f0e83c6ee586d12" name="ga93176daeb1710d024f0e83c6ee586d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93176daeb1710d024f0e83c6ee586d12">&#9670;&#160;</a></span>EvrNetTCP_ConnectSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ConnectSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP connect failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ConnectSocketWrongState</b> is created, when the internal function <em>tcp_connect</em> can not start connection because the the socket is not closed or not listening. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga5dbbfc3def198bfe40ef51629dc55652">netTCP_Connect</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga06ebf76631b20b0d6452115e8f161735" name="ga06ebf76631b20b0d6452115e8f161735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06ebf76631b20b0d6452115e8f161735">&#9670;&#160;</a></span>EvrNetTCP_DataAcked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_DataAcked </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ack_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP data acknowledge processing (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">ack_length</td><td>acknowledged data length</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>DataAcked</b> is created when the connected socket receives the TCP acknowledgement. When this happens, the acknowledged data stored for possible retransmission, will be released from the memory.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>ack_len:</b> length of the acknowledged data. </li>
</ul>

</div>
</div>
<a id="ga21c939540dd11d6b36f4de4c5a961aa4" name="ga21c939540dd11d6b36f4de4c5a961aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c939540dd11d6b36f4de4c5a961aa4">&#9670;&#160;</a></span>EvrNetTCP_DuplicateAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_DuplicateAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dup_acks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP duplicate acknowledge processing (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">dup_acks</td><td>number of duplicate acks</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>DuplicateAck</b> is created when the connected socket receives the TCP frame with ACK flag set that is recognized as a duplicate acknowledgement. This happens when our transmitted data frame is lost.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>dup_acks:</b> number of duplicate acknowledgements recorded. </li>
</ul>

</div>
</div>
<a id="gae088d28206cb82f0aed180fc453cb79a" name="gae088d28206cb82f0aed180fc453cb79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae088d28206cb82f0aed180fc453cb79a">&#9670;&#160;</a></span>EvrNetTCP_FastRetransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FastRetransmit </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP fast retransmit, received 3 duplicate acks (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">data_length</td><td>length of data to fast retransmit</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FastRetransmit</b> is created when the connected socket receives a third duplicate acknowledgement. This happens when our transmitted data frame is lost. The socket then starts the fast retransmission and recovery process and does not wait for the retransmit timer to expire.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>len:</b> length of the data to retransmit. </li>
</ul>

</div>
</div>
<a id="gaa7dbfed1651fb5f30c80e1ac8d7114da" name="gaa7dbfed1651fb5f30c80e1ac8d7114da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7dbfed1651fb5f30c80e1ac8d7114da">&#9670;&#160;</a></span>EvrNetTCP_FinAckNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FinAckNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame with FIN+ACK-flags received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FinAckNextState</b> is created when the socket receives the TCP frame with the FIN and ACK flags set and identifies it as being simultaneously closed on both sides. The socket then sends acknowledge and the state changes to the next state.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="gae86727b491d11adddd771b44c006a088" name="gae86727b491d11adddd771b44c006a088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae86727b491d11adddd771b44c006a088">&#9670;&#160;</a></span>EvrNetTCP_FinNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FinNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame with FIN-flag received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FinNextState</b> is created when the socket receives the TCP frame with the FIN flag set while closing. The socket state changes to the next state.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="gad22ff3772bd2345490783bf2de1f2d65" name="gad22ff3772bd2345490783bf2de1f2d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad22ff3772bd2345490783bf2de1f2d65">&#9670;&#160;</a></span>EvrNetTCP_FrameNotMapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FrameNotMapped </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP received frame not mapped, no active socket found (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>frame length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FrameNotMapped</b> is created when the network library receives the TCP frame and can not map the frame to any open TCP socket. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>len:</b> length of the received frame in bytes. </li>
</ul>

</div>
</div>
<a id="ga4b590b093b753c81d9cf996851a5406b" name="ga4b590b093b753c81d9cf996851a5406b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b590b093b753c81d9cf996851a5406b">&#9670;&#160;</a></span>EvrNetTCP_FrameTooShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FrameTooShort </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP receive frame too short (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>frame length in bytes </td></tr>
    <tr><td class="paramname">min_length</td><td>minimum length of the frame</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FrameTooShort</b> is created when the network library receives the TCP frame that is too short. The TCP frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>len:</b> length of the received frame in bytes.</li>
<li><b>min:</b> minimum valid frame length in bytes. </li>
</ul>

</div>
</div>
<a id="ga5e7d001944559af9902ecaba49fccfd7" name="ga5e7d001944559af9902ecaba49fccfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7d001944559af9902ecaba49fccfd7">&#9670;&#160;</a></span>EvrNetTCP_FrameUnrecognised()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_FrameUnrecognised </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP unrecognised frame received (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>FrameUnrecognised</b> is created when the socket receives the TCP frame with a set of invalid flags. The socket sends a reset frame to the remote peer.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga9420dfe55e28577157932864a3a37632" name="ga9420dfe55e28577157932864a3a37632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9420dfe55e28577157932864a3a37632">&#9670;&#160;</a></span>EvrNetTCP_GetBufferFailed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_GetBufferFailed </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mem_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP get buffer failed, out of memory (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem_size</td><td>requested memory size</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>GetBufferFailed</b> is created, when the network library can not allocate the memory for the TCP socket send buffer. This happens when there is no free memory in the memory pool.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>size:</b> requested memory size. </li>
</ul>

</div>
</div>
<a id="ga3ee597d82d09b36096ffb2c548ca6405" name="ga3ee597d82d09b36096ffb2c548ca6405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee597d82d09b36096ffb2c548ca6405">&#9670;&#160;</a></span>EvrNetTCP_GetSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_GetSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_socks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP allocate a free socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>allocated socket handle </td></tr>
    <tr><td class="paramname">num_socks</td><td>number of available TCP sockets</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>GetSocket</b> is created when the TCP socket is assigned, that is, when the function <a class="el" href="group__tcp__user__api.html#ga19247901cf1062d474d767ac68277ed3">netTCP_GetSocket</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> allocated TCP socket handle.</li>
<li><b>max:</b> the highest possible value of the socket handle. </li>
</ul>

</div>
</div>
<a id="gabb20b14be980ef029de246c7c4ee5d0c" name="gabb20b14be980ef029de246c7c4ee5d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb20b14be980ef029de246c7c4ee5d0c">&#9670;&#160;</a></span>EvrNetTCP_GetSocketInvalidParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_GetSocketInvalidParameter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP get socket failed, invalid parameter (Error) </p>
<p>The event <b>GetSocketInvalidParameter</b> is created, when an invalid input parameter is provided for the <em>tcp_get_socket</em> internal function. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga19247901cf1062d474d767ac68277ed3">netTCP_GetSocket</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>error</b> </li>
</ul>

</div>
</div>
<a id="ga783511f4efa2adbc3a5fbf40ea13b4d8" name="ga783511f4efa2adbc3a5fbf40ea13b4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga783511f4efa2adbc3a5fbf40ea13b4d8">&#9670;&#160;</a></span>EvrNetTCP_InitSockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_InitSockets </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_sockets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_segsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP socket initialize (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_sockets</td><td>number of available TCP sockets </td></tr>
    <tr><td class="paramname">max_segsize</td><td>maximum segment size in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>InitSockets</b> is created when the TCP sockets are initialized, that is, when the function <a class="el" href="group__netSys__Func.html#ga0c68e74df79a37750413f72518f63f73">netInitialize</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>sockets:</b> number of TCP sockets available.</li>
<li><b>mss:</b> maximum segment size in bytes. </li>
</ul>

</div>
</div>
<a id="gaf224fd45840661ddd007dbc4641b2f58" name="gaf224fd45840661ddd007dbc4641b2f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf224fd45840661ddd007dbc4641b2f58">&#9670;&#160;</a></span>EvrNetTCP_InvalidAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_InvalidAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP ACK-flag set received, invalid in state LISTEN (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>InvalidAck</b> is created when the listening socket receives the TCP frame with the ACK flag set. This might happen, if the remote peer has a phantom socket still open. The socket then sends a reset frame to the remote peer.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga4e3fa97fba29b8715c48b0daa4e4b888" name="ga4e3fa97fba29b8715c48b0daa4e4b888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e3fa97fba29b8715c48b0daa4e4b888">&#9670;&#160;</a></span>EvrNetTCP_InvalidState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_InvalidState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP socket in invalid state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>InvalidState</b> is created when the socket receives the TCP frame in an invalid state. This notification is a sign of serious problems in the network library or user application, and it would usually never happen.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gad6dccc852068ff817af42ed39a79c80a" name="gad6dccc852068ff817af42ed39a79c80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6dccc852068ff817af42ed39a79c80a">&#9670;&#160;</a></span>EvrNetTCP_KeepAliveSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_KeepAliveSegment </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP keep-alive frame received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>KeepAliveSegment</b> is created when the connected socket receives the TCP frame with no data that is recognized as a keepalive packet. The keepalive timer then restarts.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gaeecb4a3fe334834b68574749b52b1b5a" name="gaeecb4a3fe334834b68574749b52b1b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeecb4a3fe334834b68574749b52b1b5a">&#9670;&#160;</a></span>EvrNetTCP_KeepAliveTimeoutClosing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_KeepAliveTimeoutClosing </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP keep-alive timeout no response, close socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>KeepAliveTimeoutClosing</b> is created, when the keepalive timer expires, but the keepalive mode is not enabled for the socket. The socket is then closed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gaa6e0c5804c652492a23a9816538a3289" name="gaa6e0c5804c652492a23a9816538a3289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6e0c5804c652492a23a9816538a3289">&#9670;&#160;</a></span>EvrNetTCP_LastAckNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_LastAckNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP last ACK-flag received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>LastAckNextState</b> is created when the socket receives the last acknowledgement during closing. The socket state changes to the next state.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="ga9b74afb4717fb3c27c4723265fa415fd" name="ga9b74afb4717fb3c27c4723265fa415fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b74afb4717fb3c27c4723265fa415fd">&#9670;&#160;</a></span>EvrNetTCP_ListenPortUndefined()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ListenPortUndefined </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP listen failed, listening port undefined (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ListenPortUndefined</b> is created, when the internal function <em>tcp_listen</em> can not set the TCP socket to listening mode because the provided port number is undefined, which means that it has a value of 0. This usually happens when the <a class="el" href="group__tcp__user__api.html#gac02a84a9dc999e80c5a8a1650e5d9674">netTCP_Listen</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for listening. </li>
</ul>

</div>
</div>
<a id="ga8d60bb0ce4651304d10c6ddf47082b25" name="ga8d60bb0ce4651304d10c6ddf47082b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d60bb0ce4651304d10c6ddf47082b25">&#9670;&#160;</a></span>EvrNetTCP_ListenSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ListenSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP listen socket request (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">port</td><td>local port number</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ListenSocket</b> is created, when the socket is set to the listening mode, that is, when the function <a class="el" href="group__tcp__user__api.html#gac02a84a9dc999e80c5a8a1650e5d9674">netTCP_Listen</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for listening.</li>
<li><b>port:</b> assigned local TCP port. </li>
</ul>

</div>
</div>
<a id="ga558df663217df72693592eba4c46171f" name="ga558df663217df72693592eba4c46171f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga558df663217df72693592eba4c46171f">&#9670;&#160;</a></span>EvrNetTCP_ListenSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ListenSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP listen failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ListenSocketNotValid</b> is created, when the internal function <em>tcp_listen</em> can not set the TCP socket to listening mode because the provided socket handle is not valid. This usually happens when the <a class="el" href="group__tcp__user__api.html#gac02a84a9dc999e80c5a8a1650e5d9674">netTCP_Listen</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for listening. </li>
</ul>

</div>
</div>
<a id="ga4dd8a3f2e654b4f3c0b34db236b73879" name="ga4dd8a3f2e654b4f3c0b34db236b73879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd8a3f2e654b4f3c0b34db236b73879">&#9670;&#160;</a></span>EvrNetTCP_ListenSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ListenSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP listen failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ListenSocketWrongState</b> is created, when the internal function <em>tcp_listen</em> can not set the TCP socket to listening mode because the socket is not closed. This usually happens when the <a class="el" href="group__tcp__user__api.html#gac02a84a9dc999e80c5a8a1650e5d9674">netTCP_Listen</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for listening.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga81e90189bb31c1b0027899493ab0060f" name="ga81e90189bb31c1b0027899493ab0060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e90189bb31c1b0027899493ab0060f">&#9670;&#160;</a></span>EvrNetTCP_MapFrameToSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_MapFrameToSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP received frame mapped to a socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>mapped socket handle </td></tr>
    <tr><td class="paramname">state</td><td>current socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>MapFrameToSocket</b> is created when the network library receives the TCP frame and maps the frame to an open TCP socket.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> mapped TCP socket handle.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="gac7f8a6deada5aacfea6d5aa376a06ba5" name="gac7f8a6deada5aacfea6d5aa376a06ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f8a6deada5aacfea6d5aa376a06ba5">&#9670;&#160;</a></span>EvrNetTCP_MapSocketNoListenSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_MapSocketNoListenSocket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP map socket failed, no listening sockets found (Error) </p>
<p>The event <b>MapSocketNoListenSocket</b> is created when the network library receives the TCP frame with SYN flag set, that is recognized as a connection request. The listening socket at the required port does not exist, so the received frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>error</b> </li>
</ul>

</div>
</div>
<a id="gaa3dd497f04005147ecf908568061b2a2" name="gaa3dd497f04005147ecf908568061b2a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3dd497f04005147ecf908568061b2a2">&#9670;&#160;</a></span>EvrNetTCP_MapSocketSynNotSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_MapSocketSynNotSet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP map socket failed, SYN-flag not set (Error) </p>
<p>The event <b>MapSocketSynNotSet</b> is created when the network library receives the TCP frame with SYN flag not set. The listening socket can not be assigned, the established connection also does not exist, so the received frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>error</b> </li>
</ul>

</div>
</div>
<a id="ga0dfd12e03806cdd4a0a2489d6e90cee0" name="ga0dfd12e03806cdd4a0a2489d6e90cee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dfd12e03806cdd4a0a2489d6e90cee0">&#9670;&#160;</a></span>EvrNetTCP_MapSocketWrongFlagsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_MapSocketWrongFlagsSet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP map socket failed, wrong TCP flags set (Error) </p>
<p>The event <b>MapSocketWrongFlagsSet</b> is created when the network library receives the TCP frame with SYN flag set, but other flags like FIN, RST or ACK are also set. The listening socket can not be assigned, so the received frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>error</b> </li>
</ul>

</div>
</div>
<a id="ga18de9978c7fc0c2547978ec3316b0f67" name="ga18de9978c7fc0c2547978ec3316b0f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18de9978c7fc0c2547978ec3316b0f67">&#9670;&#160;</a></span>EvrNetTCP_NextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_NextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP transition to next state (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>NextState</b> is created when the socket state changes to a new state. The state transition usually changes some internal variables and restarts some of the socket timers.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="gabc6c1f97b79d796fb805a5bca2bd6681" name="gabc6c1f97b79d796fb805a5bca2bd6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc6c1f97b79d796fb805a5bca2bd6681">&#9670;&#160;</a></span>EvrNetTCP_NoRetriesLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_NoRetriesLeft </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP no retries left (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>NoRetriesLeft</b> is created, when the retry timer expires and the socket is closing. Because no retries are left, the socket arbitrarily closes the connection by sending the reset packet.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gac4b46b4a2e8a72ef1e0b30b401b3fa3b" name="gac4b46b4a2e8a72ef1e0b30b401b3fa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b46b4a2e8a72ef1e0b30b401b3fa3b">&#9670;&#160;</a></span>EvrNetTCP_NoSocketAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_NoSocketAvailable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_socks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP get socket failed, no free socket available (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_socks</td><td>number of available TCP sockets</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>NoSocketAvailable</b> is created, when the internal function <em>tcp_get_socket</em> can not assign a free TCP socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga19247901cf1062d474d767ac68277ed3">netTCP_GetSocket</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>used:</b> number of already used sockets. </li>
</ul>

</div>
</div>
<a id="ga50f135d3c53ef9ff839233b431c83286" name="ga50f135d3c53ef9ff839233b431c83286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50f135d3c53ef9ff839233b431c83286">&#9670;&#160;</a></span>EvrNetTCP_OptionMss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_OptionMss </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP header option MSS (maximum segment size) (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">mss</td><td>maximum segment size</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>OptionMss</b> is created when the socket analyzes the options of the received TCP frame with SYN flag and finds the maximum segment size option.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>mss:</b> maximum segment size in bytes. </li>
</ul>

</div>
</div>
<a id="ga1a2b32f4cec602226316936d6bcccc92" name="ga1a2b32f4cec602226316936d6bcccc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a2b32f4cec602226316936d6bcccc92">&#9670;&#160;</a></span>EvrNetTCP_OutOfRangeSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_OutOfRangeSegment </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP out of range segment received (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>OutOfRangeSegment</b> is created when the connected socket receives the TCP frame with sequence number that is out of range. This happens when an error occured while processing the sequence number on the peer side. The frame is then discarded and the last valid sequence number is acknowledged again.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gaa01289acd546e6fc9146e9cacc980abd" name="gaa01289acd546e6fc9146e9cacc980abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa01289acd546e6fc9146e9cacc980abd">&#9670;&#160;</a></span>EvrNetTCP_ParseHeaderOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ParseHeaderOptions </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opt_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP parse header options (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">opt_length</td><td>length of header options</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ParseHeaderOptions</b> is created when the socket receives the TCP frame with SYN flag set and parses the TCP options, in particular the option maximum segment size.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>opt_len:</b> length of the TCP options. </li>
</ul>

</div>
</div>
<a id="ga5d89655e312a9e044a1e664c3537baea" name="ga5d89655e312a9e044a1e664c3537baea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d89655e312a9e044a1e664c3537baea">&#9670;&#160;</a></span>EvrNetTCP_PshAckInHalfClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_PshAckInHalfClosed </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP PSH+ACK-flags received in half closed state FIN_WAIT_2 (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>PshAckInHalfClosed</b> is created when the socket receives the TCP frame with the PSH and ACK flags set on closing. The remote peer is still open. The socket is in a half-closed state. The received data is delivered to the application.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga8da961c14765cf273bc8e80b58d2579f" name="ga8da961c14765cf273bc8e80b58d2579f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da961c14765cf273bc8e80b58d2579f">&#9670;&#160;</a></span>EvrNetTCP_ReceiveFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ReceiveFrame </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ip_version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP receive frame (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>frame length in bytes </td></tr>
    <tr><td class="paramname">ip_version</td><td>internet protocol version<ul>
<li>0: IPv4</li>
<li>1: IPv6</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ReceiveFrame</b> is created when the network library receives the TCP frame. The frame can come from any interface.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>len:</b> length of the received TCP frame in bytes.</li>
<li><b>ver:</b> IP protocol version of the received frame (IPv4, IPv6). </li>
</ul>

</div>
</div>
<a id="ga4950e24a7e460e6c99a742d495460703" name="ga4950e24a7e460e6c99a742d495460703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4950e24a7e460e6c99a742d495460703">&#9670;&#160;</a></span>EvrNetTCP_ReleaseSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ReleaseSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP release socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ReleaseSocket</b> is created when the TCP socket is released, that is, when the function <a class="el" href="group__tcp__user__api.html#ga20a5311ac374ab89995165de6e1dbe1c">netTCP_ReleaseSocket</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for release. </li>
</ul>

</div>
</div>
<a id="ga0eaa1a76c4d644ff5b04414378e789e1" name="ga0eaa1a76c4d644ff5b04414378e789e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eaa1a76c4d644ff5b04414378e789e1">&#9670;&#160;</a></span>EvrNetTCP_ReleaseSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ReleaseSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP release failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ReleaseSocketNotValid</b> is created, when the internal function <em>tcp_release_socket</em> can not release the TCP socket because the provided socket handle is not valid. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga20a5311ac374ab89995165de6e1dbe1c">netTCP_ReleaseSocket</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for release. </li>
</ul>

</div>
</div>
<a id="ga243ed0529ebc3a56b6007d3028577955" name="ga243ed0529ebc3a56b6007d3028577955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga243ed0529ebc3a56b6007d3028577955">&#9670;&#160;</a></span>EvrNetTCP_ReleaseSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ReleaseSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP release failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ReleaseSocketWrongState</b> is created, when the internal function <em>tcp_release_socket</em> can not release the TCP socket because the socket is not closed. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga20a5311ac374ab89995165de6e1dbe1c">netTCP_ReleaseSocket</a> function is executed. You must first close the socket before releasing it.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for release.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="gac9a540744193c2e0d4dd30d8d4e94ef6" name="gac9a540744193c2e0d4dd30d8d4e94ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9a540744193c2e0d4dd30d8d4e94ef6">&#9670;&#160;</a></span>EvrNetTCP_RemotePeerClosing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RemotePeerClosing </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP FIN-flag received, remote peer wants to close (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RemotePeerClosing</b> is created when the connected socket receives the TCP frame with the FIN flag set. This happens when the remote peer wants to close the connection. The socket sends all unacknowledged data, if any, and confirms closing of the socket.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga18ad833c3ae03fee6fb23e6a12bb07a0" name="ga18ad833c3ae03fee6fb23e6a12bb07a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18ad833c3ae03fee6fb23e6a12bb07a0">&#9670;&#160;</a></span>EvrNetTCP_RepeatedFin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RepeatedFin </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP repeated FIN-flag received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RepeatedFin</b> is created when the socket again receives the TCP frame with the FIN flag set during closing. The socket then sends an acknowledgement.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gac510c586418182e8d732018f46f404cc" name="gac510c586418182e8d732018f46f404cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac510c586418182e8d732018f46f404cc">&#9670;&#160;</a></span>EvrNetTCP_RepeatedSyn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RepeatedSyn </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP repeated SYN-flag set frame received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RepeatedSyn</b> is created when the socket receives the TCP frame with the SYN flag set again. If this happens when the socket is connected, then the the last valid sequence number is acknowledged again, otherwise the frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gac9b72a6664cffe5ba528f695494a3269" name="gac9b72a6664cffe5ba528f695494a3269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b72a6664cffe5ba528f695494a3269">&#9670;&#160;</a></span>EvrNetTCP_RepeatedSynAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RepeatedSynAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP repeated SYN+ACK-flags received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RepeatedSynAck</b> is created when the connected socket receives the TCP frame with the SYN and ACK flags again, but the socket is already connected. This usually happens when our acknowledgement is lost. The frame is therefore acknowledged again.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga90ea9458a5b777b7865a8aca34b04ceb" name="ga90ea9458a5b777b7865a8aca34b04ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ea9458a5b777b7865a8aca34b04ceb">&#9670;&#160;</a></span>EvrNetTCP_ResendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResendData </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP resend data from transmit queue (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">length</td><td>length of the data to resend </td></tr>
    <tr><td class="paramname">tout</td><td>retry timeout in 100ms ticks</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResendData</b> is created when the connected socket does not receive the acknowledgement for the data and the retransmit timer expires. This happens when our transmitted data frame is lost. The socket then resends the data and sets the new retransmit timeout using the exponential backoff algorithm.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>len:</b> length of the data to resend.</li>
<li><b>tout:</b> new retransmit timeout in ms. </li>
</ul>

</div>
</div>
<a id="ga2a48ef7d2e645b8c39a116d2864d569f" name="ga2a48ef7d2e645b8c39a116d2864d569f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a48ef7d2e645b8c39a116d2864d569f">&#9670;&#160;</a></span>EvrNetTCP_ResendOnTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResendOnTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP resend data on timeout (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">length</td><td>length of data to resend</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResendOnTimeout</b> is created, when the acknowledge timer expires, and the network library must retransmit the undelivered data.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>len:</b> length of the undelivered data. </li>
</ul>

</div>
</div>
<a id="gaea2adad45a2417f72055dc94f3b169d1" name="gaea2adad45a2417f72055dc94f3b169d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea2adad45a2417f72055dc94f3b169d1">&#9670;&#160;</a></span>EvrNetTCP_ResetWindowNoFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResetWindowNoFlowControl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP reset window failed, flow-control not enabled (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResetWindowNoFlowControl</b> is created, when the internal function <em>tcp_reset_window</em> can not reset the full size window because the TCP flow-control is not enabled for the socket. This happens when the <a class="el" href="group__tcp__user__api.html#ga4bad195ba75c21a5e03a40d13adee3e7">netTCP_ResetReceiveWindow</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for receive window update. </li>
</ul>

</div>
</div>
<a id="ga7f15f12246d3283f2dcc3040cbba2a08" name="ga7f15f12246d3283f2dcc3040cbba2a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f15f12246d3283f2dcc3040cbba2a08">&#9670;&#160;</a></span>EvrNetTCP_ResetWindowNotConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResetWindowNotConnected </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP reset window failed, invalid socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResetWindowNotConnected</b> is created, when the internal function <em>tcp_reset_window</em> can not reset the full size window because the socket is not connected. This happens when the <a class="el" href="group__tcp__user__api.html#ga4bad195ba75c21a5e03a40d13adee3e7">netTCP_ResetReceiveWindow</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for receive window update. </li>
</ul>

</div>
</div>
<a id="gab71d12870266f7dbebf936a9ccbe2b6c" name="gab71d12870266f7dbebf936a9ccbe2b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab71d12870266f7dbebf936a9ccbe2b6c">&#9670;&#160;</a></span>EvrNetTCP_ResetWindowSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResetWindowSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP reset window failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResetWindowSocketNotValid</b> is created, when the internal function <em>tcp_reset_window</em> can not reset the full size window because the provided socket handle is invalid. This happens when the <a class="el" href="group__tcp__user__api.html#ga4bad195ba75c21a5e03a40d13adee3e7">netTCP_ResetReceiveWindow</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for receive window update. </li>
</ul>

</div>
</div>
<a id="ga5a44caeefb9a272c1fe49bca823e7043" name="ga5a44caeefb9a272c1fe49bca823e7043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a44caeefb9a272c1fe49bca823e7043">&#9670;&#160;</a></span>EvrNetTCP_ResetWindowUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ResetWindowUpdate </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>window_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP reset window update (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">window_size</td><td>updated receive window size</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ResetWindowUpdate</b> is created, when the internal function <em>tcp_reset_window</em> sends a TCP Window update frame. This happens when the <a class="el" href="group__tcp__user__api.html#ga4bad195ba75c21a5e03a40d13adee3e7">netTCP_ResetReceiveWindow</a> function is executed and the receive window is reduced.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for receive window update.</li>
<li><b>window_size:</b> updated window size for receiving. </li>
</ul>

</div>
</div>
<a id="gad489876037d877a1310ffb74a8c6a005" name="gad489876037d877a1310ffb74a8c6a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad489876037d877a1310ffb74a8c6a005">&#9670;&#160;</a></span>EvrNetTCP_RetransmittedSegment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RetransmittedSegment </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP retransmitted frame received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RetransmittedSegment</b> is created when the connected socket receives the TCP frame with data that is recognized as a retransmitted packet. This happens when our acknowledgement is lost. The frame is therefore acknowledged again.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gae4c8d4f803cfeb08405ca18282508346" name="gae4c8d4f803cfeb08405ca18282508346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4c8d4f803cfeb08405ca18282508346">&#9670;&#160;</a></span>EvrNetTCP_RstInWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RstInWindow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP RST-flag received within current receive window (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RstInWindow</b> is created when the connected socket receives the TCP frame with the RST flag set and the sequence is within the current receive window. The socket then sends a challenge ACK frame.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga7d27f20645ef1821a2b5aa2ca5b6b8bc" name="ga7d27f20645ef1821a2b5aa2ca5b6b8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d27f20645ef1821a2b5aa2ca5b6b8bc">&#9670;&#160;</a></span>EvrNetTCP_RstNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RstNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP RST-flag received outside current receive window (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RstNotValid</b> is created when the connected socket receives the TCP frame with the RST flag set and the sequence is outside the current receive window. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gad9b5d1e25be1916c6df2cb3519fad032" name="gad9b5d1e25be1916c6df2cb3519fad032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9b5d1e25be1916c6df2cb3519fad032">&#9670;&#160;</a></span>EvrNetTCP_RstReceived()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_RstReceived </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP RST-flag received (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>RstReceived</b> is created when the socket receives the TCP frame with the RST flag set. The socket is then closed in client mode, or listening is reactivated in server mode.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga457e530d907d711dd08745e591478c54" name="ga457e530d907d711dd08745e591478c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga457e530d907d711dd08745e591478c54">&#9670;&#160;</a></span>EvrNetTCP_SendBufferInvalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendBufferInvalid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, invalid buffer (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendBufferInvalid</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame, because the send buffer is invalid. This happens when the sending buffer is not allocated from <a class="el" href="group__tcp__user__api.html#ga361ee211c7cd20ca32c266aec90d60ff">netTCP_GetBuffer</a> function.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga935140d8a00f81f39aff0db5daeec863" name="ga935140d8a00f81f39aff0db5daeec863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga935140d8a00f81f39aff0db5daeec863">&#9670;&#160;</a></span>EvrNetTCP_SendControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendControl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send control frame (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendControl</b> is created when the TCP frame header is constructed and the frame with no data is sent to IP layer for further processing and transmit.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga8081b2a0f691faa47f88303dd3d72413" name="ga8081b2a0f691faa47f88303dd3d72413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8081b2a0f691faa47f88303dd3d72413">&#9670;&#160;</a></span>EvrNetTCP_SendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendData </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send data frame (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">length</td><td>data length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendData</b> is created when the TCP frame header is constructed and the frame with data is sent to IP layer for further processing and transmit.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle.</li>
<li><b>len:</b> length of the TCP frame payload. </li>
</ul>

</div>
</div>
<a id="gae7b21676e68abaf97d8970f9f6b5562d" name="gae7b21676e68abaf97d8970f9f6b5562d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b21676e68abaf97d8970f9f6b5562d">&#9670;&#160;</a></span>EvrNetTCP_SendDataUnacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendDataUnacked </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, unacked data pending (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendDataUnacked</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because data is already waiting for acknowledge and there is no room for adding more data. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga7ec61df4f44d9e2d894208f338da0c71" name="ga7ec61df4f44d9e2d894208f338da0c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec61df4f44d9e2d894208f338da0c71">&#9670;&#160;</a></span>EvrNetTCP_SendDelayedAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendDelayedAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send delayed-acknowledge (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendDelayedAck</b> is created, when the delay timer expires, the acknowledge request is pending and the delayed acknowledgement is active.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gad135ca1b002f8a1b7546e1b6338b554a" name="gad135ca1b002f8a1b7546e1b6338b554a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad135ca1b002f8a1b7546e1b6338b554a">&#9670;&#160;</a></span>EvrNetTCP_SendFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendFrame </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send frame (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">length</td><td>frame length in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendFrame</b> is created when the TCP frame header is constructed and the frame is sent to IP layer for further processing and transmit.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle.</li>
<li><b>len:</b> length of the TCP frame payload. </li>
</ul>

</div>
</div>
<a id="ga79689cb4e6b63e0e7d4b6f0881720d3a" name="ga79689cb4e6b63e0e7d4b6f0881720d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79689cb4e6b63e0e7d4b6f0881720d3a">&#9670;&#160;</a></span>EvrNetTCP_SendKeepAliveProbe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendKeepAliveProbe </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send keep-alive probe (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendKeepAliveProbe</b> is created, when the keepalive timer expires, and the keepalive mode is enabled for the socket. The network library sends the keepalive probe to retain the connection.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga123a83e759a8a9d32dfaa351218738d8" name="ga123a83e759a8a9d32dfaa351218738d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga123a83e759a8a9d32dfaa351218738d8">&#9670;&#160;</a></span>EvrNetTCP_SendMssExceeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendMssExceeded </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, Maximum Segment Size exceeded (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Frame length is larger than MSS.</dd></dl>
<p>The event <b>SendMssExceeded</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because length of the data is too large. This occurs when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed for a length that is above the maximum length obtained by <a class="el" href="group__tcp__user__api.html#gad8393d4e967564107799400710c94521">netTCP_GetMaxSegmentSize</a> function and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="gad7f03feef835e0694374d94a5e687c46" name="gad7f03feef835e0694374d94a5e687c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f03feef835e0694374d94a5e687c46">&#9670;&#160;</a></span>EvrNetTCP_SendReadyReenteredCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendReadyReenteredCall </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send ready failed, called from a callback function (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendReadyReenteredCall</b> is created, when the socket status query fails because it is called from an illegal context, that is, from a socket callback function. This happens when the <a class="el" href="group__tcp__user__api.html#ga5770081776ef5a657b984a9ee600c149">netTCP_SendReady</a> function is executed from the callback function of the same socket.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for query. </li>
</ul>

</div>
</div>
<a id="ga93f0db538ca6777b7ef9d76a288cf7a8" name="ga93f0db538ca6777b7ef9d76a288cf7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f0db538ca6777b7ef9d76a288cf7a8">&#9670;&#160;</a></span>EvrNetTCP_SendReadySocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendReadySocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send ready failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendReadySocketNotValid</b> is created, when the socket status query fails because the provided socket handle is invalid. This happens when the <a class="el" href="group__tcp__user__api.html#ga5770081776ef5a657b984a9ee600c149">netTCP_SendReady</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for query. </li>
</ul>

</div>
</div>
<a id="ga96f40823aed258059e7f380c86b423e8" name="ga96f40823aed258059e7f380c86b423e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f40823aed258059e7f380c86b423e8">&#9670;&#160;</a></span>EvrNetTCP_SendReenteredCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendReenteredCall </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, called from a callback function (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendReenteredCall</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because it is called from an illegal context, that is, from a socket callback function. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed from the callback function of the same socket and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga6ef37c8d20f224429cfc6d516e65ccb6" name="ga6ef37c8d20f224429cfc6d516e65ccb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ef37c8d20f224429cfc6d516e65ccb6">&#9670;&#160;</a></span>EvrNetTCP_SendReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send reset to remote host for unmapped frame (Op) </p>
<p>The event <b>SendReset</b> is created when the TCP frame with RST flag set is constructed and the frame with no data is sent to IP layer for further processing and transmit.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>rst</b> </li>
</ul>

</div>
</div>
<a id="ga4c3a43fa79b486e32e466e1878c3861f" name="ga4c3a43fa79b486e32e466e1878c3861f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c3a43fa79b486e32e466e1878c3861f">&#9670;&#160;</a></span>EvrNetTCP_SendSocketClosing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendSocketClosing </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, socket closing (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendSocketClosing</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because the socket is currently closing. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="gabaa0eb4a3daac242ac86ea2b723281ef" name="gabaa0eb4a3daac242ac86ea2b723281ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa0eb4a3daac242ac86ea2b723281ef">&#9670;&#160;</a></span>EvrNetTCP_SendSocketNotConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendSocketNotConnected </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, socket not connected (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendSocketNotConnected</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because the socket is not connected. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga84d8a2d62b8efe1975126cd2fadf6506" name="ga84d8a2d62b8efe1975126cd2fadf6506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d8a2d62b8efe1975126cd2fadf6506">&#9670;&#160;</a></span>EvrNetTCP_SendSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send failed, socket handle not valid (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendSocketNotValid</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because the provided socket handle is invalid. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga9cceb4554b1e724e1dca5d2561520d43" name="ga9cceb4554b1e724e1dca5d2561520d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cceb4554b1e724e1dca5d2561520d43">&#9670;&#160;</a></span>EvrNetTCP_SendZeroLengthFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SendZeroLengthFrame </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP send 0-length frame, frame dumped (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SendZeroLengthFrame</b> is created, when the internal function <em>tcp_send</em> can not send the TCP frame because the length of the data is zero. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga0b32a74e8fc2d3d3fcea041d3958f4e6">netTCP_Send</a> function is executed and the sending frame is discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle. </li>
</ul>

</div>
</div>
<a id="ga07ca87cbe117998c1a7088f1d8877e4d" name="ga07ca87cbe117998c1a7088f1d8877e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ca87cbe117998c1a7088f1d8877e4d">&#9670;&#160;</a></span>EvrNetTCP_SetOptionDelayedAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionDelayedAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket delayed-acknowledge option (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">enable</td><td>delayed-acknowledge state value<ul>
<li>0: disable</li>
<li>1: enable</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionDelayedAck</b> is created, when the internal function <em>tcp_set_option</em> enables or disables the delayed acknowledgement for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>enable:</b> controlling the delayed acknowledgement (1= enable, 0= disable). </li>
</ul>

</div>
</div>
<a id="ga5fb736e03519df4ff454aa002f05cc0d" name="ga5fb736e03519df4ff454aa002f05cc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb736e03519df4ff454aa002f05cc0d">&#9670;&#160;</a></span>EvrNetTCP_SetOptionFlowControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionFlowControl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket flow-control option (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">enable</td><td>flow-control state value<ul>
<li>0: disable</li>
<li>1: enable</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionFlowControl</b> is created, when the internal function <em>tcp_set_option</em> enables or disables the TCP flow control mode for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>enable:</b> controlling the TCP flow control mode (1= enable, 0= disable). </li>
</ul>

</div>
</div>
<a id="ga6884ad095ecc56f1a676c51ad49b5584" name="ga6884ad095ecc56f1a676c51ad49b5584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6884ad095ecc56f1a676c51ad49b5584">&#9670;&#160;</a></span>EvrNetTCP_SetOptionKeepAlive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionKeepAlive </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket keep-alive option (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">enable</td><td>keep-alive state value<ul>
<li>0: disable</li>
<li>1: enable</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionKeepAlive</b> is created, when the internal function <em>tcp_set_option</em> enables or disables the keepalive mode for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>enable:</b> controlling the keepalive mode (1= enable, 0= disable). </li>
</ul>

</div>
</div>
<a id="ga753b2d11bb803db1a9bf4f27b3d457d5" name="ga753b2d11bb803db1a9bf4f27b3d457d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753b2d11bb803db1a9bf4f27b3d457d5">&#9670;&#160;</a></span>EvrNetTCP_SetOptionSocket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">option</td><td>interface option as specified by <a class="el" href="group__netTCP__Enums.html#ga5866dd2ae379ba30a83a9ea1a0c82fdd">netTCP_Option</a> </td></tr>
    <tr><td class="paramname">val</td><td>option value</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionSocket</b> is created, when the internal function <em>tcp_set_option</em> sets the operating option for the TCP socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>opt:</b> option to be set.</li>
<li><b>val:</b> value for the setting option. </li>
</ul>

</div>
</div>
<a id="ga80d73b5d799778015fa330500bd5bdcd" name="ga80d73b5d799778015fa330500bd5bdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80d73b5d799778015fa330500bd5bdcd">&#9670;&#160;</a></span>EvrNetTCP_SetOptionSocketNotValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionSocketNotValid </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option failed, not valid socket (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionSocketNotValid</b> is created, when the internal function <em>tcp_set_option</em> can not set the TCP socket option because the provided socket handle is invalid. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option. </li>
</ul>

</div>
</div>
<a id="gabbe697016f06fd021ab10d21e6b8e4c4" name="gabbe697016f06fd021ab10d21e6b8e4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbe697016f06fd021ab10d21e6b8e4c4">&#9670;&#160;</a></span>EvrNetTCP_SetOptionSocketWrongState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionSocketWrongState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option failed, wrong socket state (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionSocketWrongState</b> is created, when the internal function <em>tcp_set_option</em> can not set the TCP socket option because the socket is not created. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed. Before you set the socket option, you must first allocate the socket.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>state:</b> state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga9960e0b3c5e88954e55efc03fb18960d" name="ga9960e0b3c5e88954e55efc03fb18960d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9960e0b3c5e88954e55efc03fb18960d">&#9670;&#160;</a></span>EvrNetTCP_SetOptionTclass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionTclass </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ip6_tclass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option Traffic Class for IPv6 (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">ip6_tclass</td><td>traffic class value</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionTclass</b> is created, when the internal function <em>tcp_set_option</em> sets the TClass (IPv6 Traffic Class) for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>tclass:</b> value for TClass option. </li>
</ul>

</div>
</div>
<a id="ga5db93183863758c46ab59ce0c2f3aa24" name="ga5db93183863758c46ab59ce0c2f3aa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5db93183863758c46ab59ce0c2f3aa24">&#9670;&#160;</a></span>EvrNetTCP_SetOptionTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionTimeout </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option connection timeout (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">timeout</td><td>connection or keep-alive timeout in seconds</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionTimeout</b> is created, when the internal function <em>tcp_set_option</em> sets the connection timeout or keepalive interval for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>tout:</b> value for connection timeout or keepalive interval. </li>
</ul>

</div>
</div>
<a id="gaec8f0bf59cf521e3bc07ee540b57e3c1" name="gaec8f0bf59cf521e3bc07ee540b57e3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8f0bf59cf521e3bc07ee540b57e3c1">&#9670;&#160;</a></span>EvrNetTCP_SetOptionTos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionTos </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ip4_tos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP set socket option Type Of Service for IPv4 (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">ip4_tos</td><td>type of service value</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionTos</b> is created, when the internal function <em>tcp_set_option</em> sets the TOS (IPv4 Type of Service) for the socket. This usually happens when the <a class="el" href="group__tcp__user__api.html#ga574cc756d0ab2fb8e4719befd7c56913">netTCP_SetOption</a> function is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>tos:</b> value for TOS option. </li>
</ul>

</div>
</div>
<a id="ga2831613b19062dbc90ea2719cd0dfd6f" name="ga2831613b19062dbc90ea2719cd0dfd6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2831613b19062dbc90ea2719cd0dfd6f">&#9670;&#160;</a></span>EvrNetTCP_SetOptionWrongOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionWrongOption </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>tcp_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP wrong set socket option (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">tcp_option</td><td>wrong set option value</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionWrongOption</b> is created, when the internal function <em>tcp_set_option</em> can not set the TCP socket option because the requested option is not supported. This can happen when attempting to set the IPv6 option in IPv4-Only Network library.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>opt:</b> requested option to set. </li>
</ul>

</div>
</div>
<a id="gac6819f627f2ba4946734ffa4c611e73f" name="gac6819f627f2ba4946734ffa4c611e73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6819f627f2ba4946734ffa4c611e73f">&#9670;&#160;</a></span>EvrNetTCP_SetOptionWrongValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SetOptionWrongValue </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opt_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP wrong value for set socket option (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">opt_value</td><td>wrong value for set option</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SetOptionWrongValue</b> is created, when the internal function <em>tcp_set_option</em> can not set the TCP socket option because the option value is invalid. This usually happens when the option value is out of range.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for setting the option.</li>
<li><b>value:</b> option value that is invalid. </li>
</ul>

</div>
</div>
<a id="ga5c32a997ea7f3e7192968ec27fde95f0" name="ga5c32a997ea7f3e7192968ec27fde95f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c32a997ea7f3e7192968ec27fde95f0">&#9670;&#160;</a></span>EvrNetTCP_ShowCongestionVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowCongestionVariables </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cwnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ssth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display congestion avoidance/control variables (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">cwnd</td><td>congestion window </td></tr>
    <tr><td class="paramname">ssth</td><td>slow start threshold</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ShowCongestionVariables</b> is created when the network library wants to display the variables, that are used to prevent congestion. Variables control the slow-start and congestion avoidance algorithms for the TCP connection.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>cwnd:</b> congestion window.</li>
<li><b>ssth:</b> slow start threshold. </li>
</ul>

</div>
</div>
<a id="ga1c00ed778bbd5dd910339c966950da4d" name="ga1c00ed778bbd5dd910339c966950da4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c00ed778bbd5dd910339c966950da4d">&#9670;&#160;</a></span>EvrNetTCP_ShowFrameHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowFrameHeader </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>tcp_header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display send/receive frame header (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcp_header</td><td>pointer to TCP frame header of 20 bytes<ul>
<li>SrcPort (2 bytes)</li>
<li>DstPort (2 bytes)</li>
<li>SeqNr (4 bytes)</li>
<li>AckNr (4 bytes)</li>
<li>HLen (1 byte)</li>
<li>Flags (1 byte)</li>
<li>Window (2 bytes)</li>
<li>Chksum (2 bytes)</li>
<li>UrgPtr (2 bytes)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ShowFrameHeader</b> is created when the network library wants to display detailed information about the TCP header.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>dport:</b> destination TCP port.</li>
<li><b>sport:</b> source TCP port.</li>
<li><b>seq:</b> send sequence number.</li>
<li><b>ack:</b> acknowledge sequence number.</li>
<li><b>flags:</b> TCP frame flags.</li>
<li><b>win:</b> receive window size.</li>
<li><b>cksum:</b> frame checksum. </li>
</ul>

</div>
</div>
<a id="gaf45da68d3e7aefcdbe2f28ee6e43b6cc" name="gaf45da68d3e7aefcdbe2f28ee6e43b6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf45da68d3e7aefcdbe2f28ee6e43b6cc">&#9670;&#160;</a></span>EvrNetTCP_ShowNetAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowNetAddress </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>net_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display net address (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">net_addr</td><td>pointer to <a class="el" href="group__network__structs.html#structNET__ADDR">NET_ADDR</a> address structure</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ShowNetAddress</b> is created when the network library wants to display the contents of the network address structure, that is, the IP address and the port number.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>ip:</b> IPv4 or IPv6 address.</li>
<li><b>port:</b> port number. </li>
</ul>

</div>
</div>
<a id="ga656706dcb11ca4730978ec5d4620d032" name="ga656706dcb11ca4730978ec5d4620d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga656706dcb11ca4730978ec5d4620d032">&#9670;&#160;</a></span>EvrNetTCP_ShowReceiveWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowReceiveWindow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rec_window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display current receiving window size (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">rec_window</td><td>current receiving window size</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ShowReceiveWindo</b> is created when the connected socket wants to display the current size of the receive window.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>rec_win:</b> current receive window. </li>
</ul>

</div>
</div>
<a id="gaf5d20729d13eceb06fc331b3f02ef8d4" name="gaf5d20729d13eceb06fc331b3f02ef8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d20729d13eceb06fc331b3f02ef8d4">&#9670;&#160;</a></span>EvrNetTCP_ShowRttVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowRttVariables </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>sv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display RTT (round trip time) estimation variables (Detail) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">sa</td><td>rtt average estimator </td></tr>
    <tr><td class="paramname">sv</td><td>rtt deviation estimator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Those variables are taken from VJs original code in his paper. (Congestion avoidance and control, page 20)</dd></dl>
<p>The event <b>ShowRttVariables</b> is created when the network library wants to display the round trip time estimation variables, that are used to avoid congestion. The variables are from Van Jacobson's Congestion Avoidance and Control.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>rto:</b> calculated retransmit timeout interval in ms.</li>
<li><b>sa:</b> RTT average estimator.</li>
<li><b>sv:</b> RTT deviation estimator. </li>
</ul>

</div>
</div>
<a id="gab93d8ea699c093dd05560f3d9c7d4d3a" name="gab93d8ea699c093dd05560f3d9c7d4d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93d8ea699c093dd05560f3d9c7d4d3a">&#9670;&#160;</a></span>EvrNetTCP_ShowSendWindow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ShowSendWindow </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>send_window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP display current sending window size (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">send_window</td><td>current sending window size</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ShowSendWindow</b> is created when the connected socket wants to display the current size of the send window.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>send_win:</b> current send window. </li>
</ul>

</div>
</div>
<a id="ga99894ec10c8dd97076a529bfe5fb78b7" name="ga99894ec10c8dd97076a529bfe5fb78b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99894ec10c8dd97076a529bfe5fb78b7">&#9670;&#160;</a></span>EvrNetTCP_SimultCloseNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SimultCloseNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame with FIN-flag received in simultaneous close (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SimultCloseNextState</b> is created when the socket receives the TCP frame with the FIN flag set and identifies it as the simultaneous closing on both sides. The socket sends an acknowledgement and the state changes to the next state.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="gae74b0b1bfb7ccf47887df686aa352d46" name="gae74b0b1bfb7ccf47887df686aa352d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74b0b1bfb7ccf47887df686aa352d46">&#9670;&#160;</a></span>EvrNetTCP_SimultOpenNextState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SimultOpenNextState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP SYN-flag set received in simultaneous open (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>next socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SimultOpenNextState</b> is created when the socket receives the TCP frame with the SYN flag set and identifies it as being simultaneously opened from both sides. The socket sends acknowledge and proceeds to establish a connection.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>next:</b> next state of the socket. </li>
</ul>

</div>
</div>
<a id="ga1094d6ad120107a5b5a6504f03f53b1a" name="ga1094d6ad120107a5b5a6504f03f53b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1094d6ad120107a5b5a6504f03f53b1a">&#9670;&#160;</a></span>EvrNetTCP_SynNotSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_SynNotSet </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP SYN-flag not set in received frame (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>SynNotSet</b> is created when the listening socket receives the TCP frame with the SYN flag not set. This might happen, if the remote peer has a phantom socket still open. The socket then sends a reset frame to the remote peer.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga78d289bee07ca5feab94b9ac4b8c0375" name="ga78d289bee07ca5feab94b9ac4b8c0375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78d289bee07ca5feab94b9ac4b8c0375">&#9670;&#160;</a></span>EvrNetTCP_TimeoutInState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_TimeoutInState </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP timeout expired in current state (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle </td></tr>
    <tr><td class="paramname">state</td><td>current socket state</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>TimeoutInState</b> is created, when the retry timer expires, and the network library must resend the control packet.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection.</li>
<li><b>state:</b> current state of the TCP socket. </li>
</ul>

</div>
</div>
<a id="ga355097aeea01dc7c83dfd854b5d3f916" name="ga355097aeea01dc7c83dfd854b5d3f916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga355097aeea01dc7c83dfd854b5d3f916">&#9670;&#160;</a></span>EvrNetTCP_TwaitTimeoutClosing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_TwaitTimeoutClosing </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP timeout in TIME_WAIT state, closing socket (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>TwaitTimeoutClosing</b> is created, when the retry timer expires in the time-wait state of the TCP socket. The socket is then closed in client mode, or listening is reactivated in server mode.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga8b483ddac06b0814fe46de1984a7d02b" name="ga8b483ddac06b0814fe46de1984a7d02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b483ddac06b0814fe46de1984a7d02b">&#9670;&#160;</a></span>EvrNetTCP_UninitSockets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_UninitSockets </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP de-initialize available sockets (Op) </p>
<p>The event <b>UninitSockets</b> is created when the function <a class="el" href="group__netSys__Func.html#gaeccbc594239e8a091514b5c225a642bf">netUninitialize</a> is executed.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>tcp</b> </li>
</ul>

</div>
</div>
<a id="ga6eadf3f87b677a3710235db7800836c2" name="ga6eadf3f87b677a3710235db7800836c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eadf3f87b677a3710235db7800836c2">&#9670;&#160;</a></span>EvrNetTCP_UserConnectionReject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_UserConnectionReject </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP user rejected inbound connection (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>UserConnectionReject</b> is created when the listening socket receives the TCP frame with the SYN flag set, but the user application has rejected this incoming connection from the callback function. The socket sends a reset frame to the remote peer.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga6dbbae2a0f004ce7dd313900fc9b7a45" name="ga6dbbae2a0f004ce7dd313900fc9b7a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dbbae2a0f004ce7dd313900fc9b7a45">&#9670;&#160;</a></span>EvrNetTCP_WrongAckNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_WrongAckNumber </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP ACK-flag set but wrong ack number (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>WrongAckNumber</b> is created when the socket receives the TCP frame with the ACK flags set, but the acknowledge number is not correct. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gaf616347d36b5851002de6217a000467d" name="gaf616347d36b5851002de6217a000467d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf616347d36b5851002de6217a000467d">&#9670;&#160;</a></span>EvrNetTCP_WrongFinAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_WrongFinAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP frame with FIN+ACK-flags set but wrong ack number (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>WrongFinAck</b> is created when the socket receives the TCP frame with the FIN and ACK flags set, but the acknowledge number is not correct. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga697dd3899ab0043d087f194636729078" name="ga697dd3899ab0043d087f194636729078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga697dd3899ab0043d087f194636729078">&#9670;&#160;</a></span>EvrNetTCP_WrongSeqNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_WrongSeqNumber </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP ACK-flag set but wrong seq number (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>WrongSeqNumber</b> is created when the socket receives the TCP frame with the ACK flag set, but the sequence number is not correct. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="gaa32a0d8e2aa7043fe1cc2f3f47579e71" name="gaa32a0d8e2aa7043fe1cc2f3f47579e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa32a0d8e2aa7043fe1cc2f3f47579e71">&#9670;&#160;</a></span>EvrNetTCP_WrongSynAck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_WrongSynAck </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP SYN+ACK-flags set but wrong ack number (Error) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>WrongSynAck</b> is created when the socket receives the TCP frame with the SYN and ACK flags set, but the sequence number is not correct. The frame is therefore discarded.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
<a id="ga588cfd224ef168a0c68aa9f3246ae4a6" name="ga588cfd224ef168a0c68aa9f3246ae4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga588cfd224ef168a0c68aa9f3246ae4a6">&#9670;&#160;</a></span>EvrNetTCP_ZeroWindowProbe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="net__evr_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void EvrNetTCP_ZeroWindowProbe </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event on TCP zero-window probe received (Op) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>socket handle</td></tr>
  </table>
  </dd>
</dl>
<p>The event <b>ZeroWindowProbe</b> is created when the connected socket receives the TCP frame with data that is recognized as a zero window probe packet. This happens when our receive window is closed, and remote peer wants to check this. The frame is then discarded and the last valid sequence number is acknowledged again.</p>
<p><b>Value</b> in the Event Recorder shows:</p><ul>
<li><b>socket:</b> TCP socket handle for connection. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
